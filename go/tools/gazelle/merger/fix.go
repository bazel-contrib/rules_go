/* Copyright 2017 The Bazel Authors. All rights reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package merger

import (
	"log"
	"sort"

	bf "github.com/bazelbuild/buildtools/build"
	"github.com/bazelbuild/rules_go/go/tools/gazelle/config"
)

// FixFile updates rules in oldFile that were generated by an older version of
// Gazelle to a newer form that can be merged with freshly generated rules.
//
// MergeWithExisting should be called after this, since it will fix load
// statements that may be broken by transformations applied by this function.
func FixFile(oldFile *bf.File) *bf.File {
	return squashCgoLibrary(oldFile)
}

// squashCgoLibrary removes cgo_library rules with the default name and
// merges their attributes with go_library with the default name. If no
// go_library rule exists, a new one will be created.
//
// Note that the library attribute is disregarded, so cgo_library and
// go_library attributes will be squashed even if the cgo_library was unlinked.
// MergeWithExisting will remove unused values and attributes later.
func squashCgoLibrary(oldFile *bf.File) *bf.File {
	// Find the default cgo_library and go_library rules.
	var cgoLibrary, goLibrary bf.Rule
	cgoLibraryIndex := -1
	goLibraryIndex := -1

	for i, stmt := range oldFile.Stmt {
		c, ok := stmt.(*bf.CallExpr)
		if !ok {
			continue
		}
		r := bf.Rule{Call: c}
		if r.Kind() == "cgo_library" && r.Name() == config.DefaultCgoLibName && !shouldKeep(c) {
			if cgoLibrary.Call != nil {
				log.Printf("%s: when fixing existing file, multiple cgo_library rules with default name found", oldFile.Path)
				continue
			}
			cgoLibrary = r
			cgoLibraryIndex = i
			continue
		}
		if r.Kind() == "go_library" && r.Name() == config.DefaultLibName {
			if goLibrary.Call != nil {
				log.Printf("%s: when fixing existing file, multiple go_library rules with default name referencing cgo_library found", oldFile.Path)
				continue
			}
			goLibrary = r
			goLibraryIndex = i
		}
	}

	if cgoLibrary.Call == nil {
		return oldFile
	}

	// If go_library has a '# keep' comment, just delete cgo_library.
	if goLibrary.Call != nil && shouldKeep(goLibrary.Call) {
		fixedFile := *oldFile
		fixedFile.Stmt = append(fixedFile.Stmt[:cgoLibraryIndex], fixedFile.Stmt[cgoLibraryIndex+1:]...)
		return &fixedFile
	}

	// Copy the comments and attributes from cgo_library into go_library. If no
	// go_library exists, create an empty one.
	var fixedGoLibraryExpr bf.CallExpr
	fixedGoLibrary := bf.Rule{&fixedGoLibraryExpr}
	if goLibrary.Call == nil {
		fixedGoLibrary.SetKind("go_library")
		fixedGoLibrary.SetAttr("name", &bf.StringExpr{Value: config.DefaultLibName})
		if vis := cgoLibrary.Attr("visibility"); vis != nil {
			fixedGoLibrary.SetAttr("visibility", vis)
		}
	} else {
		fixedGoLibraryExpr = *goLibrary.Call
		fixedGoLibraryExpr.List = append([]bf.Expr{}, goLibrary.Call.List...)
	}

	fixedGoLibrary.DelAttr("library")
	fixedGoLibrary.SetAttr("cgo", &bf.LiteralExpr{Token: "True"})

	fixedGoLibraryExpr.Comments.Before = append(fixedGoLibraryExpr.Comments.Before, cgoLibrary.Call.Comments.Before...)
	fixedGoLibraryExpr.Comments.Suffix = append(fixedGoLibraryExpr.Comments.Suffix, cgoLibrary.Call.Comments.Suffix...)
	fixedGoLibraryExpr.Comments.After = append(fixedGoLibraryExpr.Comments.After, cgoLibrary.Call.Comments.After...)

	for _, key := range []string{"cdeps", "clinkopts", "copts", "data", "deps", "gc_goopts", "srcs"} {
		goLibraryAttr := fixedGoLibrary.Attr(key)
		cgoLibraryAttr := cgoLibrary.Attr(key)
		if cgoLibraryAttr == nil {
			continue
		}
		if fixedAttr, err := squashExpr(goLibraryAttr, cgoLibraryAttr); err == nil {
			fixedGoLibrary.SetAttr(key, fixedAttr)
		}
	}

	// Rebuild the file with the cgo_library removed and the go_library replaced.
	// If the go_library didn't already exist, it will replace cgo_library.
	fixedFile := *oldFile
	if goLibrary.Call == nil {
		fixedFile.Stmt = append([]bf.Expr{}, oldFile.Stmt...)
		fixedFile.Stmt[cgoLibraryIndex] = &fixedGoLibraryExpr
	} else {
		fixedFile.Stmt = append(oldFile.Stmt[:cgoLibraryIndex], oldFile.Stmt[cgoLibraryIndex+1:]...)
		if goLibraryIndex > cgoLibraryIndex {
			goLibraryIndex--
		}
		fixedFile.Stmt[goLibraryIndex] = &fixedGoLibraryExpr
	}
	return &fixedFile
}

// squashExpr combines two expressions. Unlike mergeExpr, squashExpr does not
// discard information from an "old" expression. It does not sort or de-duplicate
// elements. The following kinds of expressions are recognized:
//
//   * nil
//   * lists
//   * calls to select with a dict argument. The dict keys must be strings,
//     and the values must be lists.
//   * lists combined with select using +. The list must be the left operand.
func squashExpr(x, y bf.Expr) (bf.Expr, error) {
	xList, xDict, err := exprListAndDict(x)
	if err != nil {
		return nil, err
	}
	yList, yDict, err := exprListAndDict(y)
	if err != nil {
		return nil, err
	}

	squashedList := squashList(xList, yList)
	squashedDict, err := squashDict(xDict, yDict)
	if err != nil {
		return nil, err
	}

	var squashedSelect bf.Expr
	if squashedDict != nil {
		squashedSelect = &bf.CallExpr{
			X:    &bf.LiteralExpr{Token: "select"},
			List: []bf.Expr{squashedDict},
		}
	}

	if squashedList == nil {
		return squashedDict, nil
	}
	if squashedSelect == nil {
		return squashedList, nil
	}
	return &bf.BinaryExpr{
		X:  squashedList,
		Op: "+",
		Y:  squashedSelect,
	}, nil
}

func squashList(x, y *bf.ListExpr) *bf.ListExpr {
	if x == nil {
		return y
	}
	if y == nil {
		return x
	}
	squashed := *x
	squashed.Comments.Before = append(x.Comments.Before, y.Comments.Before...)
	squashed.Comments.Suffix = append(x.Comments.Suffix, y.Comments.Suffix...)
	squashed.Comments.After = append(x.Comments.After, y.Comments.After...)
	squashed.List = append(x.List, y.List...)
	return &squashed
}

func squashDict(x, y *bf.DictExpr) (*bf.DictExpr, error) {
	if x == nil {
		return y, nil
	}
	if y == nil {
		return x, nil
	}

	squashed := *x
	squashed.Comments.Before = append(x.Comments.Before, y.Comments.Before...)
	squashed.Comments.Suffix = append(x.Comments.Suffix, y.Comments.Suffix...)
	squashed.Comments.After = append(x.Comments.After, y.Comments.After...)

	xCaseIndex := make(map[string]int)
	for i, e := range x.List {
		kv, ok := e.(*bf.KeyValueExpr)
		if !ok {
			continue
		}
		key, ok := kv.Key.(*bf.StringExpr)
		if !ok {
			continue
		}
		xCaseIndex[key.Value] = i
	}

	for _, e := range y.List {
		kv, ok := e.(*bf.KeyValueExpr)
		if !ok {
			squashed.List = append(squashed.List, e)
			continue
		}
		key, ok := e.(*bf.StringExpr)
		if !ok {
			squashed.List = append(squashed.List, e)
			continue
		}
		i, ok := xCaseIndex[key.Value]
		if !ok {
			squashed.List = append(squashed.List, e)
			continue
		}
		squashedElem, err := squashExpr(x.List[i], kv.Value)
		if err != nil {
			return nil, err
		}
		x.List[i] = squashedElem
	}

	return &squashed, nil
}

// fixLoads removes loads of unused go rules and adds loads of newly used rules.
// This should be called after FixFile, since symbols may be introduced that
// aren't loaded. This is called inside MergeWithExisting, which should suffice.
func fixLoads(oldFile *bf.File) *bf.File {
	// Identify load statements for the Go rules, and determine which symbols
	// are actually used.
	type loadInfo struct {
		index      int
		old, fixed *bf.CallExpr
	}
	var loads []loadInfo
	usedKinds := make(map[string]bool)
	for i, stmt := range oldFile.Stmt {
		c, ok := stmt.(*bf.CallExpr)
		if !ok {
			continue
		}
		x, ok := c.X.(*bf.LiteralExpr)
		if !ok {
			continue
		}

		if x.Token == "load" {
			if len(c.List) == 0 {
				continue
			}
			if label, ok := c.List[0].(*bf.StringExpr); ok && label.Value == config.RulesGoDefBzlLabel {
				loads = append(loads, loadInfo{index: i, old: c})
			}
			continue
		}

		if knownKinds[x.Token] {
			usedKinds[x.Token] = true
		}
	}

	// Fix the load statements.
	changed := false
	var newFirstLoad *bf.CallExpr
	if len(loads) == 0 {
		newFirstLoad = fixLoad(nil, usedKinds)
		changed = newFirstLoad != nil
	} else {
		for i := 0; i < len(loads); i++ {
			if i == 0 {
				loads[i].fixed = fixLoad(loads[i].old, usedKinds)
			} else {
				loads[i].fixed = fixLoad(loads[i].old, nil)
			}
			changed = changed || loads[i].fixed != loads[i].old
		}
	}
	if !changed {
		return oldFile
	}

	// Rebuild the file.
	fixedFile := *oldFile
	fixedFile.Stmt = nil
	if newFirstLoad != nil {
		fixedFile.Stmt = append(fixedFile.Stmt, newFirstLoad)
	}
	loadIndex := 0
	for i, stmt := range oldFile.Stmt {
		if loadIndex < len(loads) && i == loads[loadIndex].index {
			if loads[loadIndex].fixed != nil {
				fixedFile.Stmt = append(fixedFile.Stmt, loads[loadIndex].fixed)
			}
			loadIndex++
			continue
		}
		fixedFile.Stmt = append(fixedFile.Stmt, stmt)
	}
	return &fixedFile
}

// knownKinds is the set of symbols that Gazelle ever generated loads for,
// including symbols it no longer uses (e.g., cgo_library), not including
// other symbols loaded manually (e.g., go_embed_data). This function will
// only add or remove loads of these symbols.
var knownKinds = map[string]bool{
	"cgo_library": true,
	"go_binary":   true,
	"go_library":  true,
	"go_prefix":   true,
	"go_test":     true,
}

// fixLoad updates a load statement. load must be a load statement for
// the Go rules or nil. If nil, a new statement may be created. Symbols in
// kinds are added if they are not already present, symbols in knownKinds
// are removed if they are not in kinds, and other symbols and arguments
// are preserved. nil is returned if the statement should be deleted because
// it is empty.
func fixLoad(load *bf.CallExpr, kinds map[string]bool) *bf.CallExpr {
	var fixed bf.CallExpr
	if load == nil {
		fixed = bf.CallExpr{
			X: &bf.LiteralExpr{Token: "load"},
			List: []bf.Expr{
				&bf.StringExpr{Value: config.RulesGoDefBzlLabel},
			},
			ForceCompact: true,
		}
	} else {
		fixed = *load
	}

	var symbols []*bf.StringExpr
	var otherArgs []bf.Expr
	loadedKinds := make(map[string]bool)
	var added, removed int
	for _, arg := range fixed.List[1:] {
		if s, ok := arg.(*bf.StringExpr); ok {
			if !knownKinds[s.Value] || kinds != nil && kinds[s.Value] {
				symbols = append(symbols, s)
				loadedKinds[s.Value] = true
			} else {
				removed++
			}
		} else {
			otherArgs = append(otherArgs, arg)
		}
	}
	if kinds != nil {
		for kind, _ := range kinds {
			if _, ok := loadedKinds[kind]; !ok {
				symbols = append(symbols, &bf.StringExpr{Value: kind})
				added++
			}
		}
	}
	if added == 0 && removed == 0 {
		if load != nil && len(load.List) == 1 {
			// Special case: delete existing empty load.
			return nil
		}
		return load
	}

	sort.Stable(byString(symbols))
	fixed.List = fixed.List[:1]
	for _, sym := range symbols {
		fixed.List = append(fixed.List, sym)
	}
	fixed.List = append(fixed.List, otherArgs...)
	if len(fixed.List) == 1 {
		return nil
	}
	return &fixed
}

type byString []*bf.StringExpr

func (s byString) Len() int {
	return len(s)
}

func (s byString) Less(i, j int) bool {
	return s[i].Value < s[j].Value
}

func (s byString) Swap(i, j int) {
	s[i], s[j] = s[j], s[i]
}
