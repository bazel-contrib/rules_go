diff -urN a/gopls/README.md b/gopls/README.md
--- a/gopls/README.md	2000-01-01 00:00:00.000000000 -0000
+++ b/gopls/README.md	1969-12-31 19:00:00.000000000 -0500
@@ -1,71 +0,0 @@
-# gopls documentation
-
-gopls (pronounced: "go please") is the official [language server] for the Go language.
-
-## Status
-
-It is currently in **alpha**, so it is **not stable**.
-
-You can see more information about the status of gopls and its supported features [here](doc/status.md).
-
-## Roadmap
-
-The current goal is a fully stable build with the existing feature set, aiming
-for the first half of 2020, with release candidates earlier in the year.
-
-This will be the first build that we recommend people use, and will be tagged as the 1.0 version.
-You can see the set of things being worked on in the [1.0 milestone], in general
-we are focused on stability, specifically, making sure we have a reliable service that produces an experience in module mode that is not a retrograde step from the old tools in GOPATH mode.
-
-There is also considerable effort being put into testing in order to make sure that we both have a stable service and also that we do not regress after launch.
-
-While we may continue to accept contributions for new features, they may be turned off behind a configuration flag if they are not yet stable. See the [gopls unplanned] milestone for deprioritized features.
-
-This is just a milestone for gopls itself. We work with editor integrators to make sure they can use the latest builds of gopls, and will help them use the 1.0 version as soon as it is ready, but that does not imply anything about the stability, supported features or version of the plugins.
-
-## Using
-
-In general you should not need to know anything about gopls, it should be integrated into your editor for you.
-
-To install for your specific editor you can follow the following instructions
-
-* [VSCode](doc/vscode.md)
-* [Vim / Neovim](doc/vim.md)
-* [Emacs](doc/emacs.md)
-* [Acme](doc/acme.md)
-* [Sublime Text](doc/subl.md)
-* [Atom](doc/atom.md)
-
-See the [user guide](doc/user.md) for more information, including the how to install gopls by hand if you need.
-
-## Issues
-
-If you are having issues with gopls, please first check the [known issues](doc/status.md#known-issues) before following the [troubleshooting](doc/troubleshooting.md#steps) guide.
-If that does not give you the information you need, reach out to us.
-
-You can chat with us on:
-* the golang-tools [mailing list]
-* the #gopls [slack channel] on the gophers slack
-
-If you think you have an issue that needs fixing, or a feature suggestion, then please make sure you follow the steps to [file an issue](doc/troubleshooting.md#file-an-issue) with the right information to allow us to address it.
-
-If you need to talk to us directly (for instance to file an issue with confidential information in it) you can reach out directly to [@stamblerre] or [@ianthehat].
-
-## More information
-
-If you want to know more about it, have an unusual use case, or want to contribute, please read the following documents
-
-* [Using gopls](doc/user.md)
-* [Troubleshooting and reporting issues](doc/troubleshooting.md)
-* [Integrating gopls with an editor](doc/integrating.md)
-* [Contributing to gopls](doc/contributing.md)
-* [Design requirements and decisions](doc/design.md)
-* [Implementation details](doc/implementation.md)
-
-[language server]: https://langserver.org
-[mailing list]: https://groups.google.com/forum/#!forum/golang-tools
-[slack channel]: https://gophers.slack.com/messages/CJZH85XCZ
-[@stamblerre]: https://github.com/stamblerre "Rebecca Stambler"
-[@ianthehat]: https://github.com/ianthehat "Ian Cottrell"
-[1.0 milestone]: https://github.com/golang/go/milestone/112
-[gopls unplanned]: https://github.com/golang/go/milestone/124
diff -urN a/gopls/doc/acme.md b/gopls/doc/acme.md
--- a/gopls/doc/acme.md	2000-01-01 00:00:00.000000000 -0000
+++ b/gopls/doc/acme.md	1969-12-31 19:00:00.000000000 -0500
@@ -1,7 +0,0 @@
-# Acme
-
-Use the experimental [`acme-lsp`], simply follow the [install steps]
-
-[`acme-lsp`]: https://github.com/fhs/acme-lsp
-[install steps]: https://github.com/fhs/acme-lsp#gopls
-
diff -urN a/gopls/doc/analyzers.md b/gopls/doc/analyzers.md
--- a/gopls/doc/analyzers.md	2000-01-01 00:00:00.000000000 -0000
+++ b/gopls/doc/analyzers.md	1969-12-31 19:00:00.000000000 -0500
@@ -1,491 +0,0 @@
-# Analyzers
-
-<!--TODO: Generate this file from the documentation in golang/org/x/tools/go/analysis/passes and golang/org/x/tools/go/lsp/source/options.go.-->
-
-This document describes the analyzers that `gopls` uses inside the editor.
-
-A value of `true` means that the analyzer is enabled by default and a value of `false` means it is disabled by default.
-
-Details about how to enable/disable these analyses can be found [here](settings.md#analyses).
-
-## Go vet suite
-
-Below is the list of general analyzers that are used in `go vet`.
-
-### **asmdecl**
-
-report mismatches between assembly files and Go declarations
-
-Default value: `true`.
-
-### **assign**
-
-check for useless assignments
-
-This checker reports assignments of the form `x = x` or `a[i] = a[i]`.
-These are almost always useless, and even when they aren't they are
-usually a mistake.
-
-Default value: `true`.
-
-### **atomic**
-
-check for common mistakes using the sync/atomic package
-
-The atomic checker looks for assignment statements of the form:
-
-`x = atomic.AddUint64(&x, 1)`
-
-which are not atomic.
-
-Default value: `true`.
-
-### **atomicalign**
-
-check for non-64-bits-aligned arguments to sync/atomic functions
-
-Default value: `true`.
-
-### **bools**
-
-check for common mistakes involving boolean operators
-
-Default value: `true`.
-
-### **buildtag**
-
-check that +build tags are well-formed and correctly located
-
-Default value: `true`.
-
-### **cgocall**
-
-detect some violations of the cgo pointer passing rules
-
-Check for invalid cgo pointer passing.
-This looks for code that uses cgo to call C code passing values
-whose types are almost always invalid according to the cgo pointer
-sharing rules.
-Specifically, it warns about attempts to pass a Go chan, map, func,
-or slice to C, either directly, or via a pointer, array, or struct.
-
-Default value: `true`.
-
-### **composites**
-
-check for unkeyed composite literals
-
-This analyzer reports a diagnostic for composite literals of struct
-types imported from another package that do not use the field-keyed
-syntax. Such literals are fragile because the addition of a new field
-(even if unexported) to the struct will cause compilation to fail.
-
-As an example,
-`err = &net.DNSConfigError{err}`
-
-should be replaced by:
-`err = &net.DNSConfigError{Err: err}`
-
-Default value: `true`.
-
-### **copylock**
-
-check for locks erroneously passed by value
-
-Inadvertently copying a value containing a lock, such as sync.Mutex or
-sync.WaitGroup, may cause both copies to malfunction. Generally such
-values should be referred to through a pointer.
-
-Default value: `true`.
-
-### **errorsas**
-
-report passing non-pointer or non-error values to errors.As
-
-The errorsas analysis reports calls to errors.As where the type
-of the second argument is not a pointer to a type implementing error.
-
-Default value: `true`.
-
-### **httpresponse**
-
-check for mistakes using HTTP responses
-
-A common mistake when using the net/http package is to defer a function
-call to close the http.Response Body before checking the error that
-determines whether the response is valid:
-
-```go
-resp, err := http.Head(url)
-defer resp.Body.Close()
-if err != nil {
-  log.Fatal(err)
-}
-// (defer statement belongs here)
-```
-
-This checker helps uncover latent nil dereference bugs by reporting a
-diagnostic for such mistakes.
-
-Default value: `true`.
-
-### **loopclosure**
-
-check references to loop variables from within nested functions
-
-This analyzer checks for references to loop variables from within a
-function literal inside the loop body. It checks only instances where
-the function literal is called in a defer or go statement that is the
-last statement in the loop body, as otherwise we would need whole
-program analysis.
-
-For example:
-```go
-for i, v := range s {
-  go func() {
-    println(i, v) // not what you might expect
-  }()
-}
-```
-
-See: https://golang.org/doc/go_faq.html#closures_and_goroutines
-
-Default value: `true`.
-
-### **lostcancel**
-
-check cancel func returned by context.WithCancel is called
-
-The cancellation function returned by context.WithCancel, WithTimeout,
-and WithDeadline must be called or the new context will remain live
-until its parent context is cancelled.
-(The background context is never cancelled.)
-
-Default value: `true`.
-
-### **nilfunc**
-
-check for useless comparisons between functions and nil
-
-A useless comparison is one like f == nil as opposed to f() == nil.
-
-Default value: `true`.
-
-### **printf**
-
-check consistency of Printf format strings and arguments
-
-The check applies to known functions (for example, those in package fmt)
-as well as any detected wrappers of known functions.
-
-A function that wants to avail itself of printf checking but is not
-found by this analyzer's heuristics (for example, due to use of
-dynamic calls) can insert a bogus call:
-
-```go
-if false {
-  _ = fmt.Sprintf(format, args...) // enable printf checking
-}
-```
-
-The -funcs flag specifies a comma-separated list of names of additional
-known formatting functions or methods. If the name contains a period,
-it must denote a specific function using one of the following forms:
-
-```
-	dir/pkg.Function
-	dir/pkg.Type.Method
-	(*dir/pkg.Type).Method
-```
-
-Otherwise the name is interpreted as a case-insensitive unqualified
-identifier such as "errorf". Either way, if a listed name ends in f, the
-function is assumed to be Printf-like, taking a format string before the
-argument list. Otherwise it is assumed to be Print-like, taking a list
-of arguments with no format string.
-
-Default value: `true`.
-
-### **shift**
-
-check for shifts that equal or exceed the width of the integer
-
-Default value: `true`.
-
-### **stdmethods**
-
-check signature of methods of well-known interfaces
-
-Sometimes a type may be intended to satisfy an interface but may fail to
-do so because of a mistake in its method signature.
-For example, the result of this WriteTo method should be (int64, error),
-not error, to satisfy io.WriterTo:
-
-```go
-	type myWriterTo struct{...}
-        func (myWriterTo) WriteTo(w io.Writer) error { ... }
-```
-
-This check ensures that each method whose name matches one of several
-well-known interface methods from the standard library has the correct
-signature for that interface.
-
-Checked method names include:
-	Format GobEncode GobDecode MarshalJSON MarshalXML
-	Peek ReadByte ReadFrom ReadRune Scan Seek
-	UnmarshalJSON UnreadByte UnreadRune WriteByte
-	WriteTo
-
-Default value: `true`.
-
-### **structtag**
-
-check that struct field tags conform to reflect.StructTag.Get
-
-Also report certain struct tags (json, xml) used with unexported fields.
-
-Default value: `true`.
-
-### **tests**
-
-check for common mistaken usages of tests and examples
-
-The tests checker walks Test, Benchmark and Example functions checking
-malformed names, wrong signatures and examples documenting non-existent
-identifiers.
-
-Please see the documentation for package testing in golang.org/pkg/testing
-for the conventions that are enforced for Tests, Benchmarks, and Examples.
-
-Default value: `true`.
-
-### **unmarshal**
-
-report passing non-pointer or non-interface values to unmarshal
-
-The unmarshal analysis reports calls to functions such as json.Unmarshal
-in which the argument type is not a pointer or an interface.
-
-Default value: `true`.
-
-### **unreachable**
-
-check for unreachable code
-
-The unreachable analyzer finds statements that execution can never reach
-because they are preceded by an return statement, a call to panic, an
-infinite loop, or similar constructs.
-
-Default value: `true`.
-
-### **unsafeptr**
-
-check for invalid conversions of uintptr to unsafe.Pointer
-
-The unsafeptr analyzer reports likely incorrect uses of unsafe.Pointer
-to convert integers to pointers. A conversion from uintptr to
-unsafe.Pointer is invalid if it implies that there is a uintptr-typed
-word in memory that holds a pointer value, because that word will be
-invisible to stack copying and to the garbage collector.
-
-Default value: `true`.
-
-### **unusedresult**
-
-check for unused results of calls to some functions
-
-Some functions like fmt.Errorf return a result and have no side effects,
-so it is always a mistake to discard the result. This analyzer reports
-calls to certain functions in which the result of the call is ignored.
-
-The set of functions may be controlled using flags.
-
-Default value: `true`.
-
-## gopls suite
-
-Below is the list of analyzers that are used by `gopls`.
-
-### **deepequalerrors**
-
-check for calls of reflect.DeepEqual on error values
-
-The deepequalerrors checker looks for calls of the form:
-
-```go
-    reflect.DeepEqual(err1, err2)
-```
-
-where err1 and err2 are errors. Using reflect.DeepEqual to compare
-errors is discouraged.
-
-Default value: `true`.
-
-### **fillreturns**
-
-suggested fixes for "wrong number of return values (want %d, got %d)"
-
-This checker provides suggested fixes for type errors of the
-type "wrong number of return values (want %d, got %d)". For example:
-```go
-func m() (int, string, *bool, error) {
-  return
-}
-```
-will turn into
-```go
-func m() (int, string, *bool, error) {
-  return 0, "", nil, nil
-}
-```
-
-This functionality is similar to [goreturns](https://github.com/sqs/goreturns).
-
-Default value: `false`.
-
-### **nonewvars**
-
-suggested fixes for "no new vars on left side of :="
-
-This checker provides suggested fixes for type errors of the
-type "no new vars on left side of :=". For example:
-```go
-z := 1
-z := 2
-```
-will turn into
-```go
-z := 1
-z = 2
-```
-
-Default value: `false`.
-
-### **noresultvalues**
-
-suggested fixes for "no result values expected"
-
-This checker provides suggested fixes for type errors of the
-type "no result values expected". For example:
-```go
-func z() { return nil }
-```
-will turn into
-```go
-func z() { return }
-```
-
-Default value: `true`.
-
-### **simplifycompositelit**
-
-check for composite literal simplifications
-
-An array, slice, or map composite literal of the form:
-```go
-[]T{T{}, T{}}
-```
-will be simplified to:
-```go
-[]T{{}, {}}
-```
-
-This is one of the simplifications that "gofmt -s" applies.
-
-Default value: `true`.
-
-### **simplifyrange**
-
-check for range statement simplifications
-
-A range of the form:
-```go
-for x, _ = range v {...}
-```
-will be simplified to:
-```go
-for x = range v {...}
-```
-
-A range of the form:
-```go
-for _ = range v {...}
-```
-will be simplified to:
-```go
-for range v {...}
-```
-
-This is one of the simplifications that "gofmt -s" applies.
-
-Default value: `true`.
-
-### **simplifyslice**
-
-check for slice simplifications
-
-A slice expression of the form:
-```go
-s[a:len(s)]
-```
-will be simplified to:
-```go
-s[a:]
-```
-
-This is one of the simplifications that "gofmt -s" applies.
-
-Default value: `true`.
-
-### **sortslice**
-
-check the argument type of sort.Slice
-
-sort.Slice requires an argument of a slice type. Check that
-the interface{} value passed to sort.Slice is actually a slice.
-
-Default value: `true`.
-
-### **testinggoroutine**
-
-report calls to (*testing.T).Fatal from goroutines started by a test.
-
-Functions that abruptly terminate a test, such as the Fatal, Fatalf, FailNow, and
-Skip{,f,Now} methods of *testing.T, must be called from the test goroutine itself.
-This checker detects calls to these functions that occur within a goroutine
-started by the test. For example:
-
-```go
-func TestFoo(t *testing.T) {
-    go func() {
-        t.Fatal("oops") // error: (*T).Fatal called from non-test goroutine
-    }()
-}
-```
-
-Default value: `true`.
-
-### **undeclaredname**
-
-suggested fixes for "undeclared name: <>"
-
-This checker provides suggested fixes for type errors of the
-type `undeclared name: <>`. It will insert a new statement:
-`<> := `.
-
-Default value: `false`.
-
-### **unusedparams**
-
-check for unused parameters of functions
-
-The unusedparams analyzer checks functions to see if there are
-any parameters that are not being used.
-
-To reduce false positives it ignores:
-- methods
-- parameters that do not have a name or are underscored
-- functions in test files
-- functions with empty bodies or those with just a return stmt
-
-Default value: `false`.
diff -urN a/gopls/doc/atom.md b/gopls/doc/atom.md
--- a/gopls/doc/atom.md	2000-01-01 00:00:00.000000000 -0000
+++ b/gopls/doc/atom.md	1969-12-31 19:00:00.000000000 -0500
@@ -1,7 +0,0 @@
-# Atom
-
-Install the [`ide-gopls`] package.
-You will also need to install the [`atom-ide-ui`] package.
-
-[`ide-gopls`]: https://github.com/MordFustang21/ide-gopls
-[`atom-ide-ui`]: https://github.com/facebookarchive/atom-ide-ui
diff -urN a/gopls/doc/command-line.md b/gopls/doc/command-line.md
--- a/gopls/doc/command-line.md	2000-01-01 00:00:00.000000000 -0000
+++ b/gopls/doc/command-line.md	1969-12-31 19:00:00.000000000 -0500
@@ -1,15 +0,0 @@
-# Command line
-
-## Flags
-
-## Commands
-
-### Serve
-
-### Check
-
-### Format
-
-<!--- TODO: command line
-detailed command line instructions, use cases and flags
---->
\ No newline at end of file
diff -urN a/gopls/doc/commands.md b/gopls/doc/commands.md
--- a/gopls/doc/commands.md	2000-01-01 00:00:00.000000000 -0000
+++ b/gopls/doc/commands.md	1969-12-31 19:00:00.000000000 -0500
@@ -1,92 +0,0 @@
-# Commands
-
-This document describes the LSP-level commands supported by `gopls`. They cannot be invoked directly by users, and all the details are subject to change, so nobody should rely on this information.
-
-<!-- BEGIN Commands: DO NOT MANUALLY EDIT THIS SECTION -->
-### **Run go generate**
-Identifier: `gopls.generate`
-
-generate runs `go generate` for a given directory.
-
-
-### **Fill struct**
-Identifier: `gopls.fill_struct`
-
-fill_struct is a gopls command to fill a struct with default
-values.
-
-
-### **Regenerate cgo**
-Identifier: `gopls.regenerate_cgo`
-
-regenerate_cgo regenerates cgo definitions.
-
-
-### **Run test(s)**
-Identifier: `gopls.test`
-
-test runs `go test` for a specific test function.
-
-
-### **Run go mod tidy**
-Identifier: `gopls.tidy`
-
-tidy runs `go mod tidy` for a module.
-
-
-### **Undeclared name**
-Identifier: `gopls.undeclared_name`
-
-undeclared_name adds a variable declaration for an undeclared
-name.
-
-
-### **Add dependency**
-Identifier: `gopls.add_dependency`
-
-add_dependency adds a dependency.
-
-
-### **Upgrade dependency**
-Identifier: `gopls.upgrade_dependency`
-
-upgrade_dependency upgrades a dependency.
-
-
-### **Remove dependency**
-Identifier: `gopls.remove_dependency`
-
-remove_dependency removes a dependency.
-
-
-### **Run go mod vendor**
-Identifier: `gopls.vendor`
-
-vendor runs `go mod vendor` for a module.
-
-
-### **Extract to variable**
-Identifier: `gopls.extract_variable`
-
-extract_variable extracts an expression to a variable.
-
-
-### **Extract to function**
-Identifier: `gopls.extract_function`
-
-extract_function extracts statements to a function.
-
-
-### **Toggle gc_details**
-Identifier: `gopls.gc_details`
-
-gc_details controls calculation of gc annotations.
-
-
-### **Generate gopls.mod**
-Identifier: `gopls.generate_gopls_mod`
-
-generate_gopls_mod (re)generates the gopls.mod file.
-
-
-<!-- END Commands: DO NOT MANUALLY EDIT THIS SECTION -->
diff -urN a/gopls/doc/contributing.md b/gopls/doc/contributing.md
--- a/gopls/doc/contributing.md	2000-01-01 00:00:00.000000000 -0000
+++ b/gopls/doc/contributing.md	1969-12-31 19:00:00.000000000 -0500
@@ -1,25 +0,0 @@
-# Documentation for contributors
-
-Contributions are welcome, but since development is so active, we request that you file an issue and claim it before starting to work on something. Otherwise, it is likely that we might already be working on a fix for your issue.
-
-## Finding issues
-
-All `gopls` issues are labeled as such (see the [`gopls` label][issue-gopls]). Issues that are suitable for contributors are additionally tagged with the [`help-wanted` label][issue-wanted].
-
-Before you begin working on an issue, please leave a comment that you are claiming it.
-
-## Getting started
-
-<!--- TODO: getting started
-Provide information to get contributors up and running here
---->
-
-## Debugging
-
-<!--- TODO: debugging
-actual debugging steps
-viewing telemetry
---->
-
-[issue-gopls]: https://github.com/golang/go/issues?utf8=%E2%9C%93&q=is%3Aissue+is%3Aopen+label%3Agopls "gopls issues"
-[issue-wanted]: https://github.com/golang/go/issues?utf8=✓&q=is%3Aissue+is%3Aopen+label%3Agopls+label%3A"help+wanted" "help wanted"
\ No newline at end of file
diff -urN a/gopls/doc/daemon.md b/gopls/doc/daemon.md
--- a/gopls/doc/daemon.md	2000-01-01 00:00:00.000000000 -0000
+++ b/gopls/doc/daemon.md	1969-12-31 19:00:00.000000000 -0500
@@ -1,176 +0,0 @@
-# Running gopls as a daemon
-
-**Note: this feature is new. If you encounter bugs, please [file an
-issue](troubleshooting.md#file-an-issue).**
-
-If you just want to try this out, skip ahead to the [quickstart](#quickstart).
-
-## Background: gopls execution modes
-
-Gopls was originally implemented as an LSP sidecar: a process started by
-editors or editor plugins, and communicated with using jsonrpc 2.0 over
-stdin/stdout. By executing as a stateful process, gopls can maintain a
-significant amount of cache and can eagerly perform analysis on the source code
-being edited.
-
-This execution mode does not work as well when there are many separate editor
-processes or when editor processes are short-lived, as is often the case for
-users of non-IDE editors such as Vim or Emacs. Having many processes means
-having many caches, consuming a significant amount of system resources. Using
-short-lived sessions means paying a start-up cost each time a session is
-created.
-
-To support these types of workflows, a new mode of gopls execution is supported
-wherein a single, persistent, shared gopls "daemon" process is responsible for
-managing all gopls sessions. In this mode, editors still start a gopls sidecar,
-but this sidecar merely acts as a thin "forwarder", responsible for forwarding
-the LSP to the shared gopls instance and recording metrics, logs, and rpc
-traces.
-
-## Quickstart
-
-To use a shared gopls instance you must either manage the daemon process
-yourself, or let the gopls forwarder processes start the shared daemon as
-needed.
-
-### Running with `-remote=auto`
-
-Automatic management of the daemon is easiest, and can be done by passing the
-flag `-remote=auto` to the gopls process started by your editor. This will
-cause this process to auto-start the gopls daemon if needed, connect to it, and
-forward the LSP. For example, here is a reasonable gopls invocation, that sets
-some additional flags for easier [debugging](#debugging):
-```
-$ gopls -remote=auto -logfile=auto -debug=:0 -remote.debug=:0 -rpc.trace
-```
-
-Note that the shared gopls process will automatically shut down after one
-minute with no connected clients.
-
-### Managing the daemon manually
-
-To manage the gopls daemon process via external means rather than having the
-forwarders manage it, you must start a gopls daemon process with the
-`-listen=<addr>` flag, and then pass `-remote=<addr>` to the gopls processes
-started by your editor.
-
-For example, to host the daemon on the TCP port `37374`, do:
-```
-$ gopls -listen=:37374 -logfile=auto -debug=:0
-```
-
-And then from the editor, run
-```
-$ gopls -remote=:37374 -logfile=auto -debug=:0 -rpc.trace
-```
-
-If you are on a POSIX system, you can also use unix domain sockets by prefixing
-the flag values with `unix;`. For example:
-```
-$ gopls -listen="unix;/tmp/gopls-daemon-socket" -logfile=auto -debug=:0
-```
-And connect via:
-```
-$ gopls -remote="unix;/tmp/gopls-daemon-socket" -logfile=auto -debug=:0 -rpc.trace
-```
-
-(Note that these flag values MUST be enclosed in quotes, because ';' is a
-special shell character. For this reason, this syntax is subject to change in
-the future.)
-
-## Debugging
-
-Debugging a shared gopls session is more complicated than a singleton session,
-because there are now two gopls processes involved with handling the LSP. Here
-are some tips:
-
-### Finding logfiles and debug addresses
-
-When running in daemon mode, you can use the `gopls inspect sessions` command
-to find the logfile and debug port for your gopls daemon instance (as well as
-for all its connected clients). By default, this inspects the default daemon
-(i.e. `-remote=auto`). To inspect a different daemon, use the `-remote` flag
-explicitly: `gopls -remote=localhost:12345 inspect sessions`.
-
-This works whether or not you have enabled `-remote.debug`.
-
-### Traversing debug pages
-
-When `-debug=:0` is passed to gopls, it runs a webserver that serves stateful
-debug pages (see [troubleshooting.md](troubleshooting.md)). You can find the
-actual port hosting these pages by either using the `gopls inspect sessions`
-command, or by checking the start of the logfile -- it will be one of the first
-log messages. For example, if using `-logfile=auto`, find the debug address by
-checking `head /tmp/gopls-<pid>.log`.
-
-By default, the gopls daemon is not started with `-debug`. To enable it, set
-the `-remote.debug` flag on the forwarder instance, so that it invokes gopls
-with `-debug` when starting the daemon.
-
-The debug pages of the forwarder process will have a link to the debug pages of
-the daemon server process. Correspondingly, the debug pages of the daemon
-process will have a link to each of its clients.
-
-This can help you find metrics, traces, and log files for all of the various
-servers and clients.
-
-### Using logfiles
-
-The gopls daemon is started with logging disabled by default. To customize
-this, pass `-remote.logfile` to the gopls forwarder. Using
-`-remote.logfile=auto`, the daemon will log to a default location (on posix
-systems: `/tmp/gopls-daemon-<pid>.log`).
-
-The gopls daemon does not log session-scoped messages: those are instead
-reflected back to the forwarder so that they can be accessed by the editor.
-Daemon logs will only contain global messages, for example logs when sessions
-connect and disconnect.
-
-It is recommended to start the forwarder gopls process with `-rpc.trace`, so
-that its logfile will contain rpc trace logs specific to the LSP session.
-
-## Using multiple shared gopls instances
-
-There may be environments where it is desirable to have more than one shared
-gopls instance. If managing the daemon manually, this can be done by simply
-choosing different `-listen` addresses for each distinct daemon process.
-
-On POSIX systems, there is also support for automatic management of distinct
-shared gopls processes: distinct daemons can be selected by passing
-`-remote="auto;<id>"`. Any gopls forwarder passing the same value for `<id>`
-will use the same shared daemon.
-
-## FAQ
-
-**Q: Why am I not saving as much memory as I expected when using a shared gopls?**
-
-A: As described in [implementation.md](implementation.md), gopls has a concept
-of view/session/cache. Each session and view map onto exactly one editor
-session (because they contain things like edited but unsaved buffers). The
-cache contains things that are independent of any editor session, and can
-therefore be shared.
-
-When, for example, three editor session are sharing a single gopls process,
-they will share the cache but will each have their own session and view. The
-memory savings in this mode, when compared to three separate gopls processes,
-corresponds to the amount of cache overlap across sessions.
-
-Because this hasn't mattered much in the past, it is likely that there is state
-that can be moved out of the session/view, and into the cache, thereby
-increasing the amount of memory savings in the shared mode.
-
-**Q: How do I customize the daemon instance when using `-remote=auto`?**
-
-The daemon may be customized using flags of the form `-remote.*` on the
-forwarder gopls. This causes the forwarder to invoke gopls with these settings
-when starting the daemon. As of writing, we expose the following configuration:
-
-* `-remote.logfile`: the location of the daemon logfile
-* `-remote.debug`: the daemon's debug address
-* `-remote.listen.timeout`: the amount of time the daemon should wait for new
-  connections while there are no current connections, before shutting down. If
-  `0`, listen indefinitely.
-
-Note that once the daemon is already running, setting these flags will not
-change its configuration. These flags only matter for the forwarder process
-that actually starts the daemon.
diff -urN a/gopls/doc/design.md b/gopls/doc/design.md
--- a/gopls/doc/design.md	2000-01-01 00:00:00.000000000 -0000
+++ b/gopls/doc/design.md	1969-12-31 19:00:00.000000000 -0500
@@ -1,400 +0,0 @@
-# gopls design documentation
-
-## Goals
-
-* `gopls` should **become the default editor backend** for the major editors used by Go programmers, fully supported by the Go team.
-* `gopls` will be a **full implementation of LSP**, as described in the [LSP specification], to standardize as many of its features as possible.
-* `gopls` will be **clean and extensible** so that it can encompass additional features in the future, allowing Go tooling to become best in class once more.
-* `gopls` will **support alternate build systems and file layouts**, allowing Go development to be simpler and more powerful in any environment.
-
-
-## Context
-
-While Go has a number of excellent and useful command-line tools that enhance the developer experience, it has become clear that integrating these tools with IDEs can pose challenges.
-
-Support of these tools has relied on the goodwill of community members, and they have been put under a large burden of support at times as the language, toolchain and environments change. As a result many tools have ceased to work, have had support problems, or become confusing with forks and replacements, or provided an experience that is not as good as it could be.
-See the section below on [existing solutions](#existing-solutions) for more problems and details.
-
-This is fine for tools used occasionally, but for core IDE features, this is not acceptable.
-Autocompletion, jump to definition, formatting, and other such features should always work, as they are key for Go development.
-
-The Go team will create an editor backend that works in any build system.
-It will also be able to improve upon the latency of Go tools, since each tool will no longer have to individually run the type-checker on each invocation, instead there will be a long-running process and data can be shared between the definitions, completions, diagnostics, and other features.
-
-By taking ownership of these tools and packaging them together in the form of gopls, the Go team will ensure that the Go development experience isn’t unnecessarily complicated for Go users.
-Having one editor backend will simplify the lives of Go developers, the Go team, and the maintainers of Go editor plugins.
-
-See Rebecca's excellent GopherCon keynote [talk] and [slides] for some more context.
-
-## Non-Goals
-
-* Command line speed
-
-  Although gopls will have a command line mode, it will be optimized for long running and not command responsiveness, as such it may not be the right tool for things like CI systems.
-  For such cases there will have to be an alternate tool using the same underlying libraries for consistency.
-
-* Low memory environments
-
-  In order to do a good job of processing large projects with very low latencies gopls will be holding a lot of information in memory.
-  It is presumed that developers are normally working on systems with significant RAM and this will not be a problem.
-  In general this is upheld by the large memory usage of existing IDE solutions (like IntelliJ)
-
-* Syntax highlighting
-
-  At the moment there is no editor that delegates this functionality to a separate binary, and no standard way of doing it.
-
-## Existing solutions
-
-Every year the Go team conducts a survey, asking developers about their experiences with the language.
-
-One question that is asked is “How do you feel about your editor?”.
-
-The responses told a very negative story. Some categorized quotes:
-
-* Setup
-  * "Hard to install and configure"
-  * "Inadequate documentation"
-* Performance
-  * "Performance is very poor"
-  * "Pretty slow in large projects"
-* Reliability
-  * "Features work one day, but not the next"
-  * "Tooling is not updated with new language features"
-
-Each editor has its own plugin that shells out to a variety of tools, many of which break with new Go releases or because they are no longer maintained.
-
-The individual tools each have to do the work to understand the code and all its transitive dependencies.
-
-Each feature is a different tool, with a different set of patterns for its command line, a different way to accept input and parse output, a different way of specifying source code locations.
-To support its existing feature set, VSCode installed 24 different command line tools, many of which have options or forks to configure. When looking at the set of tools that needed to be migrated to modules, across all the editors, there were 63 separate tools.
-
-All these tools need to understand the code, and they use the same standard libraries to do it. Those libraries are optimized for these kinds of tools, but even so processing that much code takes a lot of time time. Almost none of the tools are capable of returning results within 100ms.
-As developers type in their editor, multiple of these features need to activate, which means they are not just paying the cost once, but many times. The overall effect is an editing experience that feels sluggish, and features that are either not enabled or sometimes produce results that appear so slowly they are no longer useful when they arrive. This is a problem that increases with the size of the code base, which means it is getting worse over time, and is especially bad for the kinds of large code bases companies are dealing with as they use Go for more major tasks.
-
-## Requirements
-
-### Complete feature set
-
-For gopls to be considered a success it has to implement the full feature set discussed [below](#Features).
-This is the set of features that users need in order to feel as productive as they were with the tooling it is replacing. It does not include every feature of previous implementations, there are some features that are almost never used that should be dropped (like guru's pointer analysis) and some other features that do not easily fit and will have to be worked around (replacing the save hook/linter).
-
-### Equivalent or better experience
-
-For all of those features, the user experience must match or exceed the current one available in all editors.
-This is an easy statement to make, but a hard one to validate or measure. Many of the possible measures fail to capture the experience.
-
-For instance, if an attempt was made to measure the latency of a jump to definition call, the results would be fairly consistent from the old godef tool. From the gopls implementation there may be a much larger range of latencies, with the best being orders of magnitude faster, and the worse slightly worse, because gopls attempts to do far more work, but manages to cache it across calls.
-
-Or for a completion call, it might be slower but produce a better first match such that users accept it more often, resulting in an overall better experience.
-
-For the most part this has to rely on user reports. If users are refusing to switch because the experience is not better, it is clearly not done, if they are switching but most people are complaining, there are probably enough areas that are better to make the switch compelling but other areas which are worse. If most people are switching and either staying silent or being positive, it is probably done. When writing tools, the user is all that matters.
-
-### Solid community of contributors
-
-The scope and scale of the problem gopls is trying to solve is untenable for the core Go team, it is going to require a strong community to make it all happen.
-
-This implies the code must be easy to contribute to, and easy for many developers to work on in parallel. The functionality needs to be well decoupled, and have a thorough testing story.
-
-### Latencies that fall within user tolerance
-
-There has been a lot of research on acceptable latencies for user actions.
-<!-- TODO: research links -->
-The main result that affects gopls is that feedback in direct response to continuous user actions needs to be under 100ms to be imperceptible, and anything above 200ms aggravates the user.
-This means in general the aim has to be <100ms for anything that happens as the developer types.
-There will always be cases where gopls fails to meet this deadline, and there needs to be ways to make the user experience okay in those cases, but in general the point of this deadline is to inform the basic architecture design, any solution that cannot theoretically meet this goal in the long term is the wrong answer.
-
-### Easy to configure
-
-Developers are very particular, and have very differing desires in their coding experience. gopls is going to have to support a significant amount of flexibility, in order to meet those desires.
-The default settings however with no configuration at all must be the one that is best experience for most users, and where possible the features must be flexible without configuration so that the client can easily make the choices about treatment without changing its communication with gopls.
-
-## Difficulties
-
-### Volume of data
-
-<!-- TODO: project sizes -->
-* Small:
-* Medium:
-* Large:
-* Corporate mono-repo: Much much bigger
-
-Parsing and type checking large amounts of code is quite expensive, and the converted forms use a lot of space. As gopls has to keep updating this information while the developer types, it needs to manage how it caches the converted forms very carefully to balance memory use vs speed.
-
-### Cache invalidation
-
-The basic unit of operation for the type checking is the package, but the basic unit of operation for an editor is the file.
-gopls needs to be able to map files to packages efficiently, so that when files change it knows which packages need to be updated (along with any other packages that transitively depended on them).
-This is made especially difficult by the fact that changing the content of a file can modify which packages it is considered part of (either by changing the package declaration or the build tags), a file can be in more than one package, and changes can be made to files without using the editor, in which case it will not notify us of the changes.
-
-### Inappropriate core functionality
-
-The base libraries for Go (things like [go/token], [go/ast] and [go/types]) are all designed for compiler-like applications.
-They tend to worry more about throughput than memory use, they have structures that are intended to grow and then be thrown away at program exit, and they are not designed to keep going in the presence of errors in the source they are handling.
-They also have no abilities to do incremental changes.
-
-Making a long running service work well with those libraries is a very large challenge, but writing new libraries would be far more work, and cause a significant long term cost as both sets of libraries would have to be maintained. Right now it is more important to get a working tool into the hands of users. In the long term this decision may have to be revisited, new low level libraries may be the only way to keep pushing the capabilities forwards.
-
-### Build system capabilities
-
-gopls is supposed to be build system agnostic, but it must use the build system to discover how files map to packages. When it tries to do so, even when the functionality is the same, the costs (in time, CPU and memory) are very different, and can significantly impact the user experience. Designing how gopls interacts with the build system to try to minimize or hide these differences is hard.
-
-### Build tags
-
-The build tag system in Go is quite powerful, and has many use cases. Source files can exclude themselves using powerful boolean logic on the set of active tags.
-It is however designed for specifying the set of active tags on the command line, and the libraries are all designed to cope with only one valid combination at a time. There is also no way to work out the set of valid combinations.
-
-Type checking a file requires knowledge of all the other files in the same package, and that set of files is modified by the build tags. The set of exported identifiers of a package is also affected by which files are in the package, and thus its build tags.
-
-This means that even for files or packages that have no build tag controls it is not possible to produce correct results without knowing the set of build tags to consider.
-This makes it very hard to produce useful results when viewing a file.
-
-### Features not supported by LSP
-
-There are some things it would be good to be able to do that do not fit easily into the existing LSP protocol.
-For instance, displaying control flow information, automatic struct tags, complex refactoring...
-
-Each feature will have to be considered carefully, and either propose a change to LSP, or add a way to have gopls specific extensions to the protocol that are still easy to use in all the editor plugins.
-
-To avoid these at the start, only core LSP features will be implemented, as they are sufficient to meet the baseline requirements anyway, but the potential features need to be kept in mind in the core architecture.
-
-### Distribution
-
-Making sure that users are using the right version of gopls is going to be a problem. Each editor plugin is probably going to install the tools in its own way, some will choose to install it system wide, some will keep their own copy.
-
-Because it is a brand new tool, it will be changing rapidly. If users are not informed they are on an old version they will be experiencing problems that have already been fixed, which is worse for them, and then probably reporting them, which wastes time for the gopls team. There needs to be a mechanism for gopls to check if is up to date, and a recommended way to install an up to date version.
-
-### Debugging user problems
-
-gopls is essentially a very stateful long running server on the developer's machine. Its basic operation is affected by many things, from the users environment to the contents of the local build cache. The data it is operating on is often a confidential code base that cannot be shared.
-All of these things make it hard for users to report a bug usefully, or create a minimal reproduction.
-
-There needs to be easy ways for users to report what information they can, and ways to attempt to reproduce problems without their entire state. This is also needed to produce regression tests.
-
-
-## Basic design decisions
-
-There are some fundamental architecture decisions that affect much of the rest of the design of the tool, making fundamental trade offs that impact the user experience.
-
-### Process lifetime: *managed by the editor*
-
-Processing a large code base to fully type check and then analyze it within the latency requirements is not feasible, and is one of the primary problems with the existing solutions. This remains true even if the computed information was cached on disk, as running analyzers and type checkers ends up requiring the full AST of all files in the dependency graph.
-It is theoretically possible to do better, but only with a major re-write of the existing parsing and type checking libraries, something that is not feasible at this time.
-
-This implies that gopls should be a long running process, that is able to cache and pre-calculate results in memory so that when a request arrives it can produce the answer much faster.
-
-It could run as a daemon on the user's machine, but there are a lot of issues with managing a daemon. It may well be the right choice in the long term, and it should be allowed for in the fundamental architecture design, but to start with it will instead have a process that lasts as long as the editor that starts it, and that can easily be restarted.
-
-### Caching: *in memory*
-
-Persistent disk caches are very expensive to maintain, and require solving a lot of extra problems.
-Although building the information required is expensive compared to the latencies required of the requests, it is fairly minor compared to the startup times of an editor, so it is expected that rebuilding the information when gopls is restarted will be acceptable.
-
-The advantage gained from this is that gopls becomes stateless across restarts which means if it has issues or gets its state confused, a simple restart will often fix the problem.
-It also means that when users report problems, the entire state of the on disk cache is not needed to diagnose and reproduce the issue.
-
-### Communication: *stdin/stdout JSON*
-
-The LSP specification defines the JSON messages that are normally used, but it does not define how those message should be sent, and there are implementations of the LSP that do not use JSON (for instance, Protocol buffers are an option).
-
-The constraints on gopls are that it must be easy to integrate into *every editor* on *all operating systems*, and that it should not have large external dependencies.
-
-JSON is part of the Go standard library, and is also the native language of LSP, so it makes the most sense. By far the best supported communication mechanism is the standard input and output of a process, and the common client implementations all have ways of using [JSON rpc 2] in this mode.  There were no complete and low dependency implementations of this protocol in Go, but it is a fairly small protocol on top of the JSON library that can be implemented with a moderate effort, and would be a generally useful library to have anyway.
-
-In the future it is expected to run in separated client server mode, so writing it in a way that could use sockets instead of stdin/stdout from the start was the best way to make sure it remained possible. It was also a huge debugging aid to be able to run the gopls server by hand and watch/debug it outside the editor.
-
-### Running other tools: *no*
-
-<!--- TODO: subprocess discuss --->
-
-## Features
-
-There is a set of features that gopls needs to expose to be a comprehensive IDE solution.
-The following is the minimum set of features, along with their existing solutions and how they should map to the LSP.
-
-### Introspection
-
-Introspection features tell developers information about their code while they work. They do not make or suggest changes.
-
----
-Diagnostics | Static analysis results of the code, including compilation and lint errors
------------ | ---
-Requires    | Full go/analysis run, which needs full AST, type and SSA information
-LSP         | [`textDocument/publishDiagnostics`]
-Previous    | `go build`, `go vet`, `golint`, [errcheck], [staticcheck] <!-- TODO: and all the rest -->
-|           | This is one of the most important IDE features, allowing fast turn around without having to run compilers and checkers in the shell. Often used to power problem lists, gutter markers and squiggle underlines in the IDE. <br/> There is some complicated design work to do in order to let users customize the set of checks being run, preferably without having to recompile the main LSP binary.
-
----
-Hover    | Information about the code under the cursor.
--------- | ---
-Requires | AST and type information for the file and all dependencies
-LSP      | [`textDocument/hover`]
-Previous | [godoc], [gogetdoc]
-|        | Used when reading code to display information known to the compiler but not always obvious from the code. For instance it may return the types of identifiers, or the documentation.
-
----
-Signature help | Function parameter information and documentation
--------------- | ---
-Requires       | AST and type information for the file and all dependencies
-LSP            | [`textDocument/signatureHelp`]
-Previous       | [gogetdoc]
-|              | As a function call is being typed into code, it is helpful to know the parameters of that call to enable the developer to call it correctly.
-
-
-### Navigation
-
-Navigation features are designed to make it easier for a developer to find their way round a code base.
-
----
-Definition | Select an identifier, and jump to the code where that identifier was defined.
----------- | ---
-Requires   | Full type information for file and all dependencies
-LSP        | [`textDocument/declaration`]
-|          | [`textDocument/definition`]
-|          | [`textDocument/typeDefinition`]
-Previous   | [godef] |
-|          | Asking the editor to open the place where a symbol was defined is one of the most commonly used code navigation tools inside an IDE when available. It is especially valuable when exploring an unfamiliar code base.<br/>Due to a limitation of the compiler output, it is not possible to use the binary data for this task (specifically it does not know column information) and thus it must parse from source.
-
----
-Implementation | Reports the types that implement an interface
--------------- | ---
-Requires       | Full workspace type knowledge
-LSP            | [`textDocument/implementation`]
-Previous       | [impl]
-|              | This feature is hard to scale up to large code bases, and is going to take thought to get right. It may be feasible to implemented a more limited form in the meantime.
-
----
-Document symbols | Provides the set of top level symbols in the current file.
----------------- | ---
-Requires         | AST of the current file only
-LSP              | [`textDocument/documentSymbol`]
-Previous         | [go-outline], [go-symbols]
-|                | Used to drive things like outline mode.
-
----
-References | Find all references to the symbol under the cursor.
----------- | ---
-Requires   | AST and type information for the **reverse** transitive closure
-LSP        | [`textDocument/references`]
-Previous   | [guru]
-|          | This requires knowledge of every package that could possible depend on any packages the current file is part of. In the past this has been implemented either by global knowledge, which does not scale, or by specifying a "scope" which confused users to the point where they just did not use the tools. gopls is probably going to need a more powerful solution in the long term, but to start with automatically limiting the scope may produce acceptable results. This would probably be the module if known, or some sensible parent directory otherwise.
-
-
----
-Folding  | Report logical hierarchies of blocks
--------- | ---
-Requires | AST of the current file only
-LSP      | [`textDocument/foldingRange`]
-Previous | [go-outline]
-|        | This is normally used to provide expand and collapse behavior in editors.
-
----
-Selection | Report regions of logical selection around the cursor
---------- | ---
-Requires  | AST of the current file only
-LSP       | [`textDocument/selectionRange`]
-Previous  | [guru]
-|         | Used in editor features like expand selection.
-
-
-### Edit assistance
-
-These features suggest or apply edits to the code for the user, including refactoring features, for which there are many potential use cases.
-Refactoring is one of the places where Go tools could potentially be very strong, but have not been so far, and thus there is huge potential for improvements in the developer experience.
-There is not yet a clear understanding of the kinds of refactoring people need or how they should express them however, and there are weaknesses in the LSP protocol around this.
-This means it may be much more of a research project.
-
-
----
-Format   | Fix the formatting of the file
--------- | ---
-Requires | AST of current file
-LSP      | [`textDocument/formatting`]
-|        | [`textDocument/rangeFormatting`]
-|        | [`textDocument/onTypeFormatting`]
-Previous | [gofmt], [goimports], [goreturns]
-|        | It will use the standard format package. <br/> Current limitations are that it does not work on malformed code. It may need some very careful changes to the formatter to allow for formatting an invalid AST or changes to force the AST to a valid mode. These changes would improve range and file mode as well, but are basically vital to onTypeFormatting
-
-
----
-Imports  | Rewrite the imports block automatically to match the symbols used.
--------- | ---
-Requires | AST of the current file and full symbol knowledge for all candidate packages.
-LSP      | [`textDocument/codeAction`]
-Previous | [goimports], [goreturns]
-|        | This needs knowledge of packages that are not yet in use, and the ability to find those packages by name. <br/> It also needs exported symbol information for all the packages it discovers. <br/> It should be implemented using the standard imports package, but there may need to be exposed a more fine grained API than just a file rewrite for some of the interactions.
-
-
----
-Autocompletion | Makes suggestions to complete the entity currently being typed.
--------------- | ---
-Requires       | AST and type information for the file and all dependencies<br/> Also full exported symbol knowledge for all packages.
-LSP            | [`textDocument/completion`]
-|              | [`completionItem/resolve`]
-Previous       | [gocode]
-|              | Autocomplete is one of the most complicated features, and the more it knows the better its suggestions can be. For instance it can autocomplete into packages that are not yet being imported if it has their public symbols. It can make better suggestions of options if it knows what kind of program you are writing. It can suggest better arguments if it knows how you normally call a function. It can suggest entire patterns of code if it knows they are common. Unlike many other features, which have a specific task, and once it is doing that task the feature is done, autocomplete will never be finished. Balancing and improving both the candidates and how they are ranked will be a research problem for a long time to come.
-
----
-Rename   | Rename an identifier
--------- | ---
-Requires | AST and type information for the **reverse** transitive closure
-LSP      | [`textDocument/rename`]
-|        | [`textDocument/prepareRename`]
-Previous | [gorename]
-|        | This uses the same information that find references does, with all the same problems and limitations. It is slightly worse because the changes it suggests make it intolerant of incorrect results. It is also dangerous using it to change the public API of a package.
-
----
-Suggested fixes | Suggestions that can be manually or automatically accepted to change the code
---------------- | ---
-Requires        | Full go/analysis run, which needs full AST, type and SSA information
-LSP             | [`textDocument/codeAction`]
-Previous        | N/A
-|               | This is a brand new feature powered by the new go/analysis engine, and it should allow a huge amount of automated refactoring.
-
-
-[LSP specification]: https://microsoft.github.io/language-server-protocol/specifications/specification-3-14/
-[talk]: TODO
-[slides]: https://github.com/gophercon/2019-talks/blob/master/RebeccaStambler-GoPleaseStopBreakingMyEditor/slides.pdf "Go, please stop breaking my editor!"
-[JSON rpc 2]: https://www.jsonrpc.org/specification
-
-[errcheck]: https://github.com/kisielk/errcheck
-[go-outline]: https://github.com/lukehoban/go-outline
-[go-symbols]: https://github.com/acroca/go-symbols
-[gocode]: https://github.com/stamblerre/gocode
-[godef]: https://github.com/rogpeppe/godef
-[godoc]: https://golang.org/cmd/godoc
-[gofmt]: https://golang.org/cmd/gofmt
-[gogetdoc]: https://github.com/zmb3/gogetdoc
-[goimports]: https://pkg.go.dev/golang.org/x/tools/cmd/goimports
-[gorename]: https://pkg.go.dev/golang.org/x/tools/cmd/gorename
-[goreturns]: https://github.com/sqs/goreturns
-[gotags]: https://github.com/jstemmer/gotags
-[guru]: https://pkg.go.dev/golang.org/x/tools/cmd/guru
-[impl]: https://github.com/josharian/impl
-[staticcheck]: https://staticcheck.io/docs/
-[go/types]: https://golang.org/pkg/go/types/
-[go/ast]: https://golang.org/pkg/go/ast/
-[go/token]: https://golang.org/pkg/go/token/
-
-
-[`completionItem/resolve`]:https://github.com/Microsoft/language-server-protocol/blob/gh-pages/_specifications/specification-3-14.md#completionItem_resolve
-[`textDocument/codeAction`]: https://github.com/Microsoft/language-server-protocol/blob/gh-pages/_specifications/specification-3-14.md#textDocument_codeAction
-[`textDocument/completion`]: https://github.com/Microsoft/language-server-protocol/blob/gh-pages/_specifications/specification-3-14.md#textDocument_completion
-[`textDocument/declaration`]: https://github.com/Microsoft/language-server-protocol/blob/gh-pages/_specifications/specification-3-14.md#textDocument_declaration
-[`textDocument/definition`]: https://github.com/Microsoft/language-server-protocol/blob/gh-pages/_specifications/specification-3-14.md#textDocument_definition
-[`textDocument/documentLink`]: https://github.com/Microsoft/language-server-protocol/blob/gh-pages/_specifications/specification-3-14.md#textDocument_documentLink
-[`textDocument/documentSymbol`]: https://github.com/Microsoft/language-server-protocol/blob/gh-pages/_specifications/specification-3-14.md#textDocument_documentSymbol
-[`textDocument/foldingRange`]: https://github.com/Microsoft/language-server-protocol/blob/gh-pages/_specifications/specification-3-14.md#textDocument_foldingRange
-[`textDocument/formatting`]: https://github.com/Microsoft/language-server-protocol/blob/gh-pages/_specifications/specification-3-14.md#textDocument_formatting
-[`textDocument/highlight`]: https://github.com/Microsoft/language-server-protocol/blob/gh-pages/_specifications/specification-3-14.md#textDocument_highlight
-[`textDocument/hover`]: https://github.com/Microsoft/language-server-protocol/blob/gh-pages/_specifications/specification-3-14.md#textDocument_hover
-[`textDocument/implementation`]: https://github.com/Microsoft/language-server-protocol/blob/gh-pages/_specifications/specification-3-14.md#textDocument_implementation
-[`textDocument/onTypeFormatting`]:https://github.com/Microsoft/language-server-protocol/blob/gh-pages/_specifications/specification-3-14.md#textDocument_onTypeFormatting
-[`textDocument/prepareRename`]:https://github.com/Microsoft/language-server-protocol/blob/gh-pages/_specifications/specification-3-14.md#textDocument_prepareRename
-[`textDocument/publishDiagnostics`]: https://github.com/Microsoft/language-server-protocol/blob/gh-pages/_specifications/specification-3-14.md#textDocument_publishDiagnostics
-[`textDocument/rangeFormatting`]: https://github.com/Microsoft/language-server-protocol/blob/gh-pages/_specifications/specification-3-14.md#textDocument_rangeFormatting
-[`textDocument/references`]: https://github.com/Microsoft/language-server-protocol/blob/gh-pages/_specifications/specification-3-14.md#textDocument_references
-[`textDocument/rename`]: https://github.com/Microsoft/language-server-protocol/blob/gh-pages/_specifications/specification-3-14.md#textDocument_rename
-[`textDocument/selectionRange`]:https://github.com/Microsoft/language-server-protocol/blob/gh-pages/_specifications/specification-3-14.md#textDocument_selectionRange
-[`textDocument/signatureHelp`]: https://github.com/Microsoft/language-server-protocol/blob/gh-pages/_specifications/specification-3-14.md#textDocument_signatureHelp
-[`textDocument/typeDefinition`]: https://github.com/Microsoft/language-server-protocol/blob/gh-pages/_specifications/specification-3-14.md#textDocument_typeDefinition
-[`workspace/didChangeWatchedFiles`]: https://github.com/Microsoft/language-server-protocol/blob/gh-pages/_specifications/specification-3-14.md#workspace_didChangeWatchedFiles
diff -urN a/gopls/doc/emacs.md b/gopls/doc/emacs.md
--- a/gopls/doc/emacs.md	2000-01-01 00:00:00.000000000 -0000
+++ b/gopls/doc/emacs.md	1969-12-31 19:00:00.000000000 -0500
@@ -1,70 +0,0 @@
-# Emacs
-
-Use [lsp-mode]. gopls is built in as a client. You first must install `gopls` and put it somewhere in your `PATH`. Here is a basic config to get you started (assuming you are using [use-package]):
-
-```lisp
-(use-package lsp-mode
-  :ensure t
-  :commands (lsp lsp-deferred)
-  :hook (go-mode . lsp-deferred))
-
-;; Set up before-save hooks to format buffer and add/delete imports.
-;; Make sure you don't have other gofmt/goimports hooks enabled.
-(defun lsp-go-install-save-hooks ()
-  (add-hook 'before-save-hook #'lsp-format-buffer t t)
-  (add-hook 'before-save-hook #'lsp-organize-imports t t))
-(add-hook 'go-mode-hook #'lsp-go-install-save-hooks)
-
-;; Optional - provides fancier overlays.
-(use-package lsp-ui
-  :ensure t
-  :commands lsp-ui-mode)
-
-;; Company mode is a standard completion package that works well with lsp-mode.
-(use-package company
-  :ensure t
-  :config
-  ;; Optionally enable completion-as-you-type behavior.
-  (setq company-idle-delay 0)
-  (setq company-minimum-prefix-length 1))
-
-;; Optional - provides snippet support.
-(use-package yasnippet
-  :ensure t
-  :commands yas-minor-mode
-  :hook (go-mode . yas-minor-mode))
-```
-
-lsp-mode integrates with xref. By default `lsp-find-definition` is bound to `M-.`. To go back, use `M-,`. Explore other `lsp-*` commands (not everything is supported by gopls).
-
-## Gopls Configuration
-
-Stable gopls settings have first-class support in [lsp-mode]. For example, `(setq lsp-gopls-use-placeholders nil)` will disable placeholders in completion snippets. See [lsp-go] for a list of available variables.
-
-Experimental settings can be configured via `lsp-register-custom-settings`:
-
-```lisp
-(lsp-register-custom-settings
- '(("gopls.completeUnimported" t t)
-   ("gopls.staticcheck" t t)))
-```
-
-See [settings] for information about gopls settings.
-
-Note that after changing settings you must restart gopls using e.g. `M-x lsp-restart-workspace`.
-
-## Troubleshooting
-
-Common errors:
-- When prompted by Emacs for your project folder, if you are using modules you must select the module's root folder (i.e. the directory with the "go.mod"). If you are using GOPATH, select your $GOPATH as your folder.
-- Emacs must have your environment set properly (PATH, GOPATH, etc). You can run `M-x getenv <RET> PATH <RET>` to see if your PATH is set in Emacs. If not, you can try starting Emacs from your terminal, using [this package][exec-path-from-shell], or moving your shell config from .bashrc into .bashenv (or .zshenv).
-- Make sure `lsp-mode` and `lsp-ui` are up-to-date, also make sure `lsp-go` and `company-lsp` are _not_ installed.
-- Look for errors in the `*lsp-log*` buffer.
-- Ask for help in the #emacs channel on the [Gophers slack].
-
-[lsp-mode]: https://github.com/emacs-lsp/lsp-mode
-[use-package]: https://github.com/jwiegley/use-package
-[exec-path-from-shell]: https://github.com/purcell/exec-path-from-shell
-[settings]: settings.md
-[lsp-go]: https://github.com/emacs-lsp/lsp-mode/blob/master/lsp-go.el
-[Gophers slack]: https://invite.slack.golangbridge.org/
diff -urN a/gopls/doc/faq.md b/gopls/doc/faq.md
--- a/gopls/doc/faq.md	2000-01-01 00:00:00.000000000 -0000
+++ b/gopls/doc/faq.md	1969-12-31 19:00:00.000000000 -0500
@@ -1,7 +0,0 @@
-# gopls FAQ
-
-## Why is it called gopls?
-
-Since gopls works both as a language server and as a command line tool, we wanted a name that could be used as a verb. For example, gopls check should read as "go please check." See: [cl/158197].
-
-[cl/158197]: https://golang.org/cl/158197
\ No newline at end of file
diff -urN a/gopls/doc/generate.go b/gopls/doc/generate.go
--- a/gopls/doc/generate.go	2000-01-01 00:00:00.000000000 -0000
+++ b/gopls/doc/generate.go	1969-12-31 19:00:00.000000000 -0500
@@ -1,120 +0,0 @@
-// Copyright 2020 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// Command generate updates settings.md from the UserOptions struct.
-package main
-
-import (
-	"bytes"
-	"encoding/json"
-	"fmt"
-	"io/ioutil"
-	"os"
-	"path/filepath"
-	"regexp"
-	"strings"
-
-	"golang.org/x/tools/internal/lsp/source"
-)
-
-func main() {
-	if _, err := doMain(".", true); err != nil {
-		fmt.Fprintf(os.Stderr, "Generation failed: %v\n", err)
-		os.Exit(1)
-	}
-}
-
-func doMain(baseDir string, write bool) (bool, error) {
-	api := &source.APIJSON{}
-	if err := json.Unmarshal([]byte(source.GeneratedAPIJSON), api); err != nil {
-		return false, err
-	}
-
-	if ok, err := rewriteFile(filepath.Join(baseDir, "gopls/doc/settings.md"), api, write, rewriteSettings); !ok || err != nil {
-		return ok, err
-	}
-	if ok, err := rewriteFile(filepath.Join(baseDir, "gopls/doc/commands.md"), api, write, rewriteCommands); !ok || err != nil {
-		return ok, err
-	}
-
-	return true, nil
-}
-
-func rewriteFile(file string, api *source.APIJSON, write bool, rewrite func([]byte, *source.APIJSON) ([]byte, error)) (bool, error) {
-	doc, err := ioutil.ReadFile(file)
-	if err != nil {
-		return false, err
-	}
-
-	content, err := rewrite(doc, api)
-	if err != nil {
-		return false, fmt.Errorf("rewriting %q: %v", file, err)
-	}
-
-	if !bytes.Equal(doc, content) && !write {
-		return false, nil
-	}
-
-	if err := ioutil.WriteFile(file, content, 0); err != nil {
-		return false, err
-	}
-
-	return true, nil
-}
-
-var parBreakRE = regexp.MustCompile("\n{2,}")
-
-func rewriteSettings(doc []byte, api *source.APIJSON) ([]byte, error) {
-	result := doc
-	for category, opts := range api.Options {
-		section := bytes.NewBuffer(nil)
-		for _, opt := range opts {
-			var enumValues strings.Builder
-			if len(opt.EnumValues) > 0 {
-				enumValues.WriteString("Must be one of:\n\n")
-				for _, val := range opt.EnumValues {
-					if val.Doc != "" {
-						// Don't break the list item by starting a new paragraph.
-						unbroken := parBreakRE.ReplaceAllString(val.Doc, "\\\n")
-						fmt.Fprintf(&enumValues, " * %s\n", unbroken)
-					} else {
-						fmt.Fprintf(&enumValues, " * `%s`\n", val.Value)
-					}
-				}
-			}
-			fmt.Fprintf(section, "### **%v** *%v*\n%v%v\n\nDefault: `%v`.\n", opt.Name, opt.Type, opt.Doc, enumValues.String(), opt.Default)
-		}
-		var err error
-		result, err = replaceSection(result, category, section.Bytes())
-		if err != nil {
-			return nil, err
-		}
-	}
-
-	section := bytes.NewBuffer(nil)
-	for _, lens := range api.Lenses {
-		fmt.Fprintf(section, "### **%v**\nIdentifier: `%v`\n\n%v\n\n", lens.Title, lens.Lens, lens.Doc)
-	}
-	return replaceSection(result, "Lenses", section.Bytes())
-}
-
-func rewriteCommands(doc []byte, api *source.APIJSON) ([]byte, error) {
-	section := bytes.NewBuffer(nil)
-	for _, command := range api.Commands {
-		fmt.Fprintf(section, "### **%v**\nIdentifier: `%v`\n\n%v\n\n", command.Title, command.Command, command.Doc)
-	}
-	return replaceSection(doc, "Commands", section.Bytes())
-}
-
-func replaceSection(doc []byte, sectionName string, replacement []byte) ([]byte, error) {
-	re := regexp.MustCompile(fmt.Sprintf(`(?s)<!-- BEGIN %v.* -->\n(.*?)<!-- END %v.* -->`, sectionName, sectionName))
-	idx := re.FindSubmatchIndex(doc)
-	if idx == nil {
-		return nil, fmt.Errorf("could not find section %q", sectionName)
-	}
-	result := append([]byte(nil), doc[:idx[2]]...)
-	result = append(result, replacement...)
-	result = append(result, doc[idx[3]:]...)
-	return result, nil
-}
diff -urN a/gopls/doc/generate_test.go b/gopls/doc/generate_test.go
--- a/gopls/doc/generate_test.go	2000-01-01 00:00:00.000000000 -0000
+++ b/gopls/doc/generate_test.go	1969-12-31 19:00:00.000000000 -0500
@@ -1,23 +0,0 @@
-// Copyright 2020 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package main
-
-import (
-	"testing"
-
-	"golang.org/x/tools/internal/testenv"
-)
-
-func TestGenerated(t *testing.T) {
-	testenv.NeedsGoBuild(t) // This is a lie. We actually need the source code.
-
-	ok, err := doMain("../..", false)
-	if err != nil {
-		t.Fatal(err)
-	}
-	if !ok {
-		t.Error("documentation needs updating. run: `go run gopls/doc/generate.go` from the root of tools.")
-	}
-}
diff -urN a/gopls/doc/implementation.md b/gopls/doc/implementation.md
--- a/gopls/doc/implementation.md	2000-01-01 00:00:00.000000000 -0000
+++ b/gopls/doc/implementation.md	1969-12-31 19:00:00.000000000 -0500
@@ -1,48 +0,0 @@
-# gopls implementation documentation
-
-This is not intended as a complete description of the implementation, for the most the part the package godoc, code comments and the code itself hold that.
-Instead this is meant to be a guide into finding parts of the implementation, and understanding some core concepts used throughout the implementation.
-
-## View/Session/Cache
-
-Throughout the code there are references to these three concepts, and they build on each other.
-
-At the base is the *Cache*. This is the level at which we hold information that is global in nature, for instance information about the file system and its contents.
-
-Above that is the *Session*, which holds information for a connection to an editor. This layer hold things like the edited files (referred to as overlays).
-
-The top layer is called the *View*. This holds the configuration, and the mapping to configured packages.
-
-The purpose of this layering is to allow a single editor session to have multiple views active whilst still sharing as much information as possible for efficiency.
-In theory if only the View layer existed, the results would be identical, but slower and using more memory.
-
-## Code location
-
-gopls will be developed in the [x/tools] Go repository; the core packages are in [internal/lsp], and the binary and integration tests are located in [gopls].
-
-Below is a list of the core packages of gopls, and their primary purpose:
-
-Package | Description
---- | ---
-[gopls] | the main binary, plugins and integration tests
-[internal/lsp] | the core message handling package
-[internal/lsp/cache] | the cache layer
-[internal/lsp/cmd] | the gopls command line layer
-[internal/lsp/debug] | features to aid in debugging gopls
-[internal/lsp/protocol] | the lsp protocol layer and wire format
-[internal/lsp/source] | the core feature implementations
-[internal/span] | a package for dealing with source file locations
-[internal/memoize] | a function invocation cache used to reduce the work done
-[internal/jsonrpc2] | an implementation of the JSON RPC2 specification
-
-[gopls]: https://github.com/golang/tools/tree/master/gopls
-[internal/jsonrpc2]: https://github.com/golang/tools/tree/master/internal/jsonrpc2
-[internal/lsp]: https://github.com/golang/tools/tree/master/internal/lsp
-[internal/lsp/cache]: https://github.com/golang/tools/tree/master/internal/lsp/cache
-[internal/lsp/cmd]: https://github.com/golang/tools/tree/master/internal/lsp/cmd
-[internal/lsp/debug]: https://github.com/golang/tools/tree/master/internal/lsp/debug
-[internal/lsp/protocol]: https://github.com/golang/tools/tree/master/internal/lsp/protocol
-[internal/lsp/source]: https://github.com/golang/tools/tree/master/internal/lsp/source
-[internal/memoize]: https://github.com/golang/tools/tree/master/internal/memoize
-[internal/span]: https://github.com/golang/tools/tree/master/internal/span
-[x/tools]: https://github.com/golang/tools
diff -urN a/gopls/doc/integrating.md b/gopls/doc/integrating.md
--- a/gopls/doc/integrating.md	2000-01-01 00:00:00.000000000 -0000
+++ b/gopls/doc/integrating.md	1969-12-31 19:00:00.000000000 -0500
@@ -1,91 +0,0 @@
-# Documentation for plugin authors
-
-If you are integrating `gopls` into an editor by writing an editor plugin, there are quite a few semantics of the communication between the editor and `gopls` that are not specified by the [LSP specification].
-
-We attempt to document those details along with any other information that has been helpful to other plugin authors here.
-
-If you are implementing a plugin yourself and have questions this page does not answer, please reach out to us to ask, and then also contribute your findings back to this page.
-
-## Supported features
-
-For the most part you should look at the [list](status.md#supported-features) in the current status document to know if gopls supports a feature.
-For a truly authoritative answer you should check the [result][InitializeResult] of the [initialize] request, where gopls enumerates its support in the [ServerCapabilities].
-
-
-## Positions and ranges
-
-Many LSP requests pass position or range information. This is described in the [LSP specification][lsp-text-documents]:
-
-> A position inside a document (see Position definition below) is expressed as a zero-based line and character offset. The offsets are based on a UTF-16 string representation. So a string of the form a𐐀b the character offset of the character a is 0, the character offset of 𐐀 is 1 and the character offset of b is 3 since 𐐀 is represented using two code units in UTF-16.
-
-This means that integrators will need to calculate UTF-16 based column offsets.
-
-[`golang.org/x/tools/internal/span`] has the code to do this in go.
-[#31080] tracks making `span` and other useful packages non-internal.
-
-## Edits
-
-In order to deliver changes from gopls to the editor, the LSP supports arrays of [`TextEdit`][lsp-textedit]s in responses.
-The spec specifies exactly how these should be applied:
-
-> All text edits ranges refer to positions in the original document. Text edits ranges must never overlap, that means no part of the original document must be manipulated by more than one edit. However, it is possible that multiple edits have the same start position: multiple inserts, or any number of inserts followed by a single remove or replace edit. If multiple inserts have the same position, the order in the array defines the order in which the inserted strings appear in the resulting text.
-
-All `[]TextEdit` are sorted such that applying the array of deltas received in reverse order achieves the desired result that holds with the spec.
-
-## Errors
-
-Various error codes are described in the [LSP specification][lsp-response]. We are still determining what it means for a method to return an error; are errors only for low-level LSP/transport issues or can other conditions cause errors to be returned? See some of this discussion on [#31526].
-
-The method chosen is currently influenced by the exact treatment in the currently popular editor integrations. It may well change, and ideally would become more coherent across requests.
-
-* [`textDocument/codeAction`]: Return error if there was an error computing code actions.
-* [`textDocument/completion`]: Log errors, return empty result list.
-* [`textDocument/definition`]: Return error if there was an error computing the definition for the position.
-* [`textDocument/typeDefinition`]: Return error if there was an error computing the type definition for the position.
-* [`textDocument/formatting`]: Return error if there was an error formatting the file.
-* [`textDocument/highlight`]: Log errors, return empty result.
-* [`textDocument/hover`]: Return empty result.
-* [`textDocument/documentLink`]: Log errors, return nil result.
-* [`textDocument/publishDiagnostics`]: Log errors if there were any while computing diagnostics.
-* [`textDocument/references`]: Log errors, return empty result.
-* [`textDocument/rename`]: Return error if there was an error computing renames.
-* [`textDocument/signatureHelp`]: Log errors, return nil result.
-* [`textDocument/documentSymbols`]: Return error if there was an error computing document symbols.
-
-## Watching files
-
-It is fairly normal for files that affect `gopls` to be modified outside of the editor it is associated with.
-
-For instance, files that are needed to do correct type checking are modified by switching branches in git, or updated by a code generator.
-
-Monitoring files inside gopls directly has a lot of awkward problems, but the [LSP specification] has methods that allow gopls to request that the client notify it of file system changes, specifically [`workspace/didChangeWatchedFiles`].
-This is currently being added to gopls by a community member, and tracked in [#31553]
-
-[InitializeResult]: https://pkg.go.dev/golang.org/x/tools/internal/lsp/protocol#InitializeResult
-[ServerCapabilities]: https://pkg.go.dev/golang.org/x/tools/internal/lsp/protocol#ServerCapabilities
-[`golang.org/x/tools/internal/span`]: https://pkg.go.dev/golang.org/x/tools/internal/span#NewPoint
-
-[LSP specification]: https://microsoft.github.io/language-server-protocol/specifications/specification-3-14/
-[lsp-response]: https://github.com/Microsoft/language-server-protocol/blob/gh-pages/_specifications/specification-3-14.md#response-message
-[initialize]: https://microsoft.github.io/language-server-protocol/specifications/specification-3-14/#initialize
-[lsp-text-documents]: https://github.com/Microsoft/language-server-protocol/blob/gh-pages/_specifications/specification-3-14.md#text-documents
-[lsp-textedit]: https://github.com/Microsoft/language-server-protocol/blob/gh-pages/_specifications/specification-3-14.md#textedit
-
-[`textDocument/codeAction`]: https://github.com/Microsoft/language-server-protocol/blob/gh-pages/_specifications/specification-3-14.md#textDocument_codeAction
-[`textDocument/completion`]: https://github.com/Microsoft/language-server-protocol/blob/gh-pages/_specifications/specification-3-14.md#textDocument_completion
-[`textDocument/definition`]: https://github.com/Microsoft/language-server-protocol/blob/gh-pages/_specifications/specification-3-14.md#textDocument_definition
-[`textDocument/typeDefinition`]: https://github.com/Microsoft/language-server-protocol/blob/gh-pages/_specifications/specification-3-14.md#textDocument_typeDefinition
-[`textDocument/formatting`]: https://github.com/Microsoft/language-server-protocol/blob/gh-pages/_specifications/specification-3-14.md#textDocument_formatting
-[`textDocument/highlight`]: https://github.com/Microsoft/language-server-protocol/blob/gh-pages/_specifications/specification-3-14.md#textDocument_highlight
-[`textDocument/hover`]: https://github.com/Microsoft/language-server-protocol/blob/gh-pages/_specifications/specification-3-14.md#textDocument_hover
-[`textDocument/documentLink`]: https://github.com/Microsoft/language-server-protocol/blob/gh-pages/_specifications/specification-3-14.md#textDocument_documentLink
-[`textDocument/publishDiagnostics`]: https://github.com/Microsoft/language-server-protocol/blob/gh-pages/_specifications/specification-3-14.md#textDocument_publishDiagnostics
-[`textDocument/references`]: https://github.com/Microsoft/language-server-protocol/blob/gh-pages/_specifications/specification-3-14.md#textDocument_references
-[`textDocument/rename`]: https://github.com/Microsoft/language-server-protocol/blob/gh-pages/_specifications/specification-3-14.md#textDocument_rename
-[`textDocument/signatureHelp`]: https://github.com/Microsoft/language-server-protocol/blob/gh-pages/_specifications/specification-3-14.md#textDocument_signatureHelp
-[`textDocument/documentSymbols`]: https://github.com/Microsoft/language-server-protocol/blob/gh-pages/_specifications/specification-3-14.md#textDocument_documentSymbols
-[`workspace/didChangeWatchedFiles`]: https://github.com/Microsoft/language-server-protocol/blob/gh-pages/_specifications/specification-3-14.md#workspace_didChangeWatchedFiles
-
-[#31080]: https://github.com/golang/go/issues/31080
-[#31553]: https://github.com/golang/go/issues/31553
-[#31526]: https://github.com/golang/go/issues/31526
diff -urN a/gopls/doc/settings.md b/gopls/doc/settings.md
--- a/gopls/doc/settings.md	2000-01-01 00:00:00.000000000 -0000
+++ b/gopls/doc/settings.md	1969-12-31 19:00:00.000000000 -0500
@@ -1,313 +0,0 @@
-# Settings
-
-<!--TODO: Generate this file from the documentation in golang/org/x/tools/internal/lsp/source/options.go.-->
-
-This document describes the global settings for `gopls` inside the editor. The settings block will be called `"gopls"` and contains a collection of controls for `gopls` that the editor is not expected to understand or control. These settings can also be configured differently per workspace folder.
-
-In VSCode, this would be a section in your `settings.json` file that might look like this:
-
-```json5
-  "gopls": {
-    "usePlaceholders": true,
-    "completeUnimported": true
-  },
-```
-
-## Officially supported
-
-Below is the list of settings that are officially supported for `gopls`.
-
-To enable all experimental features, use **allExperiments: `true`**. You will
-still be able to independently override specific experimental features.
-
-<!-- BEGIN User: DO NOT MANUALLY EDIT THIS SECTION -->
-### **buildFlags** *[]string*
-buildFlags is the set of flags passed on to the build system when invoked.
-It is applied to queries like `go list`, which is used when discovering files.
-The most common use is to set `-tags`.
-
-
-Default: `[]`.
-### **env** *map[string]string*
-env adds environment variables to external commands run by `gopls`, most notably `go list`.
-
-
-Default: `{}`.
-### **hoverKind** *enum*
-hoverKind controls the information that appears in the hover text.
-SingleLine and Structured are intended for use only by authors of editor plugins.
-Must be one of:
-
- * `"FullDocumentation"`
- * `"NoDocumentation"`
- * `"SingleLine"`
- * `"Structured"` is an experimental setting that returns a structured hover format.
-This format separates the signature from the documentation, so that the client
-can do more manipulation of these fields.\
-This should only be used by clients that support this behavior.
-
- * `"SynopsisDocumentation"`
-
-
-Default: `"FullDocumentation"`.
-### **usePlaceholders** *bool*
-placeholders enables placeholders for function parameters or struct fields in completion responses.
-
-
-Default: `false`.
-### **linkTarget** *string*
-linkTarget controls where documentation links go.
-It might be one of:
-
-* `"godoc.org"`
-* `"pkg.go.dev"`
-
-If company chooses to use its own `godoc.org`, its address can be used as well.
-
-
-Default: `"pkg.go.dev"`.
-### **local** *string*
-local is the equivalent of the `goimports -local` flag, which puts imports beginning with this string after 3rd-party packages.
-It should be the prefix of the import path whose imports should be grouped separately.
-
-
-Default: `""`.
-### **gofumpt** *bool*
-gofumpt indicates if we should run gofumpt formatting.
-
-
-Default: `false`.
-### **analyses** *map[string]bool*
-analyses specify analyses that the user would like to enable or disable.
-A map of the names of analysis passes that should be enabled/disabled.
-A full list of analyzers that gopls uses can be found [here](analyzers.md)
-
-Example Usage:
-```json5
-...
-"analyses": {
-  "unreachable": false, // Disable the unreachable analyzer.
-  "unusedparams": true  // Enable the unusedparams analyzer.
-}
-...
-```
-
-
-Default: `{}`.
-### **codelenses** *map[string]bool*
-codelenses overrides the enabled/disabled state of code lenses. See the "Code Lenses"
-section of settings.md for the list of supported lenses.
-
-Example Usage:
-```json5
-"gopls": {
-...
-  "codelens": {
-    "generate": false,  // Don't show the `go generate` lens.
-    "gc_details": true  // Show a code lens toggling the display of gc's choices.
-  }
-...
-}
-```
-
-
-Default: `{"gc_details":false,"generate":true,"regenerate_cgo":true,"tidy":true,"upgrade_dependency":true,"vendor":true}`.
-### **linksInHover** *bool*
-linksInHover toggles the presence of links to documentation in hover.
-
-
-Default: `true`.
-### **importShortcut** *enum*
-importShortcut specifies whether import statements should link to
-documentation or go to definitions.
-Must be one of:
-
- * `"Both"`
- * `"Definition"`
- * `"Link"`
-
-
-Default: `"Both"`.
-### **matcher** *enum*
-matcher sets the algorithm that is used when calculating completion candidates.
-Must be one of:
-
- * `"CaseInsensitive"`
- * `"CaseSensitive"`
- * `"Fuzzy"`
-
-
-Default: `"Fuzzy"`.
-### **symbolMatcher** *enum*
-symbolMatcher sets the algorithm that is used when finding workspace symbols.
-Must be one of:
-
- * `"CaseInsensitive"`
- * `"CaseSensitive"`
- * `"Fuzzy"`
-
-
-Default: `"Fuzzy"`.
-### **symbolStyle** *enum*
-symbolStyle controls how symbols are qualified in symbol responses.
-
-Example Usage:
-```json5
-"gopls": {
-...
-  "symbolStyle": "dynamic",
-...
-}
-```
-Must be one of:
-
- * `"Dynamic"` uses whichever qualifier results in the highest scoring
-match for the given symbol query. Here a "qualifier" is any "/" or "."
-delimited suffix of the fully qualified symbol. i.e. "to/pkg.Foo.Field" or
-just "Foo.Field".
-
- * `"Full"` is fully qualified symbols, i.e.
-"path/to/pkg.Foo.Field".
-
- * `"Package"` is package qualified symbols i.e.
-"pkg.Foo.Field".
-
-
-
-Default: `"Dynamic"`.
-<!-- END User: DO NOT MANUALLY EDIT THIS SECTION -->
-
-## Experimental
-
-The below settings are considered experimental. They may be deprecated or changed in the future. They are typically used to test experimental opt-in features or to disable features.
-
-<!-- BEGIN Experimental: DO NOT MANUALLY EDIT THIS SECTION -->
-### **annotations** *map[string]bool*
-annotations suppress various kinds of optimization diagnostics
-that would be reported by the gc_details command.
- * noNilcheck suppresses display of nilchecks.
- * noEscape suppresses escape choices.
- * noInline suppresses inlining choices.
- * noBounds suppresses bounds checking diagnostics.
-
-
-Default: `{}`.
-### **staticcheck** *bool*
-staticcheck enables additional analyses from staticcheck.io.
-
-
-Default: `false`.
-### **semanticTokens** *bool*
-semanticTokens controls whether the LSP server will send
-semantic tokens to the client.
-
-
-Default: `false`.
-### **expandWorkspaceToModule** *bool*
-expandWorkspaceToModule instructs `gopls` to adjust the scope of the
-workspace to find the best available module root. `gopls` first looks for
-a go.mod file in any parent directory of the workspace folder, expanding
-the scope to that directory if it exists. If no viable parent directory is
-found, gopls will check if there is exactly one child directory containing
-a go.mod file, narrowing the scope to that directory if it exists.
-
-
-Default: `true`.
-### **experimentalWorkspaceModule** *bool*
-experimentalWorkspaceModule opts a user into the experimental support
-for multi-module workspaces.
-
-
-Default: `false`.
-### **experimentalDiagnosticsDelay** *time.Duration*
-experimentalDiagnosticsDelay controls the amount of time that gopls waits
-after the most recent file modification before computing deep diagnostics.
-Simple diagnostics (parsing and type-checking) are always run immediately
-on recently modified packages.
-
-This option must be set to a valid duration string, for example `"250ms"`.
-
-
-Default: `"0s"`.
-### **experimentalPackageCacheKey** *bool*
-experimentalPackageCacheKey controls whether to use a coarser cache key
-for package type information to increase cache hits. This setting removes
-the user's environment, build flags, and working directory from the cache
-key, which should be a safe change as all relevant inputs into the type
-checking pass are already hashed into the key. This is temporarily guarded
-by an experiment because caching behavior is subtle and difficult to
-comprehensively test.
-
-
-Default: `true`.
-<!-- END Experimental: DO NOT MANUALLY EDIT THIS SECTION -->
-
-## Debugging
-
-The below settings are for use in debugging `gopls`. Like the experimental options, they may be deprecated or changed in the future.
-
-<!-- BEGIN Debugging: DO NOT MANUALLY EDIT THIS SECTION -->
-### **verboseOutput** *bool*
-verboseOutput enables additional debug logging.
-
-
-Default: `false`.
-### **completionBudget** *time.Duration*
-completionBudget is the soft latency goal for completion requests. Most
-requests finish in a couple milliseconds, but in some cases deep
-completions can take much longer. As we use up our budget we
-dynamically reduce the search scope to ensure we return timely
-results. Zero means unlimited.
-
-
-Default: `"100ms"`.
-<!-- END Debugging: DO NOT MANUALLY EDIT THIS SECTION -->
-
-## Code Lenses
-
-These are the code lenses that `gopls` currently supports. They can be enabled and disabled using the `codeLenses` setting, documented above. The names and features are subject to change.
-
-<!-- BEGIN Lenses: DO NOT MANUALLY EDIT THIS SECTION -->
-### **Run go generate**
-Identifier: `generate`
-
-generate runs `go generate` for a given directory.
-
-
-### **Regenerate cgo**
-Identifier: `regenerate_cgo`
-
-regenerate_cgo regenerates cgo definitions.
-
-
-### **Run test(s)**
-Identifier: `test`
-
-test runs `go test` for a specific test function.
-
-
-### **Run go mod tidy**
-Identifier: `tidy`
-
-tidy runs `go mod tidy` for a module.
-
-
-### **Upgrade dependency**
-Identifier: `upgrade_dependency`
-
-upgrade_dependency upgrades a dependency.
-
-
-### **Run go mod vendor**
-Identifier: `vendor`
-
-vendor runs `go mod vendor` for a module.
-
-
-### **Toggle gc_details**
-Identifier: `gc_details`
-
-gc_details controls calculation of gc annotations.
-
-
-<!-- END Lenses: DO NOT MANUALLY EDIT THIS SECTION -->
diff -urN a/gopls/doc/status.md b/gopls/doc/status.md
--- a/gopls/doc/status.md	2000-01-01 00:00:00.000000000 -0000
+++ b/gopls/doc/status.md	1969-12-31 19:00:00.000000000 -0500
@@ -1,37 +0,0 @@
-# Status
-
-gopls is currently in **alpha**, so it is **not stable**.
-
-gopls is currently under active development by the Go team. The code is in the [x/tools] repository, in [golang.org/x/tools/internal/lsp] and [golang.org/x/tools/gopls].
-
-## Supported features
-
-<!--- TODO: supported features
-details and status for the features
-missing features
---->
-
-### Autocompletion
-### Jump to definition
-### Signature help
-### Hover
-### Document symbols
-### References
-### Rename
-
-## Known issues
-
-1. Editing multiple modules in one editor window: [#32394]
-1. Type checking does not work in cgo packages: [#35721]
-1. Does not work with build tags: [#29202]
-1. Find references and rename only work in a single package: [#32877]
-
-[x/tools]: https://github.com/golang/tools
-[golang.org/x/tools/gopls]: https://github.com/golang/tools/tree/master/gopls
-[golang.org/x/tools/internal/lsp]: https://github.com/golang/tools/tree/master/internal/lsp
-
-
-[#32394]: https://github.com/golang/go/issues/32394
-[#35721]: https://github.com/golang/go/issues/35721
-[#29202]: https://github.com/golang/go/issues/29202
-[#32877]: https://github.com/golang/go/issues/32877
diff -urN a/gopls/doc/subl.md b/gopls/doc/subl.md
--- a/gopls/doc/subl.md	2000-01-01 00:00:00.000000000 -0000
+++ b/gopls/doc/subl.md	1969-12-31 19:00:00.000000000 -0500
@@ -1,11 +0,0 @@
-# Sublime Text
-
-Use the [LSP] package. After installing it using Package Control, do the following:
-
-* Open the **Command Palette**
-* Find and run the command **LSP: Enable Language Server Globally**
-* Select the **gopls** item. Be careful not to select the similarly named *golsp* by mistake.
-
-Finally, you should familiarise yourself with the LSP package's *Settings* and *Key Bindings*. Find them under the menu item **Preferences > Package Settings > LSP**.
-
-[LSP]: https://packagecontrol.io/packages/LSP
diff -urN a/gopls/doc/troubleshooting.md b/gopls/doc/troubleshooting.md
--- a/gopls/doc/troubleshooting.md	2000-01-01 00:00:00.000000000 -0000
+++ b/gopls/doc/troubleshooting.md	1969-12-31 19:00:00.000000000 -0500
@@ -1,85 +0,0 @@
-# Troubleshooting
-
-If you suspect that `gopls` is crashing or not working correctly, please follow the [troubleshooting steps](#steps) below.
-
-If `gopls` is using too much memory, please follow the steps under [Memory usage](#memory-usage).
-
-## Steps
-
-<!--- TODO: troubleshooting
-describe more basic and optional trouble shooting steps
-  like checking you opened the module root
-  and using the debug pages
---->
-
-1. Make sure your `gopls` is [up to date](user.md#installing).
-1. Check the [known issues](status.md#known-issues).
-1. [Report the issue](#file-an-issue).
-
-## File an issue
-
-You can use:
-
-* Your editor's bug submission integration (if available). For instance, `:GoReportGitHubIssue` in [`vim-go`](vim.md#vim-go).
-* `gopls bug` on the command line.
-* The [Go issue tracker](https://github.com/golang/go/issues/new?title=x%2Ftools%2Fgopls%3A%20%3Cfill%20this%20in%3E).
-
-Along with an explanation of the issue, please share the information listed here:
-
-1. Your editor and any settings you have configured (for example, your VSCode `settings.json` file).
-1. A sample program that reproduces the issue, if possible.
-1. The output of `gopls version` on the command line.
-1. The output of `gopls -rpc.trace -v check /path/to/file.go`.
-1. gopls logs from when the issue occurred, as well as a timestamp for when the issue began to occur. See the [instructions](#capturing-gopls-logs) for information on how to capture gopls logs.
-
-Much of this information is filled in for you if you use `gopls bug` to file the issue.
-
-### Capturing logs
-
-#### VS Code
-
-For VSCode users, the gopls log can be found by navigating to `View` -> `Output` (or `Ctrl+K Ctrl+H`). There will be a drop-down menu titled `Tasks` in the top-right corner. Select the `gopls (server)` item, which will contain the `gopls` logs.
-
-To increase the level of detail in your logs, add the following to your VS Code settings:
-
-```json5
-"go.languageServerFlags": [
-  "-rpc.trace"
-]
-```
-
-To start a debug server that will allow you to see profiles and memory usage, add the following to your VS Code settings:
-
-```json5
-"go.languageServerFlags": [
-  "serve",
-  "-rpc.trace",
-  "--debug=localhost:6060",
-],
-```
-
-You will then be able to view debug information by navigating to `localhost:6060`.
-
-#### Other editors
-
-For other editors, you may have to directly pass a `-logfile` flag to gopls.
-
-To increase the level of detail in your logs, start `gopls` with the `-rpc.trace` flag. To start a debug server that will allow you to see profiles and memory usage, start `gopls` with `serve --debug=localhost:6060`. You will then be able to view debug information by navigating to `localhost:6060`.
-
-If you are unsure of how to pass a flag to `gopls` through your editor, please see the [documentation for your editor](user.md#editors).
-
-### Restart your editor
-
-Once you have filed an issue, you can then try to restart your `gopls` instance by restarting your editor. In many cases, this will correct the problem. In VSCode, the easiest way to restart the language server is by opening the command palette (Ctrl + Shift + P) and selecting `"Go: Restart Language Server"`. You can also reload the VSCode instance by selecting `"Developer: Reload Window"`.
-
-## Memory usage
-
-`gopls` automatically writes out memory debug information when your usage
-exceeds 1GB. This information can be found in your temporary directory with
-names like `gopls.1234-5GiB-withnames.zip`. On Windows, your temporary
-directory will be located at `%TMP%`, and on Unixes, it will be `$TMPDIR`,
-which is usually `/tmp`. Please create a
-[new issue](https://github.com/golang/go/issues/new?title=x%2Ftools%2Fgopls%3A%20%3Cfill%20this%20in%3E)
-with your editor settings and memory debug information attached. If you are
-uncomfortable sharing the package names of your code, you can share the
-`-nonames` zip instead.
diff -urN a/gopls/doc/user.md b/gopls/doc/user.md
--- a/gopls/doc/user.md	2000-01-01 00:00:00.000000000 -0000
+++ b/gopls/doc/user.md	1969-12-31 19:00:00.000000000 -0500
@@ -1,156 +0,0 @@
-# User guide
-
-##### If you're having issues with `gopls`, please see the [troubleshooting guide](troubleshooting.md).
-
-This document focuses on VSCode, as at the time of writing, VSCode is the most popular Go editor. However, most of the features described here work in any editor. The settings should be easy to translate to those of another editor's LSP client. The differences will be in the place where you define the settings and the syntax with which you declare them.
-
-## Editors
-
-The following is the list of editors with known integrations.
-If you use `gopls` with an editor that is not on this list, please let us know by [filing an issue](#new-issue) or [modifying this documentation](#contribute).
-
-* [VSCode](vscode.md)
-* [Vim / Neovim](vim.md)
-* [Emacs](emacs.md)
-* [Acme](acme.md)
-* [Sublime Text](subl.md)
-* [Atom](atom.md)
-
-## Installation
-
-For the most part, you should not need to install or update `gopls`. Your editor should handle that step for you.
-
-If you do want to get the latest stable version of `gopls`, change to any directory that is both outside of your `GOPATH` and outside of a module (a temp directory is fine), and run
-
-```sh
-go get golang.org/x/tools/gopls@latest
-```
-
-**Do not** use the `-u` flag, as it will update your dependencies to incompatible versions.
-
-To get a specific version of `gopls` (for example, to test a prerelease
-version), run:
-
-```sh
-go get golang.org/x/tools/gopls@vX.Y.Z
-```
-
-Where `vX.Y.Z` is the desired version.
-
-If you see this error:
-
-```sh
-$ go get golang.org/x/tools/gopls@latest
-go: cannot use path@version syntax in GOPATH mode
-```
-
-then run
-
-```sh
-GO111MODULE=on go get golang.org/x/tools/gopls@latest
-```
-
-### Unstable versions
-
-`go get` doesn't honor the `replace` directive in the `go.mod` of
-`gopls` when you are outside of the `gopls` module, so a simple `go get`
-with `@master` could fail.  To actually update your `gopls` to the
-latest **unstable** version, use:
-
-```sh
-go get golang.org/x/tools/gopls@master golang.org/x/tools@master
-```
-
-In general, you should use `@latest` instead, to prevent frequent
-breakages.
-
-### Supported Go versions
-
-`gopls` follows the
-[Go Release Policy](https://golang.org/doc/devel/release.html#policy),
-meaning that it officially supports the last 2 major Go releases. We run CI to
-verify that the `gopls` tests pass for the last 4 major Go releases, but do not
-prioritize issues only affecting legacy Go release (3 or 4 releases ago).
-
-## Configurations
-
-### Environment variables
-
-These are often inherited from the editor that launches `gopls`, and sometimes the editor has a way to add or replace values before launching. For example, VSCode allows you to configure `go.toolsEnvVars`.
-
-Configuring your environment correctly is important, as `gopls` relies on the `go` command.
-
-### Command line flags
-
-See the [command line page](command-line.md) for more information about the flags you might specify.
-All editors support some way of adding flags to `gopls`, for the most part you should not need to do this unless you have very unusual requirements or are trying to [troubleshoot](troubleshooting.md#steps) `gopls` behavior.
-
-### Editor settings
-
-For the most part these will be settings that control how the editor interacts with or uses the results of `gopls`, not modifications to `gopls` itself. This means they are not standardized across editors, and you will have to look at the specific instructions for your editor integration to change them.
-
-#### The set of workspace folders
-
-This is one of the most important pieces of configuration. It is the set of folders that gopls considers to be "roots" that it should consider files to be a part of.
-
-If you are using modules there should be one of these per go.mod that you are working on.
-If you do not open the right folders, very little will work. **This is the most common misconfiguration of `gopls` that we see**.
-
-#### Global configuration
-
-There should be a way of declaring global settings for `gopls` inside the editor. The settings block will be called `"gopls"` and contains a collection of controls for `gopls` that the editor is not expected to understand or control.
-
-In VSCode, this would be a section in your settings file that might look like this:
-
-```json5
-  "gopls": {
-    "usePlaceholders": true,
-    "completeUnimported": true
-  },
-```
-
-See [Settings](settings.md) for more information about the available configurations.
-
-#### Workspace folder configuration
-
-This contains exactly the same set of values that are in the global configuration, but it is fetched for every workspace folder separately. The editor can choose to respond with different values per-folder.
-
-## Special Features
-
-### Symbol Queries
-
-Gopls supports some extended syntax for `workspace/symbol` requests, when using
-the `fuzzy` symbol matcher (the default). Inspired by the popular fuzzy matcher
-[FZF](https://github.com/junegunn/fzf), the following special characters are
-supported within symbol queries:
-
-| Character | Usage     | Match        |
-| --------- | --------- | ------------ |
-| `'`       | `'abc`    | exact        |
-| `^`       | `^printf` | exact prefix |
-| `$`       | `printf$` | exact suffix |
-
-### Working on the Go source distribution
-
-If you are working on the [Go project](https://go.googlesource.com/go) itself, your `go` command will have to correspond to the version of the source you are working on. That is, if you have downloaded the code to `$HOME/go`, your `go` command should be the `$HOME/go/bin/go` executable that you built with `make.bash` or equivalent.
-
-You can achieve this by adding the right version of `go` to your `PATH` (`export PATH=$HOME/go/bin:$PATH` on Unix systems) or by configuring your editor. In VS Code, you can use the `go.alternateTools` setting to point to the correct version of `go`:
-
-```json5
-{
-
-    "go.alternateTools": {
-        "go": "$HOME/bin/go"
-    }
-}
-```
-
-## Command line support
-
-Much of the functionality of `gopls` is available through a command line interface.
-
-There are two main reasons for this. The first is that we do not want users to rely on separate command line tools when they wish to do some task outside of an editor. The second is that the CLI assists in debugging. It is easier to reproduce behavior via single command.
-
-It is not a goal of `gopls` to be a high performance command line tool. Its command line is intended for single file/package user interaction speeds, not bulk processing.
-
-For more information, see the `gopls` [command line page](command-line.md).
diff -urN a/gopls/doc/vim.md b/gopls/doc/vim.md
--- a/gopls/doc/vim.md	2000-01-01 00:00:00.000000000 -0000
+++ b/gopls/doc/vim.md	1969-12-31 19:00:00.000000000 -0500
@@ -1,193 +0,0 @@
-# Vim / Neovim
-
-## vim-go
-
-Use [vim-go] ver 1.20+, with the following configuration:
-
-```
-let g:go_def_mode='gopls'
-let g:go_info_mode='gopls'
-```
-
-## LanguageClient-neovim
-
-Use [LanguageClient-neovim], with the following configuration:
-
-```
-" Launch gopls when Go files are in use
-let g:LanguageClient_serverCommands = {
-       \ 'go': ['gopls']
-       \ }
-" Run gofmt on save
-autocmd BufWritePre *.go :call LanguageClient#textDocument_formatting_sync()
-```
-
-## Ale
-
-Use [ale]:
-
-```vim
-let g:ale_linters = {
-	\ 'go': ['gopls'],
-	\}
-```
-
-see [this issue][ale-issue-2179]
-
-## vim-lsp
-
-Use [prabirshrestha/vim-lsp], with the following configuration:
-
-```vim
-augroup LspGo
-  au!
-  autocmd User lsp_setup call lsp#register_server({
-      \ 'name': 'go-lang',
-      \ 'cmd': {server_info->['gopls']},
-      \ 'whitelist': ['go'],
-      \ })
-  autocmd FileType go setlocal omnifunc=lsp#complete
-  "autocmd FileType go nmap <buffer> gd <plug>(lsp-definition)
-  "autocmd FileType go nmap <buffer> ,n <plug>(lsp-next-error)
-  "autocmd FileType go nmap <buffer> ,p <plug>(lsp-previous-error)
-augroup END
-```
-
-## vim-lsc
-
-Use [natebosch/vim-lsc], with the following configuration:
-
-```vim
-let g:lsc_server_commands = {
-\  "go": {
-\    "command": "gopls serve",
-\    "log_level": -1,
-\    "suppress_stderr": v:true,
-\  },
-\}
-```
-
-The `log_level` and `suppress_stderr` parts are needed to prevent breakage from logging. See
-issues [#180](https://github.com/natebosch/vim-lsc/issues/180) and
-[#213](https://github.com/natebosch/vim-lsc/issues/213).
-
-## coc.nvim
-
-Use [coc.nvim], with the following `coc-settings.json` configuration:
-
-```json
-  "languageserver": {
-    "golang": {
-      "command": "gopls",
-      "rootPatterns": ["go.mod", ".vim/", ".git/", ".hg/"],
-      "filetypes": ["go"],
-      "initializationOptions": {
-        "usePlaceholders": true
-      }
-    }
-  }
-```
-
-Other [settings](settings.md) can be added in `initializationOptions` too.
-
-The `editor.action.organizeImport` code action will auto-format code and add missing imports. To run this automatically on save, add the following line to your `init.vim`:
-
-```vim
-autocmd BufWritePre *.go :call CocAction('runCommand', 'editor.action.organizeImport')
-```
-
-## govim
-
-In vim classic only, use the experimental [`govim`], simply follow the [install steps][govim-install].
-
-## Neovim v0.5.0+
-
-To use the new (still experimental) native LSP client in Neovim, make sure you
-[install][nvim-install] the prerelease v0.5.0 version of Neovim (aka “nightly”),
-the `nvim-lspconfig` configuration helper plugin, and check the
-[`gopls` configuration section][nvim-lspconfig] there.
-
-### Custom configuration
-
-You can add custom configuration using Lua.  Here is an example of enabling the
-`unusedparams` check as well as `staticcheck`:
-
-```vim
-lua <<EOF
-  nvim_lsp = require "lspconfig"
-  nvim_lsp.gopls.setup {
-    cmd = {"gopls", "serve"},
-    settings = {
-      gopls = {
-        analyses = {
-          unusedparams = true,
-        },
-        staticcheck = true,
-      },
-    },
-  }
-EOF
-```
-
-### Imports
-
-To get your imports ordered on save, like `goimports` does, you can define
-a helper function in Lua:
-
-```vim
-lua <<EOF
-  -- …
-
-  function goimports(timeoutms)
-    local context = { source = { organizeImports = true } }
-    vim.validate { context = { context, "t", true } }
-
-    local params = vim.lsp.util.make_range_params()
-    params.context = context
-
-    local method = "textDocument/codeAction"
-    local resp = vim.lsp.buf_request_sync(0, method, params, timeoutms)
-    if resp and resp[1] then
-      local result = resp[1].result
-      if result and result[1] then
-        local edit = result[1].edit
-        vim.lsp.util.apply_workspace_edit(edit)
-      end
-    end
-
-    vim.lsp.buf.formatting()
-  end
-EOF
-
-autocmd BufWritePre *.go lua goimports(1000)
-```
-
-(Taken from the [discussion][nvim-lspconfig-imports] on Neovim issue tracker.)
-
-### Omnifunc
-
-To make your <kbd>Ctrl</kbd>+<kbd>x</kbd>,<kbd>Ctrl</kbd>+<kbd>o</kbd> work, add
-this to your `init.vim`:
-
-```vim
-autocmd FileType go setlocal omnifunc=v:lua.vim.lsp.omnifunc
-```
-
-### Additional Links
-
-* [Neovim's official LSP documentation][nvim-docs].
-
-[vim-go]: https://github.com/fatih/vim-go
-[LanguageClient-neovim]: https://github.com/autozimu/LanguageClient-neovim
-[ale]: https://github.com/w0rp/ale
-[ale-issue-2179]: https://github.com/w0rp/ale/issues/2179
-[prabirshrestha/vim-lsp]: https://github.com/prabirshrestha/vim-lsp/
-[natebosch/vim-lsc]: https://github.com/natebosch/vim-lsc/
-[natebosch/vim-lsc#180]: https://github.com/natebosch/vim-lsc/issues/180
-[coc.nvim]: https://github.com/neoclide/coc.nvim/
-[`govim`]: https://github.com/myitcv/govim
-[govim-install]: https://github.com/myitcv/govim/blob/master/README.md#govim---go-development-plugin-for-vim8
-[nvim-docs]: https://neovim.io/doc/user/lsp.html
-[nvim-install]: https://github.com/neovim/neovim/wiki/Installing-Neovim
-[nvim-lspconfig]: https://github.com/neovim/nvim-lspconfig#gopls
-[nvim-lspconfig-imports]: https://github.com/neovim/nvim-lspconfig/issues/115
diff -urN a/gopls/doc/vscode.md b/gopls/doc/vscode.md
--- a/gopls/doc/vscode.md	2000-01-01 00:00:00.000000000 -0000
+++ b/gopls/doc/vscode.md	1969-12-31 19:00:00.000000000 -0500
@@ -1,74 +0,0 @@
-# VSCode
-
-Use the [VSCode-Go] plugin, with the following configuration:
-
-```json5
-"go.useLanguageServer": true,
-"[go]": {
-    "editor.formatOnSave": true,
-    "editor.codeActionsOnSave": {
-        "source.organizeImports": true,
-    },
-    // Optional: Disable snippets, as they conflict with completion ranking.
-    "editor.snippetSuggestions": "none",
-},
-"[go.mod]": {
-    "editor.formatOnSave": true,
-    "editor.codeActionsOnSave": {
-        "source.organizeImports": true,
-    },
-},
-"gopls": {
-     // Add parameter placeholders when completing a function.
-    "usePlaceholders": true,
-
-    // If true, enable additional analyses with staticcheck.
-    // Warning: This will significantly increase memory usage.
-    "staticcheck": false,
-}
-```
-
-VSCode will complain about the `"gopls"` settings, but they will still work. Once we have a consistent set of settings, we will make the changes in the VSCode plugin necessary to remove the errors.
-
-If you encounter problems with import organization, please try setting a higher code action timeout (any value greater than 750ms), for example:
-
-```json5
-"[go]": {
-  "editor.codeActionsOnSaveTimeout": 3000
-}
-```
-
-To enable more detailed debug information, add the following to your VSCode settings:
-
-```json5
-"go.languageServerFlags": [
-    "-rpc.trace", // for more detailed debug logging
-    "serve",
-    "--debug=localhost:6060", // to investigate memory usage, see profiles
-],
-```
-
-See the section on [command line](command-line.md) arguments for more information about what these do, along with other things like `--logfile=auto` that you might want to use.
-
-You can disable features through the `"go.languageServerExperimentalFeatures"` section of the config. An example of a feature you may want to disable is `"documentLink"`, which opens [`pkg.go.dev`](https://pkg.go.dev) links when you click on import statements in your file.
-
-### Build tags
-
-build tags will not be picked from `go.buildTags` configuration section, instead they should be specified as part of the`GOFLAGS` environment variable:
-
-```json5
-"go.toolsEnvVars": {
-    "GOFLAGS": "-tags=<yourtag>"
-}
-```
-
-
-[VSCode-Go]: https://github.com/golang/vscode-go
-
-# VSCode Remote Development with gopls
-
-You can also make use of `gopls` with the [VSCode Remote Development](https://code.visualstudio.com/docs/remote/remote-overview) extensions to enable full-featured Go development on a lightweight client machine, while connected to a more powerful server machine.
-
-First, install the Remote Development extension of your choice, such as the [Remote - SSH](https://code.visualstudio.com/docs/remote/ssh) extension. Once you open a remote session in a new window, open the Extensions pane (Ctrl+Shift+X) and you will see several different sections listed. In the "Local - Installed" section, navigate to the Go extension and click "Install in SSH: hostname".
-
-Once you have reloaded VSCode, you will be prompted to install `gopls` and other Go-related tools. After one more reload, you should be ready to develop remotely with VSCode and the Go extension.
diff -urN a/gopls/go.mod b/gopls/go.mod
--- a/gopls/go.mod	2000-01-01 00:00:00.000000000 -0000
+++ b/gopls/go.mod	1969-12-31 19:00:00.000000000 -0500
@@ -1,14 +0,0 @@
-module golang.org/x/tools/gopls
-
-go 1.12
-
-require (
-	github.com/sergi/go-diff v1.1.0
-	golang.org/x/tools v0.0.0-20201021214918-23787c007979
-	golang.org/x/xerrors v0.0.0-20200804184101-5ec99f83aff1
-	honnef.co/go/tools v0.0.1-2020.1.6
-	mvdan.cc/gofumpt v0.0.0-20200927160801-5bfeb2e70dd6
-	mvdan.cc/xurls/v2 v2.2.0
-)
-
-replace golang.org/x/tools => ../
diff -urN a/gopls/go.sum b/gopls/go.sum
--- a/gopls/go.sum	2000-01-01 00:00:00.000000000 -0000
+++ b/gopls/go.sum	1969-12-31 19:00:00.000000000 -0500
@@ -1,58 +0,0 @@
-github.com/BurntSushi/toml v0.3.1 h1:WXkYYl6Yr3qBf1K79EBnL4mak0OimBfB0XUf9Vl28OQ=
-github.com/BurntSushi/toml v0.3.1/go.mod h1:xHWCNGjB5oqiDr8zfno3MHue2Ht5sIBksp03qcyfWMU=
-github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
-github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=
-github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
-github.com/google/go-cmp v0.5.1 h1:JFrFEBb2xKufg6XkJsJr+WbKb4FQlURi5RUcBveYu9k=
-github.com/google/go-cmp v0.5.1/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=
-github.com/google/renameio v0.1.0/go.mod h1:KWCgfxg9yswjAJkECMjeO8J8rahYeXnNhOm40UhjYkI=
-github.com/kisielk/gotool v1.0.0/go.mod h1:XhKaO+MFFWcvkIS/tQcRk01m1F5IRFswLeQ+oQHNcck=
-github.com/kr/pretty v0.1.0 h1:L/CwN0zerZDmRFUapSPitk6f+Q3+0za1rQkzVuMiMFI=
-github.com/kr/pretty v0.1.0/go.mod h1:dAy3ld7l9f0ibDNOQOHHMYYIIbhfbHSm3C4ZsoJORNo=
-github.com/kr/pty v1.1.1/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=
-github.com/kr/text v0.1.0 h1:45sCR5RtlFHMR4UwH9sdQ5TC8v0qDQCHnXt+kaKSTVE=
-github.com/kr/text v0.1.0/go.mod h1:4Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/4vfdArNI=
-github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=
-github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
-github.com/rogpeppe/go-internal v1.3.0/go.mod h1:M8bDsm7K2OlrFYOpmOWEs/qY81heoFRclV5y23lUDJ4=
-github.com/rogpeppe/go-internal v1.5.2/go.mod h1:xXDCJY+GAPziupqXw64V24skbSoqbTEfhy4qGm1nDQc=
-github.com/rogpeppe/go-internal v1.6.1/go.mod h1:xXDCJY+GAPziupqXw64V24skbSoqbTEfhy4qGm1nDQc=
-github.com/sergi/go-diff v1.1.0 h1:we8PVUC3FE2uYfodKH/nBHMSetSfHDR6scGdBi+erh0=
-github.com/sergi/go-diff v1.1.0/go.mod h1:STckp+ISIX8hZLjrqAeVduY0gWCT9IjLuqbuNXdaHfM=
-github.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=
-github.com/stretchr/testify v1.4.0 h1:2E4SXV/wtOkTonXsotYi4li6zVWxYlZuYNCXe9XRJyk=
-github.com/stretchr/testify v1.4.0/go.mod h1:j7eGeouHqKxXV5pUuKE4zz7dFj8WfuZ+81PSLYec5m4=
-github.com/yuin/goldmark v1.2.1/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=
-golang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=
-golang.org/x/crypto v0.0.0-20191011191535-87dc89f01550/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=
-golang.org/x/crypto v0.0.0-20200622213623-75b288015ac9/go.mod h1:LzIPMQfyMNhhGPhUkYOs5KpL4U8rLKemX1yGLhDgUto=
-golang.org/x/mod v0.2.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=
-golang.org/x/mod v0.3.0 h1:RM4zey1++hCTbCVQfnWeKs9/IEsaBLA8vTkd0WVtmH4=
-golang.org/x/mod v0.3.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=
-golang.org/x/net v0.0.0-20190404232315-eb5bcb51f2a3/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=
-golang.org/x/net v0.0.0-20201021035429-f5854403a974/go.mod h1:sp8m0HH+o8qH0wwXwYZr8TS3Oi6o0r6Gce1SSxlDquU=
-golang.org/x/sync v0.0.0-20201020160332-67f06af15bc9 h1:SQFwaSi55rU7vdNs9Yr0Z324VNlrF+0wMqRXT4St8ck=
-golang.org/x/sync v0.0.0-20201020160332-67f06af15bc9/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
-golang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
-golang.org/x/sys v0.0.0-20190412213103-97732733099d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
-golang.org/x/sys v0.0.0-20200930185726-fdedc70b468f/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
-golang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=
-golang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=
-golang.org/x/xerrors v0.0.0-20191011141410-1b5146add898/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
-golang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
-golang.org/x/xerrors v0.0.0-20200804184101-5ec99f83aff1 h1:go1bK/D/BFZV2I8cIQd1NKEZ+0owSTG1fDTci4IqFcE=
-golang.org/x/xerrors v0.0.0-20200804184101-5ec99f83aff1/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
-gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
-gopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
-gopkg.in/check.v1 v1.0.0-20190902080502-41f04d3bba15 h1:YR8cESwS4TdDjEe65xsg0ogRM/Nc3DYOhEAlW+xobZo=
-gopkg.in/check.v1 v1.0.0-20190902080502-41f04d3bba15/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
-gopkg.in/errgo.v2 v2.1.0/go.mod h1:hNsd1EY+bozCKY1Ytp96fpM3vjJbqLJn88ws8XvfDNI=
-gopkg.in/yaml.v2 v2.2.2/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=
-gopkg.in/yaml.v2 v2.2.4 h1:/eiJrUcujPVeJ3xlSWaiNi3uSVmDGBK1pDHUHAnao1I=
-gopkg.in/yaml.v2 v2.2.4/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=
-honnef.co/go/tools v0.0.1-2020.1.6 h1:W18jzjh8mfPez+AwGLxmOImucz/IFjpNlrKVnaj2YVc=
-honnef.co/go/tools v0.0.1-2020.1.6/go.mod h1:pyyisuGw24ruLjrr1ddx39WE0y9OooInRzEYLhQB2YY=
-mvdan.cc/gofumpt v0.0.0-20200927160801-5bfeb2e70dd6 h1:z+/YqapuV7VZPvBb3GYmuEJbA88M3PFUxaHilHYVCpQ=
-mvdan.cc/gofumpt v0.0.0-20200927160801-5bfeb2e70dd6/go.mod h1:bzrjFmaD6+xqohD3KYP0H2FEuxknnBmyyOxdhLdaIws=
-mvdan.cc/xurls/v2 v2.2.0 h1:NSZPykBXJFCetGZykLAxaL6SIpvbVy/UFEniIfHAa8A=
-mvdan.cc/xurls/v2 v2.2.0/go.mod h1:EV1RMtya9D6G5DMYPGD8zTQzaHet6Jh8gFlRgGRJeO8=
diff -urN a/gopls/integration/govim/Dockerfile b/gopls/integration/govim/Dockerfile
--- a/gopls/integration/govim/Dockerfile	2000-01-01 00:00:00.000000000 -0000
+++ b/gopls/integration/govim/Dockerfile	1969-12-31 19:00:00.000000000 -0500
@@ -1,16 +0,0 @@
-# Copyright 2019 The Go Authors. All rights reserved.
-# Use of this source code is governed by a BSD-style
-# license that can be found in the LICENSE file.
-
-# govim requires a more recent version of vim than is available in most
-# distros, so we build from their base image.
-FROM govim/govim:latest-vim
-ARG GOVIM_REF
-
-ENV GOPROXY=https://proxy.golang.org GOPATH=/go VIM_FLAVOR=vim
-WORKDIR /src
-
-# Clone govim. In order to use the go command for resolving latest, we download
-# a redundant copy of govim to the build cache using `go mod download`.
-RUN git clone https://github.com/govim/govim /src/govim && cd /src/govim && \
-    git checkout $GOVIM_REF
diff -urN a/gopls/integration/govim/README.md b/gopls/integration/govim/README.md
--- a/gopls/integration/govim/README.md	2000-01-01 00:00:00.000000000 -0000
+++ b/gopls/integration/govim/README.md	1969-12-31 19:00:00.000000000 -0500
@@ -1,47 +0,0 @@
-# govim integration tests
-
-Files in this directory configure Cloud Build to run [govim] integration tests
-against a gopls binary built from source.
-
-## Running on GCP
-
-To run these integration tests in Cloud Build, use the following steps.  Here
-we assume that `$PROJECT_ID` is a valid GCP project and `$BUCKET` is a cloud
-storage bucket owned by that project.
-
-- `cd` to the root directory of the tools project.
-- (at least once per GCP project) Build the test harness:
-```
-$ gcloud builds submit \
-	--project="${PROJECT_ID}" \
-	--config=gopls/integration/govim/cloudbuild.harness.yaml
-```
-- Run the integration tests:
-```
-$ gcloud builds submit \
-	--project="${PROJECT_ID}" \
-	--config=gopls/integration/govim/cloudbuild.yaml \
-	--substitutions=_RESULT_BUCKET="${BUCKET}"
-```
-
-## Fetching Artifacts
-
-Assuming the artifacts bucket is world readable, you can fetch integration from
-GCS. They are located at:
-
-- logs: `https://storage.googleapis.com/${BUCKET}/log-${EVALUATION_ID}.txt`
-- artifact tarball: `https://storage.googleapis.com/${BUCKET}/govim/${EVALUATION_ID}/artifacts.tar.gz`
-
-The `artifacts.go` command can be used to fetch both artifacts using an
-evaluation id.
-
-## Running locally
-
-Run `gopls/integration/govim/run_local.sh`. This may take a while the first
-time it is run, as it will require building the test harness. This script
-accepts two flags to modify its behavior:
-
-**--sudo**: run docker with `sudo`
-**--short**: run `go test -short`
-
-[govim]: https://github.com/govim/govim
diff -urN a/gopls/integration/govim/artifacts.go b/gopls/integration/govim/artifacts.go
--- a/gopls/integration/govim/artifacts.go	2000-01-01 00:00:00.000000000 -0000
+++ b/gopls/integration/govim/artifacts.go	1969-12-31 19:00:00.000000000 -0500
@@ -1,67 +0,0 @@
-// Copyright 2020 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package main
-
-import (
-	"flag"
-	"fmt"
-	"io/ioutil"
-	"net/http"
-	"os"
-	"path"
-)
-
-var bucket = flag.String("bucket", "golang-gopls_integration_tests", "GCS bucket holding test artifacts.")
-
-const usage = `
-artifacts [--bucket=<bucket ID>] <cloud build evaluation ID>
-
-Fetch artifacts from an integration test run. Evaluation ID should be extracted
-from the cloud build notification.
-
-In order for this to work, the GCS bucket that artifacts were written to must
-be publicly readable. By default, this fetches from the
-golang-gopls_integration_tests bucket.
-`
-
-func main() {
-	flag.Usage = func() {
-		fmt.Fprint(flag.CommandLine.Output(), usage)
-	}
-	flag.Parse()
-	if flag.NArg() != 1 {
-		flag.Usage()
-		os.Exit(2)
-	}
-	evalID := flag.Arg(0)
-	logURL := fmt.Sprintf("https://storage.googleapis.com/%s/log-%s.txt", *bucket, evalID)
-	if err := download(logURL); err != nil {
-		fmt.Fprintf(os.Stderr, "downloading logs: %v", err)
-	}
-	tarURL := fmt.Sprintf("https://storage.googleapis.com/%s/govim/%s/artifacts.tar.gz", *bucket, evalID)
-	if err := download(tarURL); err != nil {
-		fmt.Fprintf(os.Stderr, "downloading artifact tarball: %v", err)
-	}
-}
-
-func download(artifactURL string) error {
-	name := path.Base(artifactURL)
-	resp, err := http.Get(artifactURL)
-	if err != nil {
-		return fmt.Errorf("fetching from GCS: %v", err)
-	}
-	defer resp.Body.Close()
-	if resp.StatusCode != http.StatusOK {
-		return fmt.Errorf("got status code %d from GCS", resp.StatusCode)
-	}
-	data, err := ioutil.ReadAll(resp.Body)
-	if err != nil {
-		return fmt.Errorf("reading result: %v", err)
-	}
-	if err := ioutil.WriteFile(name, data, 0644); err != nil {
-		return fmt.Errorf("writing artifact: %v", err)
-	}
-	return nil
-}
diff -urN a/gopls/integration/govim/cloudbuild.harness.yaml b/gopls/integration/govim/cloudbuild.harness.yaml
--- a/gopls/integration/govim/cloudbuild.harness.yaml	2000-01-01 00:00:00.000000000 -0000
+++ b/gopls/integration/govim/cloudbuild.harness.yaml	1969-12-31 19:00:00.000000000 -0500
@@ -1,21 +0,0 @@
-# Copyright 2019 The Go Authors. All rights reserved.
-# Use of this source code is governed by a BSD-style
-# license that can be found in the LICENSE file.
-
-# Build the govim test harness that will be used to run govim integration tests
-# for gopls. See README.md for instructions on how to use this.
-steps:
-  - name: 'gcr.io/cloud-builders/docker'
-    args: ['build',
-      # To allow for breaking changes to this test harness, tag with a major
-      # version number.
-      '-t', 'gcr.io/$PROJECT_ID/govim-harness:latest',
-      '-t', 'gcr.io/$PROJECT_ID/govim-harness:3',
-      # It is assumed that this build is running from the root directory of the
-      # tools repository.
-      '-f', 'gopls/integration/govim/Dockerfile',
-      # Use the integration test directory as build context: the test harness
-      # doesn't actually require any local files.
-      'gopls/integration/govim']
-images:
-  - gcr.io/$PROJECT_ID/govim-harness
diff -urN a/gopls/integration/govim/cloudbuild.yaml b/gopls/integration/govim/cloudbuild.yaml
--- a/gopls/integration/govim/cloudbuild.yaml	2000-01-01 00:00:00.000000000 -0000
+++ b/gopls/integration/govim/cloudbuild.yaml	1969-12-31 19:00:00.000000000 -0500
@@ -1,51 +0,0 @@
-# Copyright 2019 The Go Authors. All rights reserved.
-# Use of this source code is governed by a BSD-style
-# license that can be found in the LICENSE file.
-
-# Build gopls, and run the govim integration tests.  See README.md for
-# instructions on how to use this.
-
-substitutions:
-  # This bucket must be owned by the GCP project executing the build. If
-  # you are running this from your own project, override using --substitutions.
-  _RESULT_BUCKET: 'golang-gopls_integration_tests'
-
-steps:
-  # Build gopls from source, to use with the govim integration tests.
-  - name: 'golang:1.14'
-    env: ['GOPROXY=https://proxy.golang.org']
-    dir: 'gopls'
-    args: ['go', 'build']
-
-  # Run the tests. Note that the script in this step does not return the exit
-  # code from `go test`, but rather saves it for use in the final step after
-  # uploading artifacts.
-  - name: 'gcr.io/$PROJECT_ID/govim-harness:3'
-    dir: '/src/govim'
-    volumes:
-      - name: artifacts
-        path: /artifacts
-    env:
-      - GOVIM_TESTSCRIPT_WORKDIR_ROOT=/artifacts
-      - VIM_FLAVOR=vim
-    args: ['/workspace/gopls/integration/govim/run_tests_for_cloudbuild.sh']
-
-  # The govim tests produce a large number of artifacts; tarball/gzip to reduce
-  # roundtrips and save space.
-  - name: 'ubuntu'
-    volumes:
-      - name: artifacts
-        path: /artifacts
-    args: ['tar', '-czf', 'artifacts.tar.gz', '/artifacts']
-
-  # Upload artifacts to GCS.
-  - name: 'gcr.io/cloud-builders/gsutil'
-    args: ['cp', 'artifacts.tar.gz', 'gs://${_RESULT_BUCKET}/govim/${BUILD_ID}/artifacts.tar.gz']
-
-  # Exit with the actual exit code of the integration tests.
-  - name: 'ubuntu'
-    args: ['bash', 'govim_test_result.sh']
-
-# Write build logs to the same bucket as artifacts, so they can be more easily
-# shared.
-logsBucket: 'gs://${_RESULT_BUCKET}'
diff -urN a/gopls/integration/govim/run_local.sh b/gopls/integration/govim/run_local.sh
--- a/gopls/integration/govim/run_local.sh	2000-01-01 00:00:00.000000000 -0000
+++ b/gopls/integration/govim/run_local.sh	1969-12-31 19:00:00.000000000 -0500
@@ -1,96 +0,0 @@
-#!/bin/bash -e
-
-# Copyright 2019 The Go Authors. All rights reserved.
-# Use of this source code is governed by a BSD-style
-# license that can be found in the LICENSE file.
-
-# Run govim integration tests against a local gopls.
-
-usage() {
-  cat <<EOUSAGE
-Usage: $0 [--sudo] [--short] [--version (semver|latest)]
-
-Args:
-  --sudo     run docker with sudo
-  --short    run `go test` with `-short`
-  --version  run on the specific tagged Go version (or latest) rather
-             than the default branch
-
-Run govim tests against HEAD using local docker.
-EOUSAGE
-}
-
-SUDO_IF_NEEDED=
-TEST_SHORT=
-DOCKERFILE=gopls/integration/govim/Dockerfile
-GOVIM_REF=main
-while [[ $# -gt 0 ]]; do
-  case "$1" in
-    "-h" | "--help" | "help")
-      usage
-      exit 0
-      ;;
-    "--sudo")
-      SUDO_IF_NEEDED="sudo "
-      shift
-      ;;
-    "--short")
-      TEST_SHORT="-short"
-      shift
-      ;;
-    "--version")
-      if [[ -z "$2" ]]; then
-        usage
-        exit 1
-      fi
-      GOVIM_REF=$2
-      if [[ "${GOVIM_REF}" == "latest" ]]; then
-        TMPGOPATH=$(mktemp -d)
-        trap "GOPATH=${TMPGOPATH} go clean -modcache && rm -r ${TMPGOPATH}" EXIT
-        GOVIM_REF=$(GOPATH=${TMPGOPATH} go mod download -json \
-          github.com/govim/govim@latest | jq -r .Version)
-      fi
-      shift 2
-      ;;
-    *)
-      usage
-      exit 1
-  esac
-done
-
-# Find the tools root, so that this script can be run from any directory.
-script_dir=$(dirname "$(readlink -f "$0")")
-tools_dir=$(readlink -f "${script_dir}/../../..")
-
-# Build gopls.
-cd "${tools_dir}/gopls"
-temp_gopls=$(mktemp -p "$PWD")
-trap "rm -f \"${temp_gopls}\"" EXIT
-# For consistency across environments, use golang docker to build rather than
-# the local go command.
-${SUDO_IF_NEEDED}docker run --rm -t \
-  -v "${tools_dir}:/src/tools" \
-  -w "/src/tools/gopls" \
-  golang:latest \
-  go build -o $(basename ${temp_gopls})
-
-# Build the test harness. Here we are careful to pass in a very limited build
-# context so as to optimize caching.
-echo "Checking out govim@${GOVIM_REF}"
-cd "${tools_dir}"
-${SUDO_IF_NEEDED}docker build \
-  --build-arg GOVIM_REF="${GOVIM_REF}" \
-  -t gopls-govim-harness:${GOVIM_REF} \
-  -f gopls/integration/govim/Dockerfile \
-  gopls/integration/govim
-
-# Run govim integration tests.
-echo "running govim integration tests using ${temp_gopls}"
-temp_gopls_name=$(basename "${temp_gopls}")
-${SUDO_IF_NEEDED}docker run --rm -t \
-  -v "${tools_dir}:/src/tools" \
-  -w "/src/govim" \
-  --ulimit memlock=-1:-1 \
-  gopls-govim-harness:${GOVIM_REF} \
-  go test ${TEST_SHORT} ./cmd/govim \
-    -gopls "/src/tools/gopls/${temp_gopls_name}"
diff -urN a/gopls/integration/govim/run_tests_for_cloudbuild.sh b/gopls/integration/govim/run_tests_for_cloudbuild.sh
--- a/gopls/integration/govim/run_tests_for_cloudbuild.sh	2000-01-01 00:00:00.000000000 -0000
+++ b/gopls/integration/govim/run_tests_for_cloudbuild.sh	1969-12-31 19:00:00.000000000 -0500
@@ -1,28 +0,0 @@
-#!/bin/bash
-
-# Copyright 2020 The Go Authors. All rights reserved.
-# Use of this source code is governed by a BSD-style
-# license that can be found in the LICENSE file.
-
-# This script runs govim integration tests but always succeeds, instead writing
-# their result to a file so that any test failure can be deferred to a later
-# build step. We do this so that we can capture govim test artifacts regardless
-# of the test results.
-
-# Substitute the locally built gopls binary for use in govim integration tests.
-go test -short ./cmd/govim -gopls /workspace/gopls/gopls
-
-# Stash the error, for use in a later build step.
-echo "exit $?" > /workspace/govim_test_result.sh
-
-# Clean up unnecessary artifacts. This is based on govim/_scripts/tidyUp.bash.
-# Since we're fetching govim using the go command, we won't have this non-go
-# source directory available to us.
-if [[ -n "$GOVIM_TESTSCRIPT_WORKDIR_ROOT" ]]; then
-  echo "Cleaning up build artifacts..."
-  # Make artifacts writable so that rm -rf doesn't complain.
-  chmod -R u+w "$GOVIM_TESTSCRIPT_WORKDIR_ROOT"
-
-  # Remove directories we don't care about.
-  find "$GOVIM_TESTSCRIPT_WORKDIR_ROOT" -type d \( -name .vim -o -name gopath \) -prune -exec rm -rf '{}' \;
-fi
diff -urN a/gopls/integration/parse/parse.go b/gopls/integration/parse/parse.go
--- a/gopls/integration/parse/parse.go	2000-01-01 00:00:00.000000000 -0000
+++ b/gopls/integration/parse/parse.go	1969-12-31 19:00:00.000000000 -0500
@@ -1,230 +0,0 @@
-// Copyright 2019 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// Package parse provides functions to parse LSP logs.
-// Fully processed logs are returned by ToRLog().
-package parse
-
-import (
-	"bufio"
-	"encoding/json"
-	"errors"
-	"fmt"
-	"log"
-	"os"
-	"regexp"
-	"strings"
-)
-
-// MsgType is the type of message.
-type MsgType int
-
-const (
-	// ClRequest from client to server has method and id
-	ClRequest MsgType = iota
-	// ClResponse from server to client
-	ClResponse
-	// SvRequest from server to client, has method and id
-	SvRequest
-	// SvResponse from client to server
-	SvResponse
-	// ToServer notification has method, but no id
-	ToServer
-	// ToClient notification
-	ToClient
-	// ReportErr is an error message
-	ReportErr // errors have method and id
-)
-
-// Logmsg is the type of a parsed log entry.
-type Logmsg struct {
-	Type    MsgType
-	Method  string
-	ID      string      // for requests/responses. Client and server request ids overlap
-	Elapsed string      // for responses
-	Hdr     string      // header. do we need to keep all these strings?
-	Rest    string      // the unparsed result, with newlines or not
-	Body    interface{} // the parsed result
-}
-
-// ReadLogs from a file. Most users should use ToRlog().
-func ReadLogs(fname string) ([]*Logmsg, error) {
-	byid := make(map[string]int)
-	msgs := []*Logmsg{}
-	fd, err := os.Open(fname)
-	if err != nil {
-		return nil, err
-	}
-	defer fd.Close()
-	logrdr := bufio.NewScanner(fd)
-	logrdr.Buffer(nil, 1<<25) //  a large buffer, for safety
-	logrdr.Split(scanLogs)
-	for i := 0; logrdr.Scan(); i++ {
-		flds := strings.SplitN(logrdr.Text(), "\n", 2)
-		if len(flds) == 1 {
-			flds = append(flds, "") // for Errors
-		}
-		msg, err := parselog(flds[0], flds[1])
-		if err != nil {
-			return nil, fmt.Errorf("failed to parse %q: %v", logrdr.Text(), err)
-		}
-		switch msg.Type {
-		case ClRequest, SvRequest:
-			v, err := msg.unmarshal(Requests(msg.Method))
-			if err != nil {
-				return nil, fmt.Errorf("%v for %s, %T", err, msg.Method, Requests(msg.Method))
-			}
-			msg.Body = v
-		case ClResponse, SvResponse:
-			v, err := msg.doresponse()
-			if err != nil {
-				return nil, fmt.Errorf("%v %s", err, msg.Method)
-			}
-			msg.Body = v
-		case ToServer, ToClient:
-			v, err := msg.unmarshal(Notifs(msg.Method))
-			if err != nil && Notifs(msg.Method) != nil {
-				return nil, fmt.Errorf("%s/%T: %v", msg.Method, Notifs(msg.Method), err)
-			}
-			msg.Body = v
-		case ReportErr:
-			msg.Body = msg.Rest // save cause
-		}
-		byid[msg.ID]++
-		msgs = append(msgs, msg)
-	}
-	if err = logrdr.Err(); err != nil {
-		return msgs, err
-	}
-	return msgs, nil
-}
-
-// parse a single log message, given first line, and the rest
-func parselog(first, rest string) (*Logmsg, error) {
-	if strings.HasPrefix(rest, "Params: ") {
-		rest = rest[8:]
-	} else if strings.HasPrefix(rest, "Result: ") {
-		rest = rest[8:]
-	}
-	msg := &Logmsg{Hdr: first, Rest: rest}
-	fixid := func(s string) string {
-		// emacs does (n)., gopls does (n)'.
-		s = strings.Trim(s, "()'.{)")
-		return s
-	}
-	flds := strings.Fields(first)
-	chk := func(s string, n int) bool { return strings.Contains(first, s) && len(flds) == n }
-	// gopls and emacs differ in how they report elapsed time
-	switch {
-	case chk("Sending request", 9):
-		msg.Type = ClRequest
-		msg.Method = flds[6][1:]
-		msg.ID = fixid(flds[8][:len(flds[8])-2])
-	case chk("Received response", 11):
-		msg.Type = ClResponse
-		msg.Method = flds[6][1:]
-		msg.ID = fixid(flds[8])
-		msg.Elapsed = flds[10]
-	case chk("Received request", 9):
-		msg.Type = SvRequest
-		msg.Method = flds[6][1:]
-		msg.ID = fixid(flds[8])
-	case chk("Sending response", 11), // gopls
-		chk("Sending response", 13): // emacs
-		msg.Type = SvResponse
-		msg.Method = flds[6][1:]
-		msg.ID = fixid(flds[8][:len(flds[8])-1])
-		msg.Elapsed = flds[10]
-	case chk("Sending notification", 7):
-		msg.Type = ToServer
-		msg.Method = strings.Trim(flds[6], ".'")
-		if len(flds) == 9 {
-			log.Printf("len=%d method=%s %q", len(flds), msg.Method, first)
-		}
-	case chk("Received notification", 7):
-		msg.Type = ToClient
-		msg.Method = flds[6][1 : len(flds[6])-2]
-	case strings.HasPrefix(first, "[Error - "):
-		msg.Type = ReportErr
-		both := flds[5]
-		idx := strings.Index(both, "#") // relies on ID.Number
-		msg.Method = both[:idx]
-		msg.ID = fixid(both[idx+1:])
-		msg.Rest = strings.Join(flds[6:], " ")
-		msg.Rest = `"` + msg.Rest + `"`
-	default:
-		return nil, fmt.Errorf("surprise, first=%q with %d flds", first, len(flds))
-	}
-	return msg, nil
-}
-
-// unmarshal into a proposed type
-func (l *Logmsg) unmarshal(p interface{}) (interface{}, error) {
-	r := []byte(l.Rest)
-	if err := json.Unmarshal(r, p); err != nil {
-		// need general alternatives, but for now
-		// if p is *[]foo and rest is {}, return an empty p (or *p?)
-		// or, cheat:
-		if l.Rest == "{}" {
-			return nil, nil
-		}
-		return nil, err
-	}
-	return p, nil
-}
-
-func (l *Logmsg) doresponse() (interface{}, error) {
-	for _, x := range Responses(l.Method) {
-		v, err := l.unmarshal(x)
-		if err == nil {
-			return v, nil
-		}
-		if x == nil {
-			return new(interface{}), nil
-		}
-	}
-	// failure!
-	rr := Responses(l.Method)
-	for _, x := range rr {
-		log.Printf("tried %T", x)
-	}
-	log.Fatalf("(%d) doresponse failed for %s %q", len(rr), l.Method, l.Rest)
-	return nil, nil
-}
-
-// be a little forgiving in separating log records
-var recSep = regexp.MustCompile("\n\n\n|\r\n\r\n\r\n")
-
-// return offset of start of next record, contents of record, error
-func scanLogs(b []byte, atEOF bool) (int, []byte, error) { //bufio.SplitFunc
-	got := recSep.FindIndex(b)
-	if got == nil {
-		if atEOF && len(b) > 0 {
-			return 0, nil, errors.New("malformed log: all logs should end with a separator")
-		}
-		return 0, nil, nil
-	}
-	return got[1], b[:got[0]], nil
-}
-
-// String returns a user-useful versin of a Direction
-func (d MsgType) String() string {
-	switch d {
-	case ClRequest:
-		return "clrequest"
-	case ClResponse:
-		return "clresponse"
-	case SvRequest:
-		return "svrequest"
-	case SvResponse:
-		return "svresponse"
-	case ToServer:
-		return "toserver"
-	case ToClient:
-		return "toclient"
-	case ReportErr:
-		return "reporterr"
-	}
-	return fmt.Sprintf("dirname: %d unknown", d)
-}
diff -urN a/gopls/integration/parse/protocol.go b/gopls/integration/parse/protocol.go
--- a/gopls/integration/parse/protocol.go	2000-01-01 00:00:00.000000000 -0000
+++ b/gopls/integration/parse/protocol.go	1969-12-31 19:00:00.000000000 -0500
@@ -1,320 +0,0 @@
-// Copyright 2019 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package parse
-
-import (
-	"log"
-
-	p "golang.org/x/tools/internal/lsp/protocol"
-)
-
-// Requests and notifications are fixed types
-// Responses may be one of several types
-
-// Requests returns a pointer to a type suitable for Unmarshal
-func Requests(m string) interface{} {
-	// these are in the documentation's order
-	switch m {
-	case "initialize":
-		return new(p.InitializeParams)
-	case "shutdown":
-		return new(struct{})
-	case "window/showMessgeRequest":
-		return new(p.ShowMessageRequestParams)
-	case "client/registerCapability":
-		return new(p.RegistrationParams)
-	case "client/unregisterCapability":
-		return new(p.UnregistrationParams)
-	case "workspace/workspaceFolders":
-		return nil
-	case "workspace/configuration":
-		return new(p.ConfigurationParams)
-	case "workspace/symbol":
-		return new(p.WorkspaceSymbolParams)
-	case "workspace/executeCommand":
-		return new(p.ExecuteCommandParams)
-	case "workspace/applyEdit":
-		return new(p.ApplyWorkspaceEditParams)
-	case "textDocument/willSaveWaitUntil":
-		return new(p.WillSaveTextDocumentParams)
-	case "textDocument/completion":
-		return new(p.CompletionParams)
-	case "completionItem/resolve":
-		return new(p.CompletionItem)
-	case "textDocument/hover":
-		return new(p.TextDocumentPositionParams)
-	case "textDocument/signatureHelp":
-		return new(p.TextDocumentPositionParams)
-	case "textDocument/declaration":
-		return new(p.TextDocumentPositionParams)
-	case "textDocument/definition":
-		return new(p.TextDocumentPositionParams)
-	case "textDocument/typeDefinition":
-		return new(p.TextDocumentPositionParams)
-	case "textDocument/implementation":
-		return new(p.TextDocumentPositionParams)
-	case "textDocument/references":
-		return new(p.ReferenceParams)
-	case "textDocument/documentHighlight":
-		return new(p.TextDocumentPositionParams)
-	case "textDocument/documentSymbol":
-		return new(p.DocumentSymbolParams)
-	case "textDocument/codeAction":
-		return new(p.CodeActionParams)
-	case "textDocument/codeLens":
-		return new(p.CodeLensParams)
-	case "codeLens/resolve":
-		return new(p.CodeLens)
-	case "textDocument/documentLink":
-		return new(p.DocumentLinkParams)
-	case "documentLink/resolve":
-		return new(p.DocumentLink)
-	case "textDocument/documentColor":
-		return new(p.DocumentColorParams)
-	case "textDocument/colorPressentation":
-		return new(p.ColorPresentationParams)
-	case "textDocument/formatting":
-		return new(p.DocumentFormattingParams)
-	case "textDocument/rangeFormatting":
-		return new(p.DocumentRangeFormattingParams)
-	case "textDocument/typeFormatting":
-		return new(p.DocumentOnTypeFormattingParams)
-	case "textDocument/rename":
-		return new(p.RenameParams)
-	case "textDocument/prepareRename":
-		return new(p.TextDocumentPositionParams)
-	case "textDocument/foldingRange":
-		return new(p.FoldingRangeParams)
-	case "textDocument/incomingCalls":
-		return new(p.CallHierarchyIncomingCallsParams)
-	case "textDocument/outgoingCalls":
-		return new(p.CallHierarchyOutgoingCallsParams)
-	}
-	log.Fatalf("request(%s) undefined", m)
-	return ""
-}
-
-// Notifs returns a pointer to a type suitable for Unmarshal
-func Notifs(m string) interface{} {
-	switch m {
-	case "$/cancelRequest":
-		return new(p.CancelParams)
-	case "$/setTraceNotification":
-		return new(struct{ Value string })
-	case "client/registerCapability": // why is this a notification? (serer->client rpc)
-		return new(p.RegistrationParams)
-	case "initialized":
-		return new(p.InitializedParams)
-	case "exit":
-		return nil
-	case "window/showMessage":
-		return new(p.ShowMessageParams)
-	case "window/logMessage":
-		return new(p.LogMessageParams)
-	case "telemetry/event":
-		return new(interface{}) // any
-	case "workspace/didChangeWorkspaceFolders":
-		return new(p.DidChangeWorkspaceFoldersParams)
-	case "workspace/didChangeConfiguration":
-		return new(p.DidChangeConfigurationParams)
-	case "workspace/didChangeWatchedFiles":
-		return new(p.DidChangeWatchedFilesParams)
-	case "textDocument/didOpen":
-		return new(p.DidOpenTextDocumentParams)
-	case "textDocument/didChange":
-		return new(p.DidChangeTextDocumentParams)
-	case "textDocument/willSave":
-		return new(p.WillSaveTextDocumentParams)
-	case "textDocument/didSave":
-		return new(p.DidSaveTextDocumentParams)
-	case "textDocument/didClose":
-		return new(p.DidCloseTextDocumentParams)
-	case "textDocument/willClose":
-		return new(p.DidCloseTextDocumentParams)
-	case "textDocument/publishDiagnostics":
-		return new(p.PublishDiagnosticsParams)
-	}
-	log.Fatalf("notif(%s) undefined", m)
-	return ""
-}
-
-// Responses returns a slice of types, one of which should be
-// suitable for Unmarshal
-func Responses(m string) []interface{} {
-	switch m {
-	case "initialize":
-		return []interface{}{new(p.InitializeResult)}
-	case "shutdown":
-		return []interface{}{nil}
-	case "window/showMessageRequest":
-		return []interface{}{new(p.MessageActionItem), nil}
-	case "client/registerCapability":
-		return []interface{}{nil}
-	case "client/unregisterCapability":
-		return []interface{}{nil}
-	case "workspace/workspaceFolder":
-		return []interface{}{new([]p.WorkspaceFolder), nil}
-	case "workspace/configuration":
-		return []interface{}{new([]interface{}), new(interface{})}
-	case "workspace/symbol":
-		return []interface{}{new([]p.SymbolInformation), nil}
-	case "workspace/executeCommand":
-		return []interface{}{new(interface{}), nil}
-	case "workspace/applyEdit":
-		return []interface{}{new(p.ApplyWorkspaceEditResponse)}
-	case "textDocument/willSaveWaitUntil":
-		return []interface{}{new([]p.TextEdit), nil}
-	case "textDocument/completion":
-		return []interface{}{new(p.CompletionList), new([]p.CompletionItem), nil}
-	case "completionItem/resolve":
-		return []interface{}{new(p.CompletionItem)}
-	case "textDocument/hover":
-		return []interface{}{new(p.Hover), nil}
-	case "textDocument/signatureHelp":
-		return []interface{}{new(p.SignatureHelp), nil}
-	case "textDocument/declaration":
-		return []interface{}{new(p.Location), new([]p.Location), new([]p.LocationLink), nil}
-	case "textDocument/definition":
-		return []interface{}{new([]p.Location), new([]p.Location), new([]p.LocationLink), nil}
-	case "textDocument/typeDefinition":
-		return []interface{}{new([]p.Location), new([]p.LocationLink), new(p.Location), nil}
-	case "textDocument/implementation":
-		return []interface{}{new(p.Location), new([]p.Location), new([]p.LocationLink), nil}
-	case "textDocument/references":
-		return []interface{}{new([]p.Location), nil}
-	case "textDocument/documentHighlight":
-		return []interface{}{new([]p.DocumentHighlight), nil}
-	case "textDocument/documentSymbol":
-		return []interface{}{new([]p.DocumentSymbol), new([]p.SymbolInformation), nil}
-	case "textDocument/codeAction":
-		return []interface{}{new([]p.CodeAction), new(p.Command), nil}
-	case "textDocument/codeLens":
-		return []interface{}{new([]p.CodeLens), nil}
-	case "codelens/resolve":
-		return []interface{}{new(p.CodeLens)}
-	case "textDocument/documentLink":
-		return []interface{}{new([]p.DocumentLink), nil}
-	case "documentLink/resolve":
-		return []interface{}{new(p.DocumentLink)}
-	case "textDocument/documentColor":
-		return []interface{}{new([]p.ColorInformation)}
-	case "textDocument/colorPresentation":
-		return []interface{}{new([]p.ColorPresentation)}
-	case "textDocument/formatting":
-		return []interface{}{new([]p.TextEdit), nil}
-	case "textDocument/rangeFormatting":
-		return []interface{}{new([]p.TextEdit), nil}
-	case "textDocument/onTypeFormatting":
-		return []interface{}{new([]p.TextEdit), nil}
-	case "textDocument/rename":
-		return []interface{}{new(p.WorkspaceEdit), nil}
-	case "textDocument/prepareRename":
-		return []interface{}{new(p.Range), nil}
-	case "textDocument/foldingRange":
-		return []interface{}{new([]p.FoldingRange), nil}
-	case "callHierarchy/incomingCalls":
-		return []interface{}{new([]p.CallHierarchyIncomingCall), nil}
-	case "callHierarchy/outgoingCalls":
-		return []interface{}{new([]p.CallHierarchyOutgoingCall), nil}
-	}
-	log.Fatalf("responses(%q) undefined", m)
-	return nil
-}
-
-// Msgtype given method names. Note that mSrv|mCl is possible
-type Msgtype int
-
-const (
-	// Mnot for notifications
-	Mnot Msgtype = 1
-	// Mreq for requests
-	Mreq Msgtype = 2
-	// Msrv for messages from the server
-	Msrv Msgtype = 4
-	// Mcl for messages from the client
-	Mcl Msgtype = 8
-)
-
-// IsNotify says if the message is a notification
-func IsNotify(msg string) bool {
-	m, ok := fromMethod[msg]
-	if !ok {
-		log.Fatalf("%q", msg)
-	}
-	return m&Mnot != 0
-}
-
-// FromServer says if the message is from the server
-func FromServer(msg string) bool {
-	m, ok := fromMethod[msg]
-	if !ok {
-		log.Fatalf("%q", msg)
-	}
-	return m&Msrv != 0
-}
-
-// FromClient says if the message is from the client
-func FromClient(msg string) bool {
-	m, ok := fromMethod[msg]
-	if !ok {
-		log.Fatalf("%q", msg)
-	}
-	return m&Mcl != 0
-}
-
-// rpc name to message type
-var fromMethod = map[string]Msgtype{
-	"$/cancelRequest":             Mnot | Msrv | Mcl,
-	"initialize":                  Mreq | Msrv,
-	"initialized":                 Mnot | Mcl,
-	"shutdown":                    Mreq | Mcl,
-	"exit":                        Mnot | Mcl,
-	"window/showMessage":          Mreq | Msrv,
-	"window/logMessage":           Mnot | Msrv,
-	"telemetry'event":             Mnot | Msrv,
-	"client/registerCapability":   Mreq | Msrv,
-	"client/unregisterCapability": Mreq | Msrv,
-	"workspace/workspaceFolders":  Mreq | Msrv,
-	"workspace/workspaceDidChangeWorkspaceFolders": Mnot | Mcl,
-	"workspace/didChangeConfiguration":             Mnot | Mcl,
-	"workspace/configuration":                      Mreq | Msrv,
-	"workspace/didChangeWatchedFiles":              Mnot | Mcl,
-	"workspace/symbol":                             Mreq | Mcl,
-	"workspace/executeCommand":                     Mreq | Mcl,
-	"workspace/applyEdit":                          Mreq | Msrv,
-	"textDocument/didOpen":                         Mnot | Mcl,
-	"textDocument/didChange":                       Mnot | Mcl,
-	"textDocument/willSave":                        Mnot | Mcl,
-	"textDocument/willSaveWaitUntil":               Mreq | Mcl,
-	"textDocument/didSave":                         Mnot | Mcl,
-	"textDocument/didClose":                        Mnot | Mcl,
-	"textDocument/publishDiagnostics":              Mnot | Msrv,
-	"textDocument/completion":                      Mreq | Mcl,
-	"completionItem/resolve":                       Mreq | Mcl,
-	"textDocument/hover":                           Mreq | Mcl,
-	"textDocument/signatureHelp":                   Mreq | Mcl,
-	"textDocument/declaration":                     Mreq | Mcl,
-	"textDocument/definition":                      Mreq | Mcl,
-	"textDocument/typeDefinition":                  Mreq | Mcl,
-	"textDocument/implementation":                  Mreq | Mcl,
-	"textDocument/references":                      Mreq | Mcl,
-	"textDocument/documentHighlight":               Mreq | Mcl,
-	"textDocument/documentSymbol":                  Mreq | Mcl,
-	"textDocument/codeAction":                      Mreq | Mcl,
-	"textDocument/codeLens":                        Mreq | Mcl,
-	"codeLens/resolve":                             Mreq | Mcl,
-	"textDocument/documentLink":                    Mreq | Mcl,
-	"documentLink/resolve":                         Mreq | Mcl,
-	"textDocument/documentColor":                   Mreq | Mcl,
-	"textDocument/colorPresentation":               Mreq | Mcl,
-	"textDocument/formatting":                      Mreq | Mcl,
-	"textDocument/rangeFormatting":                 Mreq | Mcl,
-	"textDocument/onTypeFormatting":                Mreq | Mcl,
-	"textDocument/rename":                          Mreq | Mcl,
-	"textDocument/prepareRename":                   Mreq | Mcl,
-	"textDocument/foldingRange":                    Mreq | Mcl,
-	"callHierarchy/incomingCalls":                  Mreq | Mcl,
-	"callHierarchy/outgoingCalls":                  Mreq | Mcl,
-}
diff -urN a/gopls/integration/parse/rlog.go b/gopls/integration/parse/rlog.go
--- a/gopls/integration/parse/rlog.go	2000-01-01 00:00:00.000000000 -0000
+++ b/gopls/integration/parse/rlog.go	1969-12-31 19:00:00.000000000 -0500
@@ -1,126 +0,0 @@
-// Copyright 2019 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package parse
-
-import (
-	"fmt"
-	"log"
-	"strings"
-)
-
-// Rlog contains the processed logs
-type Rlog struct {
-	Logs         []*Logmsg          // In the order in the log file
-	ServerCall   map[string]*Logmsg // ID->Request, client->server
-	ServerReply  map[string]*Logmsg // ID->Response, server->client (includes Errors)
-	ClientCall   map[string]*Logmsg
-	ClientReply  map[string]*Logmsg
-	ClientNotifs []*Logmsg
-	ServerNotifs []*Logmsg
-	Histogram    *LogHist
-}
-
-func newRlog(x []*Logmsg) *Rlog {
-	return &Rlog{Logs: x,
-		ServerCall:   make(map[string]*Logmsg),
-		ServerReply:  make(map[string]*Logmsg),
-		ClientCall:   make(map[string]*Logmsg),
-		ClientReply:  make(map[string]*Logmsg),
-		ClientNotifs: []*Logmsg{},
-		ServerNotifs: []*Logmsg{},
-		Histogram:    &LogHist{},
-	}
-}
-
-// Counts returns a one-line summary of an Rlog
-func (r *Rlog) Counts() string {
-	return fmt.Sprintf("logs:%d srvC:%d srvR:%d clC:%d clR:%d clN:%d srvN:%d",
-		len(r.Logs),
-		len(r.ServerCall), len(r.ServerReply), len(r.ClientCall), len(r.ClientReply),
-		len(r.ClientNotifs), len(r.ServerNotifs))
-}
-
-// ToRlog reads a log file and returns a *Rlog
-func ToRlog(fname string) (*Rlog, error) {
-	x, err := ReadLogs(fname)
-	if err != nil {
-		return nil, err
-	}
-	ans := newRlog(x)
-	for _, l := range x {
-		switch l.Type {
-		case ClRequest:
-			ans.ServerCall[l.ID] = l
-		case ClResponse:
-			ans.ServerReply[l.ID] = l
-			if l.Type != ReportErr {
-				n := 0
-				fmt.Sscanf(l.Elapsed, "%d", &n)
-				ans.Histogram.add(n)
-			}
-		case SvRequest:
-			ans.ClientCall[l.ID] = l
-		case SvResponse:
-			ans.ClientReply[l.ID] = l
-		case ToClient:
-			ans.ClientNotifs = append(ans.ClientNotifs, l)
-		case ToServer:
-			ans.ServerNotifs = append(ans.ServerNotifs, l)
-		case ReportErr:
-			ans.ServerReply[l.ID] = l
-			l.Method = ans.ServerCall[l.ID].Method // Method not in log message
-		default:
-			log.Fatalf("eh? %s/%s (%s)", l.Type, l.Method, l.ID)
-		}
-	}
-	return ans, nil
-}
-
-// LogHist gets ints, and puts them into buckets:
-// <=10, <=30, 100, 300, 1000, ...
-// It produces a historgram of elapsed times in milliseconds
-type LogHist struct {
-	cnts []int
-}
-
-func (l *LogHist) add(n int) {
-	if n < 0 {
-		n = 0
-	}
-	bucket := 0
-	for ; n > 0; n /= 10 {
-		if n < 10 {
-			break
-		}
-		if n < 30 {
-			bucket++
-			break
-		}
-		bucket += 2
-	}
-	if len(l.cnts) <= bucket {
-		for j := len(l.cnts); j < bucket+10; j++ {
-			l.cnts = append(l.cnts, 0)
-		}
-	}
-	l.cnts[bucket]++
-}
-
-// String returns a string describing a histogram
-func (l *LogHist) String() string {
-	top := len(l.cnts) - 1
-	for ; top > 0 && l.cnts[top] == 0; top-- {
-	}
-	labs := []string{"10", "30"}
-	out := strings.Builder{}
-	out.WriteByte('[')
-	for i := 0; i <= top; i++ {
-		label := labs[i%2]
-		labs[i%2] += "0"
-		fmt.Fprintf(&out, "%s:%d ", label, l.cnts[i])
-	}
-	out.WriteByte(']')
-	return out.String()
-}
diff -urN a/gopls/integration/replay/README.md b/gopls/integration/replay/README.md
--- a/gopls/integration/replay/README.md	2000-01-01 00:00:00.000000000 -0000
+++ b/gopls/integration/replay/README.md	1969-12-31 19:00:00.000000000 -0500
@@ -1,79 +0,0 @@
-# Replaying Logs
-
-The LSP log replayer takes a log from a gopls session, starts up an instance of gopls,
-and tries to replay the session. It produces a log from the replayed session and reports
-some comparative statistics of the two logs.
-
-```replay -log <logfile>```
-
-The `logfile` should be the log produced by gopls. It will have a name like
-`/tmp/gopls-89775` or, on a Mac, `$TMPDIR/gopls-29388`.
-
-If `replay` cannot find a copy of gopls to execute, use `-cmd <path to gopls>`.
-It looks in the same places where `go install` would put its output,
-namely `$GOBIN/gopls`, `$GOPATH/bin/gopls`, `$HOME/go/bin/gopls`.
-
-The log for the replayed session is saved in `/tmp/seen`.
-
-There is also a boolean argument `-cmp` which compares the log file
-with `/tmp/seen` without invoking gopls and rerunning the session.
-
-The output is fairly cryptic, and generated by logging. Ideas for better output would be welcome.
-Here's an example, with intermingled comments:
-
-```
-main.go:50: old 1856, hist:[10:177 30:1 100:0 300:3 1000:4 ]
-```
-This says that the original log had 1856 records in it. The histogram is
-counting how long RPCs took, in milliseconds. In this case 177 took no more
-than 10ms, and 4 took between 300ms and 1000ms.
-```
-main.go:53: calling mimic
-main.go:293: mimic 1856
-```
-This is a reminder that it's replaying in a new session, with a log file
-containing 1856 records
-```
-main.go:61: new 1846, hist:[10:181 30:1 100:1 300:1 1000:1 ]
-```
-The new session produced 1846 log records (that's 10 fewer),
-and a vaguely similar histogram.
-```
-main.go:96: old: clrequest:578 clresponse:185 svrequest:2 svresponse:2 toserver:244 toclient:460 reporterr:385
-main.go:96: new: clrequest:571 clresponse:185 svrequest:2 svresponse:2 toserver:241 toclient:460 reporterr:385
-```
-The first line is for the original log, the second for the new log. The new log has 7 fewer RPC requests
-from the client *clrequest* (578 vs 571), the same number of client responses *clresponse*, 3 fewer
-notifications *toserver* from the client, the same number from the server *toclient* to the client, and
-the same number of errors *reporterr*. (That's mysterious, but a look at the ends of the log files shows
-that the original session ended with several RPCs that don't show up, for whatever reason, in the new session.)
-
-Finally, there are counts of the various notifications seen, in the new log and the old log, and
-which direction they went. (The 3 fewer notifications in the summary above can be seen here to be from cancels
-and a didChange.)
-```
-main.go:107: counts of notifications
-main.go:110:  '$/cancelRequest'. new toserver 1
-main.go:110:  '$/cancelRequest'. old toserver 3
-main.go:110:  'initialized'. new toserver 1
-main.go:110:  'initialized'. old toserver 1
-main.go:110:  'textDocument/didChange'. new toserver 231
-main.go:110:  'textDocument/didChange'. old toserver 232
-main.go:110:  'textDocument/didOpen'. new toserver 1
-main.go:110:  'textDocument/didOpen'. old toserver 1
-main.go:110:  'textDocument/didSave'. new toserver 7
-main.go:110:  'textDocument/didSave'. old toserver 7
-main.go:110:  'textDocument/publishDiagnostics'. new toclient 182
-main.go:110:  'textDocument/publishDiagnostics'. old toclient 182
-main.go:110:  'window/logMessage'. new toclient 278
-main.go:110:  'window/logMessage'. old toclient 278
-```
-### Caveats
-Replay cannot restore the exact environment gopls saw for the original session.
-For instance, the first didOpen message in the new session will see the file
-as it was left by the original session.
-
-Gopls invokes various tools, and the environment they see could have changed too.
-
-Replay will use the gopls it finds (or is given). It has no way of using
-the same version that created the original session.
diff -urN a/gopls/integration/replay/main.go b/gopls/integration/replay/main.go
--- a/gopls/integration/replay/main.go	2000-01-01 00:00:00.000000000 -0000
+++ b/gopls/integration/replay/main.go	1969-12-31 19:00:00.000000000 -0500
@@ -1,292 +0,0 @@
-// Copyright 2019 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// Replay logs. See README.md
-package main
-
-import (
-	"bufio"
-	"context"
-	"flag"
-	"fmt"
-	"log"
-	"os"
-	"os/exec"
-	"sort"
-	"strconv"
-	"strings"
-
-	"golang.org/x/tools/gopls/integration/parse"
-	"golang.org/x/tools/internal/fakenet"
-	"golang.org/x/tools/internal/jsonrpc2"
-	p "golang.org/x/tools/internal/lsp/protocol"
-)
-
-var (
-	command = flag.String("cmd", "", "location of server to send to, looks for gopls")
-	cmp     = flag.Bool("cmp", false, "only compare log and /tmp/seen")
-	logrdr  *bufio.Scanner
-	msgs    []*parse.Logmsg
-	// requests and responses/errors, by id
-	clreq  = make(map[string]*parse.Logmsg)
-	clresp = make(map[string]*parse.Logmsg)
-	svreq  = make(map[string]*parse.Logmsg)
-	svresp = make(map[string]*parse.Logmsg)
-)
-
-func main() {
-	log.SetFlags(log.Lshortfile)
-	flag.Usage = func() {
-		fmt.Fprintln(flag.CommandLine.Output(), "replay [options] <logfile>")
-		flag.PrintDefaults()
-	}
-	flag.Parse()
-	if flag.NArg() != 1 {
-		flag.Usage()
-		os.Exit(2)
-	}
-	logf := flag.Arg(0)
-
-	orig, err := parse.ToRlog(logf)
-	if err != nil {
-		log.Fatalf("error parsing logfile %q: %v", logf, err)
-	}
-	ctx := context.Background()
-	msgs = orig.Logs
-	log.Printf("old %d, hist:%s", len(msgs), orig.Histogram)
-
-	if !*cmp {
-		log.Print("calling mimic")
-		mimic(ctx)
-	}
-	seen, err := parse.ToRlog("/tmp/seen")
-	if err != nil {
-		log.Fatal(err)
-	}
-	newMsgs := seen.Logs
-	log.Printf("new %d, hist:%s", len(newMsgs), seen.Histogram)
-
-	ok := make(map[string]int)
-	f := func(x []*parse.Logmsg, label string, diags map[p.DocumentURI][]p.Diagnostic) {
-		counts := make(map[parse.MsgType]int)
-		for _, l := range x {
-			if l.Method == "window/logMessage" {
-				// don't care
-				//continue
-			}
-			if l.Method == "textDocument/publishDiagnostics" {
-				v, ok := l.Body.(*p.PublishDiagnosticsParams)
-				if !ok {
-					log.Fatalf("got %T expected PublishDiagnosticsParams", l.Body)
-				}
-				diags[v.URI] = v.Diagnostics
-			}
-			counts[l.Type]++
-			// notifications only
-			if l.Type != parse.ToServer && l.Type != parse.ToClient {
-				continue
-			}
-			s := fmt.Sprintf("%s %s %s", strings.Replace(l.Hdr, "\r", "", -1), label, l.Type)
-			if i := strings.Index(s, "notification"); i != -1 {
-				s = s[i+12:]
-			}
-			if len(s) > 120 {
-				s = s[:120]
-			}
-			ok[s]++
-		}
-		msg := ""
-		for i := parse.ClRequest; i <= parse.ReportErr; i++ {
-			msg += fmt.Sprintf("%s:%d ", i, counts[i])
-		}
-		log.Printf("%s: %s", label, msg)
-	}
-	mdiags := make(map[p.DocumentURI][]p.Diagnostic)
-	f(msgs, "old", mdiags)
-	vdiags := make(map[p.DocumentURI][]p.Diagnostic)
-	f(newMsgs, "new", vdiags)
-	buf := []string{}
-	for k := range ok {
-		buf = append(buf, fmt.Sprintf("%s %d", k, ok[k]))
-	}
-	if len(buf) > 0 {
-		log.Printf("counts of notifications")
-		sort.Strings(buf)
-		for _, k := range buf {
-			log.Print(k)
-		}
-	}
-	buf = buf[0:0]
-	for k, v := range mdiags {
-		va := vdiags[k]
-		if len(v) != len(va) {
-			buf = append(buf, fmt.Sprintf("new has %d, old has %d for %s",
-				len(va), len(v), k))
-		}
-	}
-	for ka := range vdiags {
-		if _, ok := mdiags[ka]; !ok {
-			buf = append(buf, fmt.Sprintf("new diagnostics, but no old ones, for %s",
-				ka))
-		}
-	}
-	if len(buf) > 0 {
-		log.Print("diagnostics differ:")
-		for _, s := range buf {
-			log.Print(s)
-		}
-	}
-}
-
-func send(ctx context.Context, l *parse.Logmsg, stream jsonrpc2.Stream, id *jsonrpc2.ID) {
-	if id == nil {
-		// need to use the number version of ID
-		n, err := strconv.Atoi(l.ID)
-		if err != nil {
-			n = 0
-		}
-		nid := jsonrpc2.NewIntID(int64(n))
-		id = &nid
-	}
-	var msg jsonrpc2.Message
-	var err error
-	switch l.Type {
-	case parse.ClRequest:
-		msg, err = jsonrpc2.NewCall(*id, l.Method, l.Body)
-	case parse.SvResponse:
-		msg, err = jsonrpc2.NewResponse(*id, l.Body, nil)
-	case parse.ToServer:
-		msg, err = jsonrpc2.NewNotification(l.Method, l.Body)
-	default:
-		log.Fatalf("sending %s", l.Type)
-	}
-	if err != nil {
-		log.Fatal(err)
-	}
-	stream.Write(ctx, msg)
-}
-
-func respond(ctx context.Context, c *jsonrpc2.Call, stream jsonrpc2.Stream) {
-	// c is a server request
-	// pick out the id, and look for the response in msgs
-	id := c.ID()
-	idstr := fmt.Sprint(id)
-	for _, l := range msgs {
-		if l.ID == idstr && l.Type == parse.SvResponse {
-			// check that the methods match?
-			// need to send back the same ID we got.
-			send(ctx, l, stream, &id)
-			return
-		}
-	}
-	log.Fatalf("no response found %q %+v %+v", c.Method(), c.ID(), c)
-}
-
-func findgopls() string {
-	totry := [][]string{{"GOBIN", "/gopls"}, {"GOPATH", "/bin/gopls"}, {"HOME", "/go/bin/gopls"}}
-	// looks in the places go install would install:
-	// GOBIN, else GOPATH/bin, else HOME/go/bin
-	ok := func(s string) bool {
-		fd, err := os.Open(s)
-		if err != nil {
-			return false
-		}
-		fi, err := fd.Stat()
-		if err != nil {
-			return false
-		}
-		return fi.Mode()&0111 != 0
-	}
-	for _, t := range totry {
-		g := os.Getenv(t[0])
-		if g != "" && ok(g+t[1]) {
-			gopls := g + t[1]
-			log.Printf("using gopls at %s", gopls)
-			return gopls
-		}
-	}
-	log.Fatal("could not find gopls")
-	return ""
-}
-
-func mimic(ctx context.Context) {
-	log.Printf("mimic %d", len(msgs))
-	if *command == "" {
-		*command = findgopls()
-	}
-	cmd := exec.Command(*command, "-logfile", "/tmp/seen", "-rpc.trace")
-	toServer, err := cmd.StdinPipe()
-	if err != nil {
-		log.Fatal(err)
-	}
-	fromServer, err := cmd.StdoutPipe()
-	if err != nil {
-		log.Fatal(err)
-	}
-	err = cmd.Start()
-	if err != nil {
-		log.Fatal(err)
-	}
-	conn := fakenet.NewConn("stdio", fromServer, toServer)
-	stream := jsonrpc2.NewHeaderStream(conn)
-	rchan := make(chan jsonrpc2.Message, 10) // do we need buffering?
-	rdr := func() {
-		for {
-			msg, _, err := stream.Read(ctx)
-			if err != nil {
-				rchan <- nil // close it instead?
-				return
-			}
-			rchan <- msg
-		}
-	}
-	go rdr()
-	// send as many as possible: all clrequests and toservers up to a clresponse
-	// and loop
-	seenids := make(map[string]bool) // id's that have been responded to:
-big:
-	for _, l := range msgs {
-		switch l.Type {
-		case parse.ToServer: // just send these as we get to them
-			send(ctx, l, stream, nil)
-		case parse.ClRequest:
-			send(ctx, l, stream, nil) // for now, wait for a response, to make sure code is ok
-			fallthrough
-		case parse.ClResponse, parse.ReportErr: // don't go past these until they're received
-			if seenids[l.ID] {
-				break // onward, as it has been received already
-			}
-		done:
-			for {
-				msg := <-rchan
-				if msg == nil {
-					break big
-				}
-				// if it's svrequest, do something
-				// if it's clresponse or reporterr, add to seenids, and if it
-				// is l.id, break out of the loop, and continue the outer loop
-
-				switch msg := msg.(type) {
-				case *jsonrpc2.Call:
-					if parse.FromServer(msg.Method()) {
-						respond(ctx, msg, stream)
-						continue done // still waiting
-					}
-				case *jsonrpc2.Response:
-					id := fmt.Sprint(msg.ID())
-					seenids[id] = true
-					if id == l.ID {
-						break done
-					}
-				}
-			}
-		case parse.SvRequest: // not ours to send
-			continue
-		case parse.SvResponse: // sent by us, if the request arrives
-			continue
-		case parse.ToClient: // we don't send these
-			continue
-		}
-	}
-}
diff -urN a/gopls/internal/hooks/analysis.go b/gopls/internal/hooks/analysis.go
--- a/gopls/internal/hooks/analysis.go	2000-01-01 00:00:00.000000000 -0000
+++ b/gopls/internal/hooks/analysis.go	1969-12-31 19:00:00.000000000 -0500
@@ -1,39 +0,0 @@
-// Copyright 2019 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package hooks
-
-import (
-	"golang.org/x/tools/go/analysis"
-	"golang.org/x/tools/internal/lsp/source"
-	"honnef.co/go/tools/simple"
-	"honnef.co/go/tools/staticcheck"
-	"honnef.co/go/tools/stylecheck"
-)
-
-func updateAnalyzers(options *source.Options) {
-	var analyzers []*analysis.Analyzer
-	for _, a := range simple.Analyzers {
-		analyzers = append(analyzers, a)
-	}
-	for _, a := range staticcheck.Analyzers {
-		switch a.Name {
-		case "SA5009":
-			// This check conflicts with the vet printf check (golang/go#34494).
-		case "SA5011":
-			// This check relies on facts from dependencies, which
-			// we don't currently compute.
-		default:
-			analyzers = append(analyzers, a)
-		}
-	}
-	for _, a := range stylecheck.Analyzers {
-		analyzers = append(analyzers, a)
-	}
-	// Always add hooks for all available analyzers, but disable them if the
-	// user does not have staticcheck enabled (they may enable it later on).
-	for _, a := range analyzers {
-		options.AddStaticcheckAnalyzer(a)
-	}
-}
diff -urN a/gopls/internal/hooks/diff.go b/gopls/internal/hooks/diff.go
--- a/gopls/internal/hooks/diff.go	2000-01-01 00:00:00.000000000 -0000
+++ b/gopls/internal/hooks/diff.go	1969-12-31 19:00:00.000000000 -0500
@@ -1,30 +0,0 @@
-// Copyright 2019 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package hooks
-
-import (
-	"github.com/sergi/go-diff/diffmatchpatch"
-	"golang.org/x/tools/internal/lsp/diff"
-	"golang.org/x/tools/internal/span"
-)
-
-func ComputeEdits(uri span.URI, before, after string) []diff.TextEdit {
-	diffs := diffmatchpatch.New().DiffMain(before, after, true)
-	edits := make([]diff.TextEdit, 0, len(diffs))
-	offset := 0
-	for _, d := range diffs {
-		start := span.NewPoint(0, 0, offset)
-		switch d.Type {
-		case diffmatchpatch.DiffDelete:
-			offset += len(d.Text)
-			edits = append(edits, diff.TextEdit{Span: span.New(uri, start, span.NewPoint(0, 0, offset))})
-		case diffmatchpatch.DiffEqual:
-			offset += len(d.Text)
-		case diffmatchpatch.DiffInsert:
-			edits = append(edits, diff.TextEdit{Span: span.New(uri, start, span.Point{}), NewText: d.Text})
-		}
-	}
-	return edits
-}
diff -urN a/gopls/internal/hooks/diff_test.go b/gopls/internal/hooks/diff_test.go
--- a/gopls/internal/hooks/diff_test.go	2000-01-01 00:00:00.000000000 -0000
+++ b/gopls/internal/hooks/diff_test.go	1969-12-31 19:00:00.000000000 -0500
@@ -1,16 +0,0 @@
-// Copyright 2019 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package hooks_test
-
-import (
-	"testing"
-
-	"golang.org/x/tools/gopls/internal/hooks"
-	"golang.org/x/tools/internal/lsp/diff/difftest"
-)
-
-func TestDiff(t *testing.T) {
-	difftest.DiffTest(t, hooks.ComputeEdits)
-}
diff -urN a/gopls/internal/hooks/hooks.go b/gopls/internal/hooks/hooks.go
--- a/gopls/internal/hooks/hooks.go	2000-01-01 00:00:00.000000000 -0000
+++ b/gopls/internal/hooks/hooks.go	1969-12-31 19:00:00.000000000 -0500
@@ -1,35 +0,0 @@
-// Copyright 2019 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// Package hooks adds all the standard gopls implementations.
-// This can be used in tests without needing to use the gopls main, and is
-// also the place to edit for custom builds of gopls.
-package hooks // import "golang.org/x/tools/gopls/internal/hooks"
-
-import (
-	"context"
-	"regexp"
-
-	"golang.org/x/tools/internal/lsp/source"
-	"mvdan.cc/gofumpt/format"
-	"mvdan.cc/xurls/v2"
-)
-
-func Options(options *source.Options) {
-	if options.GoDiff {
-		options.ComputeEdits = ComputeEdits
-	}
-	options.URLRegexp = urlRegexp()
-	options.GofumptFormat = func(ctx context.Context, src []byte) ([]byte, error) {
-		return format.Source(src, format.Options{})
-	}
-	updateAnalyzers(options)
-}
-
-func urlRegexp() *regexp.Regexp {
-	// Ensure links are matched as full words, not anywhere.
-	re := regexp.MustCompile(`\b(` + xurls.Relaxed().String() + `)\b`)
-	re.Longest()
-	return re
-}
diff -urN a/gopls/internal/regtest/bench_test.go b/gopls/internal/regtest/bench_test.go
--- a/gopls/internal/regtest/bench_test.go	2000-01-01 00:00:00.000000000 -0000
+++ b/gopls/internal/regtest/bench_test.go	1969-12-31 19:00:00.000000000 -0500
@@ -1,104 +0,0 @@
-// Copyright 2020 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package regtest
-
-import (
-	"flag"
-	"fmt"
-	"testing"
-
-	"golang.org/x/tools/internal/lsp/protocol"
-)
-
-func printBenchmarkResults(result testing.BenchmarkResult) {
-	fmt.Println("Benchmark Statistics:")
-	fmt.Println(result.String())
-	fmt.Println(result.MemString())
-}
-
-var iwlOptions struct {
-	workdir string
-}
-
-func init() {
-	flag.StringVar(&iwlOptions.workdir, "iwl_workdir", "", "if set, run IWL benchmark in this directory")
-}
-
-func TestBenchmarkIWL(t *testing.T) {
-	if iwlOptions.workdir == "" {
-		t.Skip("-iwl_workdir not configured")
-	}
-
-	opts := stressTestOptions(iwlOptions.workdir)
-	// Don't skip hooks, so that we can wait for IWL.
-	opts = append(opts, SkipHooks(false))
-
-	results := testing.Benchmark(func(b *testing.B) {
-		for i := 0; i < b.N; i++ {
-			withOptions(opts...).run(t, "", func(t *testing.T, env *Env) {})
-		}
-	})
-
-	printBenchmarkResults(results)
-}
-
-var symbolOptions struct {
-	workdir, query, matcher, style string
-	printResults                   bool
-}
-
-func init() {
-	flag.StringVar(&symbolOptions.workdir, "symbol_workdir", "", "if set, run symbol benchmark in this directory")
-	flag.StringVar(&symbolOptions.query, "symbol_query", "test", "symbol query to use in benchmark")
-	flag.StringVar(&symbolOptions.matcher, "symbol_matcher", "", "symbol matcher to use in benchmark")
-	flag.StringVar(&symbolOptions.style, "symbol_style", "", "symbol style to use in benchmark")
-	flag.BoolVar(&symbolOptions.printResults, "symbol_print_results", false, "whether to print symbol query results")
-}
-
-func TestBenchmarkSymbols(t *testing.T) {
-	if symbolOptions.workdir == "" {
-		t.Skip("-symbol_workdir not configured")
-	}
-
-	opts := stressTestOptions(symbolOptions.workdir)
-	conf := EditorConfig{}
-	if symbolOptions.matcher != "" {
-		conf.SymbolMatcher = &symbolOptions.matcher
-	}
-	if symbolOptions.style != "" {
-		conf.SymbolStyle = &symbolOptions.style
-	}
-	opts = append(opts, conf)
-
-	withOptions(opts...).run(t, "", func(t *testing.T, env *Env) {
-		// We can't Await in this test, since we have disabled hooks. Instead, run
-		// one symbol request to completion to ensure all necessary cache entries
-		// are populated.
-		symbols, err := env.Editor.Server.Symbol(env.Ctx, &protocol.WorkspaceSymbolParams{
-			Query: symbolOptions.query,
-		})
-		if err != nil {
-			t.Fatal(err)
-		}
-
-		if symbolOptions.printResults {
-			fmt.Println("Results:")
-			for i := 0; i < len(symbols); i++ {
-				fmt.Printf("\t%d. %s (%s)\n", i, symbols[i].Name, symbols[i].ContainerName)
-			}
-		}
-
-		results := testing.Benchmark(func(b *testing.B) {
-			for i := 0; i < b.N; i++ {
-				if _, err := env.Editor.Server.Symbol(env.Ctx, &protocol.WorkspaceSymbolParams{
-					Query: symbolOptions.query,
-				}); err != nil {
-					t.Fatal(err)
-				}
-			}
-		})
-		printBenchmarkResults(results)
-	})
-}
diff -urN a/gopls/internal/regtest/codelens_test.go b/gopls/internal/regtest/codelens_test.go
--- a/gopls/internal/regtest/codelens_test.go	2000-01-01 00:00:00.000000000 -0000
+++ b/gopls/internal/regtest/codelens_test.go	1969-12-31 19:00:00.000000000 -0500
@@ -1,285 +0,0 @@
-// Copyright 2020 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package regtest
-
-import (
-	"runtime"
-	"strings"
-	"testing"
-
-	"golang.org/x/tools/internal/lsp"
-	"golang.org/x/tools/internal/lsp/fake"
-	"golang.org/x/tools/internal/lsp/protocol"
-	"golang.org/x/tools/internal/lsp/source"
-	"golang.org/x/tools/internal/lsp/tests"
-	"golang.org/x/tools/internal/testenv"
-)
-
-func TestDisablingCodeLens(t *testing.T) {
-	const workspace = `
--- go.mod --
-module codelens.test
--- lib.go --
-package lib
-
-type Number int
-
-const (
-	Zero Number = iota
-	One
-	Two
-)
-
-//go:generate stringer -type=Number
-`
-	tests := []struct {
-		label        string
-		enabled      map[string]bool
-		wantCodeLens bool
-	}{
-		{
-			label:        "default",
-			wantCodeLens: true,
-		},
-		{
-			label:        "generate disabled",
-			enabled:      map[string]bool{source.CommandGenerate.Name: false},
-			wantCodeLens: false,
-		},
-	}
-	for _, test := range tests {
-		t.Run(test.label, func(t *testing.T) {
-			withOptions(
-				EditorConfig{
-					CodeLenses: test.enabled,
-				},
-			).run(t, workspace, func(t *testing.T, env *Env) {
-				env.OpenFile("lib.go")
-				lens := env.CodeLens("lib.go")
-				if gotCodeLens := len(lens) > 0; gotCodeLens != test.wantCodeLens {
-					t.Errorf("got codeLens: %t, want %t", gotCodeLens, test.wantCodeLens)
-				}
-			})
-		})
-	}
-}
-
-// This test confirms the full functionality of the code lenses for updating
-// dependencies in a go.mod file. It checks for the code lens that suggests
-// an update and then executes the command associated with that code lens. A
-// regression test for golang/go#39446.
-func TestUpdateCodelens(t *testing.T) {
-	const proxyWithLatest = `
--- golang.org/x/hello@v1.3.3/go.mod --
-module golang.org/x/hello
-
-go 1.12
--- golang.org/x/hello@v1.3.3/hi/hi.go --
-package hi
-
-var Goodbye error
-	-- golang.org/x/hello@v1.2.3/go.mod --
-module golang.org/x/hello
-
-go 1.12
--- golang.org/x/hello@v1.2.3/hi/hi.go --
-package hi
-
-var Goodbye error
-`
-
-	const shouldUpdateDep = `
--- go.mod --
-module mod.com
-
-go 1.12
-
-require golang.org/x/hello v1.2.3
--- go.sum --
-golang.org/x/hello v1.2.3 h1:jOtNXLsiCuLzU6KM3wRHidpc29IxcKpofHZiOW1hYKA=
-golang.org/x/hello v1.2.3/go.mod h1:X79D30QqR94cGK8aIhQNhCZLq4mIr5Gimj5qekF08rY=
--- main.go --
-package main
-
-import "golang.org/x/hello/hi"
-
-func main() {
-	_ = hi.Goodbye
-}
-`
-	runner.Run(t, shouldUpdateDep, func(t *testing.T, env *Env) {
-		env.OpenFile("go.mod")
-		env.ExecuteCodeLensCommand("go.mod", source.CommandUpgradeDependency)
-		env.Await(CompletedWork(lsp.DiagnosticWorkTitle(lsp.FromDidChangeWatchedFiles), 1))
-		got := env.Editor.BufferText("go.mod")
-		const wantGoMod = `module mod.com
-
-go 1.12
-
-require golang.org/x/hello v1.3.3
-`
-		if got != wantGoMod {
-			t.Fatalf("go.mod upgrade failed:\n%s", tests.Diff(wantGoMod, got))
-		}
-	}, WithProxyFiles(proxyWithLatest))
-}
-
-func TestUnusedDependenciesCodelens(t *testing.T) {
-	testenv.NeedsGo1Point(t, 14)
-	const proxy = `
--- golang.org/x/hello@v1.0.0/go.mod --
-module golang.org/x/hello
-
-go 1.14
--- golang.org/x/hello@v1.0.0/hi/hi.go --
-package hi
-
-var Goodbye error
--- golang.org/x/unused@v1.0.0/go.mod --
-module golang.org/x/unused
-
-go 1.14
--- golang.org/x/unused@v1.0.0/nouse/nouse.go --
-package nouse
-
-var NotUsed error
-`
-
-	const shouldRemoveDep = `
--- go.mod --
-module mod.com
-
-go 1.14
-
-require golang.org/x/hello v1.0.0
-require golang.org/x/unused v1.0.0
--- main.go --
-package main
-
-import "golang.org/x/hello/hi"
-
-func main() {
-	_ = hi.Goodbye
-}
-`
-	runner.Run(t, shouldRemoveDep, func(t *testing.T, env *Env) {
-		env.OpenFile("go.mod")
-		env.ExecuteCodeLensCommand("go.mod", source.CommandTidy)
-		env.Await(CompletedWork(lsp.DiagnosticWorkTitle(lsp.FromDidChangeWatchedFiles), 1))
-		got := env.Editor.BufferText("go.mod")
-		const wantGoMod = `module mod.com
-
-go 1.14
-
-require golang.org/x/hello v1.0.0
-`
-		if got != wantGoMod {
-			t.Fatalf("go.mod tidy failed:\n%s", tests.Diff(wantGoMod, got))
-		}
-	}, WithProxyFiles(proxy))
-}
-
-func TestRegenerateCgo(t *testing.T) {
-	testenv.NeedsTool(t, "cgo")
-	testenv.NeedsGo1Point(t, 15)
-
-	const workspace = `
--- go.mod --
-module example.com
--- cgo.go --
-package x
-
-/*
-int fortythree() { return 42; }
-*/
-import "C"
-
-func Foo() {
-	print(C.fortytwo())
-}
-`
-	runner.Run(t, workspace, func(t *testing.T, env *Env) {
-		// Open the file. We should have a nonexistant symbol.
-		env.OpenFile("cgo.go")
-		env.Await(env.DiagnosticAtRegexp("cgo.go", `C\.(fortytwo)`)) // could not determine kind of name for C.fortytwo
-
-		// Fix the C function name. We haven't regenerated cgo, so nothing should be fixed.
-		env.RegexpReplace("cgo.go", `int fortythree`, "int fortytwo")
-		env.SaveBuffer("cgo.go")
-		env.Await(env.DiagnosticAtRegexp("cgo.go", `C\.(fortytwo)`))
-
-		// Regenerate cgo, fixing the diagnostic.
-		env.ExecuteCodeLensCommand("cgo.go", source.CommandRegenerateCgo)
-		env.Await(EmptyDiagnostics("cgo.go"))
-	})
-}
-
-func TestGCDetails(t *testing.T) {
-	testenv.NeedsGo1Point(t, 15)
-	if runtime.GOOS == "android" {
-		t.Skipf("the gc details code lens doesn't work on Android")
-	}
-
-	const mod = `
--- go.mod --
-module mod.com
-
-go 1.15
--- main.go --
-package main
-
-import "fmt"
-
-func main() {
-	var x string
-	fmt.Println(x)
-}
-`
-	withOptions(
-		EditorConfig{
-			CodeLenses: map[string]bool{
-				"gc_details": true,
-			}},
-	).run(t, mod, func(t *testing.T, env *Env) {
-		env.OpenFile("main.go")
-		env.ExecuteCodeLensCommand("main.go", source.CommandToggleDetails)
-		d := &protocol.PublishDiagnosticsParams{}
-		env.Await(
-			OnceMet(
-				DiagnosticAt("main.go", 6, 12),
-				ReadDiagnostics("main.go", d),
-			),
-		)
-		// Confirm that the diagnostics come from the gc details code lens.
-		var found bool
-		for _, d := range d.Diagnostics {
-			if d.Severity != protocol.SeverityInformation {
-				t.Fatalf("unexpected diagnostic severity %v, wanted Information", d.Severity)
-			}
-			if strings.Contains(d.Message, "x escapes") {
-				found = true
-			}
-		}
-		if !found {
-			t.Fatalf(`expected to find diagnostic with message "escape(x escapes to heap)", found none`)
-		}
-
-		// Editing a buffer should cause gc_details diagnostics to disappear, since
-		// they only apply to saved buffers.
-		env.EditBuffer("main.go", fake.NewEdit(0, 0, 0, 0, "\n\n"))
-		env.Await(EmptyDiagnostics("main.go"))
-
-		// Saving a buffer should re-format back to the original state, and
-		// re-enable the gc_details diagnostics.
-		env.SaveBuffer("main.go")
-		env.Await(DiagnosticAt("main.go", 6, 12))
-
-		// Toggle the GC details code lens again so now it should be off.
-		env.ExecuteCodeLensCommand("main.go", source.CommandToggleDetails)
-		env.Await(
-			EmptyDiagnostics("main.go"),
-		)
-	})
-}
diff -urN a/gopls/internal/regtest/completion_bench_test.go b/gopls/internal/regtest/completion_bench_test.go
--- a/gopls/internal/regtest/completion_bench_test.go	2000-01-01 00:00:00.000000000 -0000
+++ b/gopls/internal/regtest/completion_bench_test.go	1969-12-31 19:00:00.000000000 -0500
@@ -1,200 +0,0 @@
-// Copyright 2020 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package regtest
-
-import (
-	"flag"
-	"fmt"
-	"runtime"
-	"strings"
-	"testing"
-
-	"golang.org/x/tools/internal/lsp/fake"
-)
-
-// dummyCompletionFunction to test manually configured completion using CLI.
-func dummyCompletionFunction() { const s = "placeholder"; fmt.Printf("%s", s) }
-
-type completionBenchOptions struct {
-	workdir, file, locationRegexp string
-	printResults                  bool
-	// hook to run edits before initial completion, not supported for manually
-	// configured completions.
-	preCompletionEdits func(*Env)
-}
-
-var completionOptions = completionBenchOptions{}
-
-func init() {
-	flag.StringVar(&completionOptions.workdir, "completion_workdir", "", "directory to run completion benchmarks in")
-	flag.StringVar(&completionOptions.file, "completion_file", "", "relative path to the file to complete in")
-	flag.StringVar(&completionOptions.locationRegexp, "completion_regexp", "", "regexp location to complete at")
-	flag.BoolVar(&completionOptions.printResults, "completion_print_results", false, "whether to print completion results")
-}
-
-func benchmarkCompletion(options completionBenchOptions, t *testing.T) {
-	if completionOptions.workdir == "" {
-		t.Skip("-completion_workdir not configured, skipping benchmark")
-	}
-
-	opts := stressTestOptions(options.workdir)
-
-	// Completion gives bad results if IWL is not yet complete, so we must await
-	// it first (and therefore need hooks).
-	opts = append(opts, SkipHooks(false))
-
-	withOptions(opts...).run(t, "", func(t *testing.T, env *Env) {
-		env.OpenFile(options.file)
-
-		// Run edits required for this completion.
-		if options.preCompletionEdits != nil {
-			options.preCompletionEdits(env)
-		}
-
-		// Add a comment as a marker at the start of the file, we'll replace
-		// this in every iteration to trigger type checking and hence emulate
-		// a more real world scenario.
-		env.EditBuffer(options.file, fake.Edit{Text: "// 0\n"})
-
-		// Run a completion to make sure the system is warm.
-		pos := env.RegexpSearch(options.file, options.locationRegexp)
-		completions := env.Completion(options.file, pos)
-
-		if options.printResults {
-			fmt.Println("Results:")
-			for i := 0; i < len(completions.Items); i++ {
-				fmt.Printf("\t%d. %v\n", i, completions.Items[i])
-			}
-		}
-
-		results := testing.Benchmark(func(b *testing.B) {
-			for i := 0; i < b.N; i++ {
-				b.StopTimer()
-				env.RegexpReplace(options.file, `\/\/ \d*`, fmt.Sprintf("// %d", i))
-
-				// explicitly garbage collect since we don't want to count this
-				// time in completion benchmarks.
-				if i%10 == 0 {
-					runtime.GC()
-				}
-				b.StartTimer()
-
-				env.Completion(options.file, pos)
-			}
-		})
-
-		printBenchmarkResults(results)
-	})
-}
-
-// endPosInBuffer returns the position for last character in the buffer for
-// the given file.
-func endPosInBuffer(env *Env, name string) fake.Pos {
-	buffer := env.Editor.BufferText(name)
-	lines := strings.Split(buffer, "\n")
-	numLines := len(lines)
-
-	return fake.Pos{
-		Line:   numLines - 1,
-		Column: len([]rune(lines[numLines-1])),
-	}
-}
-
-// Benchmark completion at a specified file and location. When no CLI options
-// are specified, this test is skipped.
-// To Run (from x/tools/gopls) against the dummy function above:
-// 	go test -v ./internal/regtest -run=TestBenchmarkConfiguredCompletion
-// 	-completion_workdir="$HOME/Developer/tools"
-// 	-completion_file="gopls/internal/regtest/completion_bench_test.go"
-// 	-completion_regexp="dummyCompletionFunction.*fmt\.Printf\(\"%s\", s(\))"
-func TestBenchmarkConfiguredCompletion(t *testing.T) {
-	benchmarkCompletion(completionOptions, t)
-}
-
-// To run (from x/tools/gopls):
-// 	go test -v ./internal/regtest -run TestBenchmark<>Completion
-//	-completion_workdir="$HOME/Developer/tools"
-// where <> is one of the tests below. completion_workdir should be path to
-// x/tools on your system.
-
-// Benchmark struct completion in tools codebase.
-func TestBenchmarkStructCompletion(t *testing.T) {
-	file := "internal/lsp/cache/session.go"
-
-	preCompletionEdits := func(env *Env) {
-		env.OpenFile(file)
-		originalBuffer := env.Editor.BufferText(file)
-		env.EditBuffer(file, fake.Edit{
-			End:  endPosInBuffer(env, file),
-			Text: originalBuffer + "\nvar testVariable map[string]bool = Session{}.\n",
-		})
-	}
-
-	benchmarkCompletion(completionBenchOptions{
-		workdir:            completionOptions.workdir,
-		file:               file,
-		locationRegexp:     `var testVariable map\[string\]bool = Session{}(\.)`,
-		preCompletionEdits: preCompletionEdits,
-		printResults:       completionOptions.printResults,
-	}, t)
-}
-
-// Benchmark import completion in tools codebase.
-func TestBenchmarkImportCompletion(t *testing.T) {
-	benchmarkCompletion(completionBenchOptions{
-		workdir:        completionOptions.workdir,
-		file:           "internal/lsp/source/completion/completion.go",
-		locationRegexp: `go\/()`,
-		printResults:   completionOptions.printResults,
-	}, t)
-}
-
-// Benchmark slice completion in tools codebase.
-func TestBenchmarkSliceCompletion(t *testing.T) {
-	file := "internal/lsp/cache/session.go"
-
-	preCompletionEdits := func(env *Env) {
-		env.OpenFile(file)
-		originalBuffer := env.Editor.BufferText(file)
-		env.EditBuffer(file, fake.Edit{
-			End:  endPosInBuffer(env, file),
-			Text: originalBuffer + "\nvar testVariable []byte = \n",
-		})
-	}
-
-	benchmarkCompletion(completionBenchOptions{
-		workdir:            completionOptions.workdir,
-		file:               file,
-		locationRegexp:     `var testVariable \[\]byte (=)`,
-		preCompletionEdits: preCompletionEdits,
-		printResults:       completionOptions.printResults,
-	}, t)
-}
-
-// Benchmark deep completion in function call in tools codebase.
-func TestBenchmarkFuncDeepCompletion(t *testing.T) {
-	file := "internal/lsp/source/completion/completion.go"
-	fileContent := `
-func (c *completer) _() {
-	c.inference.kindMatches(c.)
-}
-`
-	preCompletionEdits := func(env *Env) {
-		env.OpenFile(file)
-		originalBuffer := env.Editor.BufferText(file)
-		env.EditBuffer(file, fake.Edit{
-			End:  endPosInBuffer(env, file),
-			Text: originalBuffer + fileContent,
-		})
-	}
-
-	benchmarkCompletion(completionBenchOptions{
-		workdir:            completionOptions.workdir,
-		file:               file,
-		locationRegexp:     `func \(c \*completer\) _\(\) {\n\tc\.inference\.kindMatches\((c)`,
-		preCompletionEdits: preCompletionEdits,
-		printResults:       completionOptions.printResults,
-	}, t)
-}
diff -urN a/gopls/internal/regtest/completion_test.go b/gopls/internal/regtest/completion_test.go
--- a/gopls/internal/regtest/completion_test.go	2000-01-01 00:00:00.000000000 -0000
+++ b/gopls/internal/regtest/completion_test.go	1969-12-31 19:00:00.000000000 -0500
@@ -1,213 +0,0 @@
-// Copyright 2020 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package regtest
-
-import (
-	"fmt"
-	"strings"
-	"testing"
-
-	"golang.org/x/tools/internal/lsp"
-	"golang.org/x/tools/internal/lsp/fake"
-	"golang.org/x/tools/internal/lsp/protocol"
-	"golang.org/x/tools/internal/testenv"
-)
-
-func TestPackageCompletion(t *testing.T) {
-	testenv.NeedsGo1Point(t, 14)
-	const files = `
--- go.mod --
-module mod.com
-
--- fruits/apple.go --
-package apple
-
-fun apple() int {
-	return 0
-}
-
--- fruits/testfile.go --
-// this is a comment
-
-/*
- this is a multiline comment
-*/
-
-import "fmt"
-
-func test() {}
-
--- fruits/testfile2.go --
-package
-
--- fruits/testfile3.go --
-pac
-`
-	var (
-		testfile4 = ""
-		testfile5 = "/*a comment*/ "
-		testfile6 = "/*a comment*/\n"
-	)
-	for _, tc := range []struct {
-		name          string
-		filename      string
-		content       *string
-		triggerRegexp string
-		want          []string
-		editRegexp    string
-	}{
-		{
-			name:          "package completion at valid position",
-			filename:      "fruits/testfile.go",
-			triggerRegexp: "\n()",
-			want:          []string{"package apple", "package apple_test", "package fruits", "package fruits_test", "package main"},
-			editRegexp:    "\n()",
-		},
-		{
-			name:          "package completion in a comment",
-			filename:      "fruits/testfile.go",
-			triggerRegexp: "th(i)s",
-			want:          nil,
-		},
-		{
-			name:          "package completion in a multiline comment",
-			filename:      "fruits/testfile.go",
-			triggerRegexp: `\/\*\n()`,
-			want:          nil,
-		},
-		{
-			name:          "package completion at invalid position",
-			filename:      "fruits/testfile.go",
-			triggerRegexp: "import \"fmt\"\n()",
-			want:          nil,
-		},
-		{
-			name:          "package completion after keyword 'package'",
-			filename:      "fruits/testfile2.go",
-			triggerRegexp: "package()",
-			want:          []string{"package apple", "package apple_test", "package fruits", "package fruits_test", "package main"},
-			editRegexp:    "package\n",
-		},
-		{
-			name:          "package completion with 'pac' prefix",
-			filename:      "fruits/testfile3.go",
-			triggerRegexp: "pac()",
-			want:          []string{"package apple", "package apple_test", "package fruits", "package fruits_test", "package main"},
-			editRegexp:    "pac",
-		},
-		{
-			name:          "package completion for empty file",
-			filename:      "fruits/testfile4.go",
-			triggerRegexp: "^$",
-			content:       &testfile4,
-			want:          []string{"package apple", "package apple_test", "package fruits", "package fruits_test", "package main"},
-			editRegexp:    "^$",
-		},
-		{
-			name:          "package completion without terminal newline",
-			filename:      "fruits/testfile5.go",
-			triggerRegexp: `\*\/ ()`,
-			content:       &testfile5,
-			want:          []string{"package apple", "package apple_test", "package fruits", "package fruits_test", "package main"},
-			editRegexp:    `\*\/ ()`,
-		},
-		{
-			name:          "package completion on terminal newline",
-			filename:      "fruits/testfile6.go",
-			triggerRegexp: `\*\/\n()`,
-			content:       &testfile6,
-			want:          []string{"package apple", "package apple_test", "package fruits", "package fruits_test", "package main"},
-			editRegexp:    `\*\/\n()`,
-		},
-	} {
-		t.Run(tc.name, func(t *testing.T) {
-			run(t, files, func(t *testing.T, env *Env) {
-				if tc.content != nil {
-					env.WriteWorkspaceFile(tc.filename, *tc.content)
-					env.Await(
-						CompletedWork(lsp.DiagnosticWorkTitle(lsp.FromDidChangeWatchedFiles), 1),
-					)
-				}
-				env.OpenFile(tc.filename)
-				completions := env.Completion(tc.filename, env.RegexpSearch(tc.filename, tc.triggerRegexp))
-
-				// Check that the completion item suggestions are in the range
-				// of the file.
-				lineCount := len(strings.Split(env.Editor.BufferText(tc.filename), "\n"))
-				for _, item := range completions.Items {
-					if start := int(item.TextEdit.Range.Start.Line); start >= lineCount {
-						t.Fatalf("unexpected text edit range start line number: got %d, want less than %d", start, lineCount)
-					}
-					if end := int(item.TextEdit.Range.End.Line); end >= lineCount {
-						t.Fatalf("unexpected text edit range end line number: got %d, want less than %d", end, lineCount)
-					}
-				}
-
-				if tc.want != nil {
-					start, end := env.RegexpRange(tc.filename, tc.editRegexp)
-					expectedRng := protocol.Range{
-						Start: fake.Pos.ToProtocolPosition(start),
-						End:   fake.Pos.ToProtocolPosition(end),
-					}
-					for _, item := range completions.Items {
-						gotRng := item.TextEdit.Range
-						if expectedRng != gotRng {
-							t.Errorf("unexpected completion range for completion item %s: got %v, want %v",
-								item.Label, gotRng, expectedRng)
-						}
-					}
-				}
-
-				diff := compareCompletionResults(tc.want, completions.Items)
-				if diff != "" {
-					t.Error(diff)
-				}
-			})
-		})
-	}
-}
-
-func TestPackageNameCompletion(t *testing.T) {
-	const files = `
--- go.mod --
-module mod.com
-
--- math/add.go --
-package ma
-`
-
-	want := []string{"ma", "ma_test", "main", "math", "math_test"}
-	run(t, files, func(t *testing.T, env *Env) {
-		env.OpenFile("math/add.go")
-		completions := env.Completion("math/add.go", fake.Pos{
-			Line:   0,
-			Column: 10,
-		})
-
-		diff := compareCompletionResults(want, completions.Items)
-		if diff != "" {
-			t.Fatal(diff)
-		}
-	})
-}
-
-func compareCompletionResults(want []string, gotItems []protocol.CompletionItem) string {
-	if len(gotItems) != len(want) {
-		return fmt.Sprintf("got %v completion(s), want %v", len(gotItems), len(want))
-	}
-
-	var got []string
-	for _, item := range gotItems {
-		got = append(got, item.Label)
-	}
-
-	for i, v := range got {
-		if v != want[i] {
-			return fmt.Sprintf("completion results are not the same: got %v, want %v", got, want)
-		}
-	}
-
-	return ""
-}
diff -urN a/gopls/internal/regtest/configuration_test.go b/gopls/internal/regtest/configuration_test.go
--- a/gopls/internal/regtest/configuration_test.go	2000-01-01 00:00:00.000000000 -0000
+++ b/gopls/internal/regtest/configuration_test.go	1969-12-31 19:00:00.000000000 -0500
@@ -1,42 +0,0 @@
-// Copyright 2020 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package regtest
-
-import (
-	"testing"
-
-	"golang.org/x/tools/internal/lsp"
-	"golang.org/x/tools/internal/lsp/fake"
-)
-
-// Test that enabling and disabling produces the expected results of showing
-// and hiding staticcheck analysis results.
-func TestChangeConfiguration(t *testing.T) {
-	const files = `
--- go.mod --
-module mod.com
-
-go 1.12
--- a/a.go --
-package a
-
-// NotThisVariable should really start with ThisVariable.
-const ThisVariable = 7
-`
-	run(t, files, func(t *testing.T, env *Env) {
-		env.OpenFile("a/a.go")
-		env.Await(
-			CompletedWork(lsp.DiagnosticWorkTitle(lsp.FromDidOpen), 1),
-			NoDiagnostics("a/a.go"),
-		)
-		cfg := &fake.EditorConfig{}
-		*cfg = env.Editor.Config
-		cfg.EnableStaticcheck = true
-		env.changeConfiguration(t, cfg)
-		env.Await(
-			DiagnosticAt("a/a.go", 2, 0),
-		)
-	})
-}
diff -urN a/gopls/internal/regtest/definition_test.go b/gopls/internal/regtest/definition_test.go
--- a/gopls/internal/regtest/definition_test.go	2000-01-01 00:00:00.000000000 -0000
+++ b/gopls/internal/regtest/definition_test.go	1969-12-31 19:00:00.000000000 -0500
@@ -1,131 +0,0 @@
-// Copyright 2020 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package regtest
-
-import (
-	"path"
-	"strings"
-	"testing"
-
-	"golang.org/x/tools/internal/lsp/tests"
-)
-
-const internalDefinition = `
--- go.mod --
-module mod.com
-
-go 1.12
--- main.go --
-package main
-
-import "fmt"
-
-func main() {
-	fmt.Println(message)
-}
--- const.go --
-package main
-
-const message = "Hello World."
-`
-
-func TestGoToInternalDefinition(t *testing.T) {
-	runner.Run(t, internalDefinition, func(t *testing.T, env *Env) {
-		env.OpenFile("main.go")
-		name, pos := env.GoToDefinition("main.go", env.RegexpSearch("main.go", "message"))
-		if want := "const.go"; name != want {
-			t.Errorf("GoToDefinition: got file %q, want %q", name, want)
-		}
-		if want := env.RegexpSearch("const.go", "message"); pos != want {
-			t.Errorf("GoToDefinition: got position %v, want %v", pos, want)
-		}
-	})
-}
-
-const stdlibDefinition = `
--- go.mod --
-module mod.com
-
--- main.go --
-package main
-
-import "fmt"
-
-func main() {
-	fmt.Printf()
-}`
-
-func TestGoToStdlibDefinition_Issue37045(t *testing.T) {
-	runner.Run(t, stdlibDefinition, func(t *testing.T, env *Env) {
-		env.OpenFile("main.go")
-		name, pos := env.GoToDefinition("main.go", env.RegexpSearch("main.go", `fmt.(Printf)`))
-		if got, want := path.Base(name), "print.go"; got != want {
-			t.Errorf("GoToDefinition: got file %q, want %q", name, want)
-		}
-
-		// Test that we can jump to definition from outside our workspace.
-		// See golang.org/issues/37045.
-		newName, newPos := env.GoToDefinition(name, pos)
-		if newName != name {
-			t.Errorf("GoToDefinition is not idempotent: got %q, want %q", newName, name)
-		}
-		if newPos != pos {
-			t.Errorf("GoToDefinition is not idempotent: got %v, want %v", newPos, pos)
-		}
-	})
-}
-
-func TestUnexportedStdlib_Issue40809(t *testing.T) {
-	runner.Run(t, stdlibDefinition, func(t *testing.T, env *Env) {
-		env.OpenFile("main.go")
-		name, _ := env.GoToDefinition("main.go", env.RegexpSearch("main.go", `fmt.(Printf)`))
-		env.OpenFile(name)
-
-		pos := env.RegexpSearch(name, `:=\s*(newPrinter)\(\)`)
-
-		// Check that we can find references on a reference
-		refs := env.References(name, pos)
-		if len(refs) < 5 {
-			t.Errorf("expected 5+ references to newPrinter, found: %#v", refs)
-		}
-
-		name, pos = env.GoToDefinition(name, pos)
-		content, _ := env.Hover(name, pos)
-		if !strings.Contains(content.Value, "newPrinter") {
-			t.Fatal("definition of newPrinter went to the incorrect place")
-		}
-		// And on the definition too.
-		refs = env.References(name, pos)
-		if len(refs) < 5 {
-			t.Errorf("expected 5+ references to newPrinter, found: %#v", refs)
-		}
-	})
-}
-
-// Test the hover on an error's Error function.
-// This can't be done via the marker tests because Error is a builtin.
-func TestHoverOnError(t *testing.T) {
-	const mod = `
--- go.mod --
-module mod.com
--- main.go --
-package main
-
-func main() {
-	var err error
-	err.Error()
-}`
-	run(t, mod, func(t *testing.T, env *Env) {
-		env.OpenFile("main.go")
-		content, _ := env.Hover("main.go", env.RegexpSearch("main.go", "Error"))
-		if content == nil {
-			t.Fatalf("nil hover content for Error")
-		}
-		want := "```go\nfunc (error).Error() string\n```"
-		if content.Value != want {
-			t.Fatalf("hover failed:\n%s", tests.Diff(want, content.Value))
-		}
-	})
-}
diff -urN a/gopls/internal/regtest/diagnostics_test.go b/gopls/internal/regtest/diagnostics_test.go
--- a/gopls/internal/regtest/diagnostics_test.go	2000-01-01 00:00:00.000000000 -0000
+++ b/gopls/internal/regtest/diagnostics_test.go	1969-12-31 19:00:00.000000000 -0500
@@ -1,1596 +0,0 @@
-// Copyright 2020 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package regtest
-
-import (
-	"context"
-	"fmt"
-	"log"
-	"os"
-	"testing"
-	"time"
-
-	"golang.org/x/tools/internal/lsp"
-	"golang.org/x/tools/internal/lsp/fake"
-	"golang.org/x/tools/internal/lsp/protocol"
-	"golang.org/x/tools/internal/lsp/tests"
-	"golang.org/x/tools/internal/testenv"
-)
-
-// Use mod.com for all go.mod files due to golang/go#35230.
-const exampleProgram = `
--- go.mod --
-module mod.com
-
-go 1.12
--- main.go --
-package main
-
-import "fmt"
-
-func main() {
-	fmt.Println("Hello World.")
-}`
-
-func TestDiagnosticErrorInEditedFile(t *testing.T) {
-	// This test is very basic: start with a clean Go program, make an error, and
-	// get a diagnostic for that error. However, it also demonstrates how to
-	// combine Expectations to await more complex state in the editor.
-	runner.Run(t, exampleProgram, func(t *testing.T, env *Env) {
-		// Deleting the 'n' at the end of Println should generate a single error
-		// diagnostic.
-		env.OpenFile("main.go")
-		env.RegexpReplace("main.go", "Printl(n)", "")
-		env.Await(
-			// Once we have gotten diagnostics for the change above, we should
-			// satisfy the DiagnosticAtRegexp assertion.
-			OnceMet(
-				CompletedWork(lsp.DiagnosticWorkTitle(lsp.FromDidChange), 1),
-				env.DiagnosticAtRegexp("main.go", "Printl"),
-			),
-			// Assert that this test has sent no error logs to the client. This is not
-			// strictly necessary for testing this regression, but is included here
-			// as an example of using the NoErrorLogs() expectation. Feel free to
-			// delete.
-			NoErrorLogs(),
-		)
-	})
-}
-
-func TestMissingImportDiagsClearOnFirstFile(t *testing.T) {
-	const onlyMod = `
--- go.mod --
-module mod.com
-
-go 1.12
-`
-	runner.Run(t, onlyMod, func(t *testing.T, env *Env) {
-		env.CreateBuffer("main.go", `package main
-
-func m() {
-	log.Println()
-}
-`)
-		env.Await(
-			env.DiagnosticAtRegexp("main.go", "log"),
-		)
-		env.SaveBuffer("main.go")
-		env.Await(
-			EmptyDiagnostics("main.go"),
-		)
-	})
-}
-
-func TestDiagnosticErrorInNewFile(t *testing.T) {
-	const brokenFile = `package main
-
-const Foo = "abc
-`
-	runner.Run(t, brokenFile, func(t *testing.T, env *Env) {
-		env.CreateBuffer("broken.go", brokenFile)
-		env.Await(env.DiagnosticAtRegexp("broken.go", "\"abc"))
-	})
-}
-
-// badPackage contains a duplicate definition of the 'a' const.
-const badPackage = `
--- go.mod --
-module mod.com
-
-go 1.12
--- a.go --
-package consts
-
-const a = 1
--- b.go --
-package consts
-
-const a = 2
-`
-
-func TestDiagnosticClearingOnEdit(t *testing.T) {
-	runner.Run(t, badPackage, func(t *testing.T, env *Env) {
-		env.OpenFile("b.go")
-		env.Await(env.DiagnosticAtRegexp("a.go", "a = 1"), env.DiagnosticAtRegexp("b.go", "a = 2"))
-
-		// Fix the error by editing the const name in b.go to `b`.
-		env.RegexpReplace("b.go", "(a) = 2", "b")
-		env.Await(
-			EmptyDiagnostics("a.go"),
-			EmptyDiagnostics("b.go"),
-		)
-	})
-}
-
-func TestDiagnosticClearingOnDelete_Issue37049(t *testing.T) {
-	runner.Run(t, badPackage, func(t *testing.T, env *Env) {
-		env.OpenFile("a.go")
-		env.Await(env.DiagnosticAtRegexp("a.go", "a = 1"), env.DiagnosticAtRegexp("b.go", "a = 2"))
-		env.RemoveWorkspaceFile("b.go")
-
-		env.Await(EmptyDiagnostics("a.go"), EmptyDiagnostics("b.go"))
-	})
-}
-
-func TestDiagnosticClearingOnClose(t *testing.T) {
-	runner.Run(t, badPackage, func(t *testing.T, env *Env) {
-		env.CreateBuffer("c.go", `package consts
-
-const a = 3`)
-		env.Await(
-			env.DiagnosticAtRegexp("a.go", "a = 1"),
-			env.DiagnosticAtRegexp("b.go", "a = 2"),
-			env.DiagnosticAtRegexp("c.go", "a = 3"))
-		env.CloseBuffer("c.go")
-		env.Await(
-			env.DiagnosticAtRegexp("a.go", "a = 1"),
-			env.DiagnosticAtRegexp("b.go", "a = 2"),
-			EmptyDiagnostics("c.go"))
-	})
-}
-
-// Tests golang/go#37978.
-func TestIssue37978(t *testing.T) {
-	runner.Run(t, exampleProgram, func(t *testing.T, env *Env) {
-		// Create a new workspace-level directory and empty file.
-		env.CreateBuffer("c/c.go", "")
-
-		// Write the file contents with a missing import.
-		env.EditBuffer("c/c.go", fake.Edit{
-			Text: `package c
-
-const a = http.MethodGet
-`,
-		})
-		env.Await(
-			env.DiagnosticAtRegexp("c/c.go", "http.MethodGet"),
-		)
-		// Save file, which will organize imports, adding the expected import.
-		// Expect the diagnostics to clear.
-		env.SaveBuffer("c/c.go")
-		env.Await(
-			EmptyDiagnostics("c/c.go"),
-		)
-	})
-}
-
-// Tests golang/go#38878: good a.go, bad a_test.go, remove a_test.go but its errors remain
-// If the file is open in the editor, this is working as intended
-// If the file is not open in the editor, the errors go away
-const test38878 = `
--- go.mod --
-module foo
-
--- a.go --
-package x
-
-func f() {}
-
--- a_test.go --
-package x
-
-import "testing"
-
-func TestA(t *testing.T) {
-	f(3)
-}
-`
-
-func TestRmTest38878Close(t *testing.T) {
-	runner.Run(t, test38878, func(t *testing.T, env *Env) {
-		env.OpenFile("a_test.go")
-		env.Await(DiagnosticAt("a_test.go", 5, 3))
-		env.CloseBuffer("a_test.go")
-		env.RemoveWorkspaceFile("a_test.go")
-		// diagnostics go away
-		env.Await(EmptyDiagnostics("a_test.go"))
-	})
-}
-
-func TestRmTest38878(t *testing.T) {
-	log.SetFlags(log.Lshortfile)
-	runner.Run(t, test38878, func(t *testing.T, env *Env) {
-		env.OpenFile("a_test.go")
-		env.Await(DiagnosticAt("a_test.go", 5, 3))
-		env.Sandbox.Workdir.RemoveFile(context.Background(), "a_test.go")
-		// diagnostics remain after giving gopls a chance to do something
-		// (there is not yet a better way to decide gopls isn't going
-		// to do anything)
-		time.Sleep(time.Second)
-		env.Await(DiagnosticAt("a_test.go", 5, 3))
-	})
-}
-
-// TestNoMod confirms that gopls continues to work when a user adds a go.mod
-// file to their workspace.
-func TestNoMod(t *testing.T) {
-	const noMod = `
--- main.go --
-package main
-
-import "mod.com/bob"
-
-func main() {
-	bob.Hello()
-}
--- bob/bob.go --
-package bob
-
-func Hello() {
-	var x int
-}
-`
-
-	t.Run("manual", func(t *testing.T) {
-		runner.Run(t, noMod, func(t *testing.T, env *Env) {
-			env.Await(
-				env.DiagnosticAtRegexp("main.go", `"mod.com/bob"`),
-			)
-			env.CreateBuffer("go.mod", `module mod.com
-
-	go 1.12
-`)
-			env.SaveBuffer("go.mod")
-			env.Await(
-				EmptyDiagnostics("main.go"),
-			)
-			var d protocol.PublishDiagnosticsParams
-			env.Await(
-				OnceMet(
-					env.DiagnosticAtRegexp("bob/bob.go", "x"),
-					ReadDiagnostics("bob/bob.go", &d),
-				),
-			)
-			if len(d.Diagnostics) != 1 {
-				t.Fatalf("expected 1 diagnostic, got %v", len(d.Diagnostics))
-			}
-		})
-	})
-	t.Run("initialized", func(t *testing.T) {
-		runner.Run(t, noMod, func(t *testing.T, env *Env) {
-			env.Await(
-				env.DiagnosticAtRegexp("main.go", `"mod.com/bob"`),
-			)
-			env.RunGoCommand("mod", "init", "mod.com")
-			env.Await(
-				EmptyDiagnostics("main.go"),
-				env.DiagnosticAtRegexp("bob/bob.go", "x"),
-			)
-		})
-	})
-
-	t.Run("without workspace module", func(t *testing.T) {
-		withOptions(
-			WithModes(WithoutExperiments),
-		).run(t, noMod, func(t *testing.T, env *Env) {
-			env.Await(
-				env.DiagnosticAtRegexp("main.go", `"mod.com/bob"`),
-			)
-			if err := env.Sandbox.RunGoCommand(env.Ctx, "", "mod", []string{"init", "mod.com"}); err != nil {
-				t.Fatal(err)
-			}
-			env.Await(
-				EmptyDiagnostics("main.go"),
-				env.DiagnosticAtRegexp("bob/bob.go", "x"),
-			)
-		})
-	})
-}
-
-// Tests golang/go#38267.
-func TestIssue38267(t *testing.T) {
-	const testPackage = `
--- go.mod --
-module mod.com
-
-go 1.12
--- lib.go --
-package lib
-
-func Hello(x string) {
-	_ = x
-}
--- lib_test.go --
-package lib
-
-import "testing"
-
-type testStruct struct{
-	name string
-}
-
-func TestHello(t *testing.T) {
-	testStructs := []*testStruct{
-		&testStruct{"hello"},
-		&testStruct{"goodbye"},
-	}
-	for y := range testStructs {
-		_ = y
-	}
-}
-`
-
-	runner.Run(t, testPackage, func(t *testing.T, env *Env) {
-		env.OpenFile("lib_test.go")
-		env.Await(
-			DiagnosticAt("lib_test.go", 10, 2),
-			DiagnosticAt("lib_test.go", 11, 2),
-		)
-		env.OpenFile("lib.go")
-		env.RegexpReplace("lib.go", "_ = x", "var y int")
-		env.Await(
-			env.DiagnosticAtRegexp("lib.go", "y int"),
-			EmptyDiagnostics("lib_test.go"),
-		)
-	})
-}
-
-// Tests golang/go#38328.
-func TestPackageChange_Issue38328(t *testing.T) {
-	const packageChange = `
--- go.mod --
-module fake
--- a.go --
-package foo
-func main() {}
-`
-	runner.Run(t, packageChange, func(t *testing.T, env *Env) {
-		env.OpenFile("a.go")
-		env.RegexpReplace("a.go", "foo", "foox")
-		env.Await(
-			// When the bug reported in #38328 was present, we didn't get erroneous
-			// file diagnostics until after the didChange message generated by the
-			// package renaming was fully processed. Therefore, in order for this
-			// test to actually exercise the bug, we must wait until that work has
-			// completed.
-			OnceMet(
-				CompletedWork(lsp.DiagnosticWorkTitle(lsp.FromDidChange), 1),
-				NoDiagnostics("a.go"),
-			),
-		)
-	})
-}
-
-const testPackageWithRequire = `
--- go.mod --
-module mod.com
-
-go 1.12
-
-require (
-	foo.test v1.2.3
-)
--- print.go --
-package lib
-
-import (
-	"fmt"
-
-	"foo.test/bar"
-)
-
-func PrintAnswer() {
-	fmt.Printf("answer: %s", bar.Answer)
-}
-`
-
-const testPackageWithRequireProxy = `
--- foo.test@v1.2.3/go.mod --
-module foo.test
-
-go 1.12
--- foo.test@v1.2.3/bar/const.go --
-package bar
-
-const Answer = 42
-`
-
-func TestResolveDiagnosticWithDownload(t *testing.T) {
-	runner.Run(t, testPackageWithRequire, func(t *testing.T, env *Env) {
-		env.OpenFile("print.go")
-		// Check that gopackages correctly loaded this dependency. We should get a
-		// diagnostic for the wrong formatting type.
-		// TODO: we should be able to easily also match the diagnostic message.
-		env.Await(env.DiagnosticAtRegexp("print.go", "fmt.Printf"))
-	}, WithProxyFiles(testPackageWithRequireProxy))
-}
-
-func TestMissingDependency(t *testing.T) {
-	runner.Run(t, testPackageWithRequire, func(t *testing.T, env *Env) {
-		env.OpenFile("print.go")
-		env.Await(LogMatching(protocol.Error, "initial workspace load failed", 1))
-	})
-}
-
-// Tests golang/go#36951.
-func TestAdHocPackages_Issue36951(t *testing.T) {
-	const adHoc = `
--- b/b.go --
-package b
-
-func Hello() {
-	var x int
-}
-`
-	runner.Run(t, adHoc, func(t *testing.T, env *Env) {
-		env.OpenFile("b/b.go")
-		env.Await(env.DiagnosticAtRegexp("b/b.go", "x"))
-	})
-}
-
-// Tests golang/go#37984: GOPATH should be read from the go command.
-func TestNoGOPATH_Issue37984(t *testing.T) {
-	const files = `
--- main.go --
-package main
-
-func _() {
-	fmt.Println("Hello World")
-}
-`
-	editorConfig := EditorConfig{Env: map[string]string{"GOPATH": ""}}
-	withOptions(editorConfig).run(t, files, func(t *testing.T, env *Env) {
-		env.OpenFile("main.go")
-		env.Await(env.DiagnosticAtRegexp("main.go", "fmt"))
-		env.SaveBuffer("main.go")
-		env.Await(EmptyDiagnostics("main.go"))
-	})
-}
-
-// Tests golang/go#38669.
-func TestEqualInEnv_Issue38669(t *testing.T) {
-	const files = `
--- go.mod --
-module mod.com
-
--- main.go --
-package main
-
-var _ = x.X
--- x/x.go --
-package x
-
-var X = 0
-`
-	editorConfig := EditorConfig{Env: map[string]string{"GOFLAGS": "-tags=foo"}}
-	withOptions(editorConfig).run(t, files, func(t *testing.T, env *Env) {
-		env.OpenFile("main.go")
-		env.OrganizeImports("main.go")
-		env.Await(EmptyDiagnostics("main.go"))
-	})
-}
-
-// Tests golang/go#38467.
-func TestNoSuggestedFixesForGeneratedFiles_Issue38467(t *testing.T) {
-	const generated = `
--- go.mod --
-module mod.com
-
--- main.go --
-package main
-
-// Code generated by generator.go. DO NOT EDIT.
-
-func _() {
-	for i, _ := range []string{} {
-		_ = i
-	}
-}
-`
-	runner.Run(t, generated, func(t *testing.T, env *Env) {
-		env.OpenFile("main.go")
-		original := env.ReadWorkspaceFile("main.go")
-		var d protocol.PublishDiagnosticsParams
-		env.Await(
-			OnceMet(
-				DiagnosticAt("main.go", 5, 8),
-				ReadDiagnostics("main.go", &d),
-			),
-		)
-		// Apply fixes and save the buffer.
-		env.ApplyQuickFixes("main.go", d.Diagnostics)
-		env.SaveBuffer("main.go")
-		fixed := env.ReadWorkspaceFile("main.go")
-		if original != fixed {
-			t.Fatalf("generated file was changed by quick fixes:\n%s", tests.Diff(original, fixed))
-		}
-	})
-}
-
-// Expect a module/GOPATH error if there is an error in the file at startup.
-// Tests golang/go#37279.
-func TestShowMessage_Issue37279(t *testing.T) {
-	const noModule = `
--- a.go --
-package foo
-
-func f() {
-	fmt.Printl()
-}
-`
-	runner.Run(t, noModule, func(t *testing.T, env *Env) {
-		env.OpenFile("a.go")
-		env.Await(env.DiagnosticAtRegexp("a.go", "fmt.Printl"), ShownMessage(""))
-	})
-}
-
-// Expect no module/GOPATH error if there is no error in the file.
-// Tests golang/go#37279.
-func TestNoShowMessage_Issue37279(t *testing.T) {
-	const noModule = `
--- a.go --
-package foo
-
-func f() {
-}
-`
-	runner.Run(t, noModule, func(t *testing.T, env *Env) {
-		env.OpenFile("a.go")
-		env.Await(
-			OnceMet(
-				CompletedWork(lsp.DiagnosticWorkTitle(lsp.FromDidOpen), 1),
-				NoDiagnostics("a.go"),
-			),
-			NoShowMessage(),
-		)
-		// introduce an error, expect no Show Message
-		env.RegexpReplace("a.go", "func", "fun")
-		env.Await(env.DiagnosticAtRegexp("a.go", "fun"), NoShowMessage())
-	})
-}
-
-func TestNonGoFolder(t *testing.T) {
-	const files = `
--- hello.txt --
-hi mom
-`
-	for _, go111module := range []string{"on", "off", ""} {
-		t.Run(fmt.Sprintf("GO111MODULE_%v", go111module), func(t *testing.T) {
-			withOptions(EditorConfig{
-				Env: map[string]string{"GO111MODULE": go111module},
-			}).run(t, files, func(t *testing.T, env *Env) {
-				env.OpenFile("hello.txt")
-				env.Await(
-					OnceMet(
-						CompletedWork(lsp.DiagnosticWorkTitle(lsp.FromDidOpen), 1),
-						NoShowMessage(),
-					),
-				)
-			})
-		})
-	}
-}
-
-// Tests golang/go#38602.
-func TestNonexistentFileDiagnostics_Issue38602(t *testing.T) {
-	const collision = `
--- x/x.go --
-package x
-
-import "x/hello"
-
-func Hello() {
-	hello.HiThere()
-}
--- x/main.go --
-package main
-
-func main() {
-	fmt.Println("")
-}
-`
-	runner.Run(t, collision, func(t *testing.T, env *Env) {
-		env.OpenFile("x/main.go")
-		env.Await(
-			env.DiagnosticAtRegexp("x/main.go", "fmt.Println"),
-		)
-		env.OrganizeImports("x/main.go")
-		// span.Parse misparses the error message when multiple packages are
-		// defined in the same directory, creating a garbage filename.
-		// Previously, we would send diagnostics for this nonexistent file.
-		// This test checks that we don't send diagnostics for this file.
-		dir, err := os.Getwd()
-		if err != nil {
-			t.Fatal(err)
-		}
-		badFile := fmt.Sprintf("%s/found packages main (main.go) and x (x.go) in %s/src/x", dir, env.Sandbox.GOPATH())
-		env.Await(
-			OnceMet(
-				CompletedWork(lsp.DiagnosticWorkTitle(lsp.FromDidChange), 1),
-				EmptyDiagnostics("x/main.go"),
-			),
-			NoDiagnostics(badFile),
-		)
-	}, InGOPATH())
-}
-
-const ardanLabsProxy = `
--- github.com/ardanlabs/conf@v1.2.3/go.mod --
-module github.com/ardanlabs/conf
-
-go 1.12
--- github.com/ardanlabs/conf@v1.2.3/conf.go --
-package conf
-
-var ErrHelpWanted error
-`
-
-// Test for golang/go#38211.
-func Test_Issue38211(t *testing.T) {
-	testenv.NeedsGo1Point(t, 14)
-	const ardanLabs = `
--- go.mod --
-module mod.com
-
-go 1.14
--- main.go --
-package main
-
-import "github.com/ardanlabs/conf"
-
-func main() {
-	_ = conf.ErrHelpWanted
-}
-`
-	withOptions(
-		WithProxyFiles(ardanLabsProxy),
-	).run(t, ardanLabs, func(t *testing.T, env *Env) {
-		// Expect a diagnostic with a suggested fix to add
-		// "github.com/ardanlabs/conf" to the go.mod file.
-		env.OpenFile("go.mod")
-		env.OpenFile("main.go")
-		var d protocol.PublishDiagnosticsParams
-		env.Await(
-			OnceMet(
-				env.DiagnosticAtRegexp("main.go", `"github.com/ardanlabs/conf"`),
-				ReadDiagnostics("main.go", &d),
-			),
-		)
-		env.ApplyQuickFixes("main.go", d.Diagnostics)
-		env.SaveBuffer("go.mod")
-		env.Await(
-			EmptyDiagnostics("main.go"),
-		)
-		// Comment out the line that depends on conf and expect a
-		// diagnostic and a fix to remove the import.
-		env.RegexpReplace("main.go", "_ = conf.ErrHelpWanted", "//_ = conf.ErrHelpWanted")
-		env.Await(
-			env.DiagnosticAtRegexp("main.go", `"github.com/ardanlabs/conf"`),
-		)
-		env.SaveBuffer("main.go")
-		// Expect a diagnostic and fix to remove the dependency in the go.mod.
-		env.Await(EmptyDiagnostics("main.go"))
-		env.Await(
-			OnceMet(
-				env.DiagnosticAtRegexp("go.mod", "require github.com/ardanlabs/conf"),
-				ReadDiagnostics("go.mod", &d),
-			),
-		)
-		env.ApplyQuickFixes("go.mod", d.Diagnostics)
-		env.SaveBuffer("go.mod")
-		env.Await(
-			EmptyDiagnostics("go.mod"),
-		)
-		// Uncomment the lines and expect a new diagnostic for the import.
-		env.RegexpReplace("main.go", "//_ = conf.ErrHelpWanted", "_ = conf.ErrHelpWanted")
-		env.SaveBuffer("main.go")
-		env.Await(
-			env.DiagnosticAtRegexp("main.go", `"github.com/ardanlabs/conf"`),
-		)
-	})
-}
-
-// Test for golang/go#38207.
-func TestNewModule_Issue38207(t *testing.T) {
-	testenv.NeedsGo1Point(t, 14)
-	const emptyFile = `
--- go.mod --
-module mod.com
-
-go 1.12
--- main.go --
-`
-	withOptions(
-		WithProxyFiles(ardanLabsProxy),
-	).run(t, emptyFile, func(t *testing.T, env *Env) {
-		env.OpenFile("main.go")
-		env.EditBuffer("main.go", fake.NewEdit(0, 0, 0, 0, `package main
-
-import "github.com/ardanlabs/conf"
-
-func main() {
-	_ = conf.ErrHelpWanted
-}
-`))
-		env.SaveBuffer("main.go")
-		var d protocol.PublishDiagnosticsParams
-		env.Await(
-			OnceMet(
-				env.DiagnosticAtRegexp("main.go", `"github.com/ardanlabs/conf"`),
-				ReadDiagnostics("main.go", &d),
-			),
-		)
-		env.ApplyQuickFixes("main.go", d.Diagnostics)
-		env.CheckForFileChanges()
-		env.Await(
-			EmptyDiagnostics("main.go"),
-		)
-	})
-}
-
-// Test for golang/go#36960.
-func TestNewFileBadImports_Issue36960(t *testing.T) {
-	testenv.NeedsGo1Point(t, 14)
-	const simplePackage = `
--- go.mod --
-module mod.com
-
-go 1.14
--- a/a1.go --
-package a
-
-import "fmt"
-
-func _() {
-	fmt.Println("hi")
-}
-`
-	runner.Run(t, simplePackage, func(t *testing.T, env *Env) {
-		env.OpenFile("a/a1.go")
-		env.CreateBuffer("a/a2.go", ``)
-		if err := env.Editor.SaveBufferWithoutActions(env.Ctx, "a/a2.go"); err != nil {
-			t.Fatal(err)
-		}
-		env.Await(
-			OnceMet(
-				CompletedWork(lsp.DiagnosticWorkTitle(lsp.FromDidSave), 1),
-				NoDiagnostics("a/a1.go"),
-			),
-		)
-		env.EditBuffer("a/a2.go", fake.NewEdit(0, 0, 0, 0, `package a`))
-		env.Await(
-			OnceMet(
-				CompletedWork(lsp.DiagnosticWorkTitle(lsp.FromDidChange), 1),
-				NoDiagnostics("a/a1.go"),
-			),
-		)
-	})
-}
-
-// This test tries to replicate the workflow of a user creating a new x test.
-// It also tests golang/go#39315.
-func TestManuallyCreatingXTest(t *testing.T) {
-	// Only for 1.15 because of golang/go#37971.
-	testenv.NeedsGo1Point(t, 15)
-
-	// Create a package that already has a test variant (in-package test).
-	const testVariant = `
--- go.mod --
-module mod.com
-
-go 1.15
--- hello/hello.go --
-package hello
-
-func Hello() {
-	var x int
-}
--- hello/hello_test.go --
-package hello
-
-import "testing"
-
-func TestHello(t *testing.T) {
-	var x int
-	Hello()
-}
-`
-	runner.Run(t, testVariant, func(t *testing.T, env *Env) {
-		// Open the file, triggering the workspace load.
-		// There are errors in the code to ensure all is working as expected.
-		env.OpenFile("hello/hello.go")
-		env.Await(
-			env.DiagnosticAtRegexp("hello/hello.go", "x"),
-			env.DiagnosticAtRegexp("hello/hello_test.go", "x"),
-		)
-
-		// Create an empty file with the intention of making it an x test.
-		// This resembles a typical flow in an editor like VS Code, in which
-		// a user would create an empty file and add content, saving
-		// intermittently.
-		// TODO(rstambler): There might be more edge cases here, as file
-		// content can be added incrementally.
-		env.CreateBuffer("hello/hello_x_test.go", ``)
-
-		// Save the empty file (no actions since formatting will fail).
-		env.Editor.SaveBufferWithoutActions(env.Ctx, "hello/hello_x_test.go")
-
-		// Add the content. The missing import is for the package under test.
-		env.EditBuffer("hello/hello_x_test.go", fake.NewEdit(0, 0, 0, 0, `package hello_test
-
-import (
-	"testing"
-)
-
-func TestHello(t *testing.T) {
-	hello.Hello()
-}
-`))
-		// Expect a diagnostic for the missing import. Save, which should
-		// trigger import organization. The diagnostic should clear.
-		env.Await(
-			env.DiagnosticAtRegexp("hello/hello_x_test.go", "hello.Hello"),
-		)
-		env.SaveBuffer("hello/hello_x_test.go")
-		env.Await(
-			EmptyDiagnostics("hello/hello_x_test.go"),
-		)
-	})
-}
-
-// Reproduce golang/go#40690.
-func TestCreateOnlyXTest(t *testing.T) {
-	const mod = `
--- go.mod --
-module mod.com
--- foo/foo.go --
-package foo
--- foo/bar_test.go --
-`
-	run(t, mod, func(t *testing.T, env *Env) {
-		env.OpenFile("foo/bar_test.go")
-		env.EditBuffer("foo/bar_test.go", fake.NewEdit(0, 0, 0, 0, "package foo"))
-		env.Await(
-			CompletedWork(lsp.DiagnosticWorkTitle(lsp.FromDidChange), 1),
-		)
-		env.RegexpReplace("foo/bar_test.go", "package foo", `package foo_test
-
-import "testing"
-
-func TestX(t *testing.T) {
-	var x int
-}
-`)
-		env.Await(
-			env.DiagnosticAtRegexp("foo/bar_test.go", "x"),
-		)
-	})
-}
-
-func TestChangePackageName(t *testing.T) {
-	t.Skip("This issue hasn't been fixed yet. See golang.org/issue/41061.")
-
-	const mod = `
--- go.mod --
-module mod.com
--- foo/foo.go --
-package foo
--- foo/bar_test.go --
-package foo_
-`
-	run(t, mod, func(t *testing.T, env *Env) {
-		env.OpenFile("foo/bar_test.go")
-		env.RegexpReplace("foo/bar_test.go", "package foo_", "package foo_test")
-		env.SaveBuffer("foo/bar_test.go")
-		env.Await(
-			OnceMet(
-				CompletedWork(lsp.DiagnosticWorkTitle(lsp.FromDidSave), 1),
-				NoDiagnostics("foo/bar_test.go"),
-			),
-			OnceMet(
-				CompletedWork(lsp.DiagnosticWorkTitle(lsp.FromDidSave), 1),
-				NoDiagnostics("foo/foo.go"),
-			),
-		)
-	})
-}
-
-// Reproduces golang/go#40825.
-func TestEmptyGOPATHXTest_40825(t *testing.T) {
-	const files = `
--- x.go --
-package x
--- x_test.go --
-`
-
-	withOptions(InGOPATH()).run(t, files, func(t *testing.T, env *Env) {
-		env.OpenFile("x_test.go")
-		env.EditBuffer("x_test.go", fake.NewEdit(0, 0, 0, 0, "pack"))
-		env.Await(
-			CompletedWork(lsp.DiagnosticWorkTitle(lsp.FromDidChange), 1),
-			NoShowMessage(),
-		)
-	})
-}
-
-func TestIgnoredFiles(t *testing.T) {
-	const ws = `
--- go.mod --
-module mod.com
-
-go 1.15
--- _foo/x.go --
-package x
-
-var _ = foo.Bar
-`
-	runner.Run(t, ws, func(t *testing.T, env *Env) {
-		env.OpenFile("_foo/x.go")
-		env.Await(
-			OnceMet(
-				CompletedWork(lsp.DiagnosticWorkTitle(lsp.FromDidOpen), 1),
-				NoDiagnostics("_foo/x.go"),
-			))
-	})
-}
-
-// Partially reproduces golang/go#38977, moving a file between packages.
-// It also gets hit by some go command bug fixed in 1.15, but we don't
-// care about that so much here.
-func TestDeletePackage(t *testing.T) {
-	const ws = `
--- go.mod --
-module mod.com
-
-go 1.15
--- a/a.go --
-package a
-
-const A = 1
-
--- b/b.go --
-package b
-
-import "mod.com/a"
-
-const B = a.A
-
--- c/c.go --
-package c
-
-import "mod.com/a"
-
-const C = a.A
-`
-	runner.Run(t, ws, func(t *testing.T, env *Env) {
-		env.OpenFile("b/b.go")
-		env.Await(CompletedWork(lsp.DiagnosticWorkTitle(lsp.FromDidOpen), 1))
-		// Delete c/c.go, the only file in package c.
-		env.RemoveWorkspaceFile("c/c.go")
-
-		// We should still get diagnostics for files that exist.
-		env.RegexpReplace("b/b.go", `a.A`, "a.Nonexistant")
-		env.Await(env.DiagnosticAtRegexp("b/b.go", `Nonexistant`))
-	})
-}
-
-// This is a copy of the scenario_default/quickfix_empty_files.txt test from
-// govim. Reproduces golang/go#39646.
-func TestQuickFixEmptyFiles(t *testing.T) {
-	testenv.NeedsGo1Point(t, 15)
-
-	const mod = `
--- go.mod --
-module mod.com
-
-go 1.12
-`
-	// To fully recreate the govim tests, we create files by inserting
-	// a newline, adding to the file, and then deleting the newline.
-	// Wait for each event to process to avoid cancellations and force
-	// package loads.
-	writeGoVim := func(env *Env, name, content string) {
-		env.WriteWorkspaceFile(name, "")
-		env.Await(CompletedWork(lsp.DiagnosticWorkTitle(lsp.FromDidChangeWatchedFiles), 1))
-
-		env.CreateBuffer(name, "\n")
-		env.Await(CompletedWork(lsp.DiagnosticWorkTitle(lsp.FromDidOpen), 1))
-
-		env.EditBuffer(name, fake.NewEdit(1, 0, 1, 0, content))
-		env.Await(CompletedWork(lsp.DiagnosticWorkTitle(lsp.FromDidChange), 1))
-
-		env.EditBuffer(name, fake.NewEdit(0, 0, 1, 0, ""))
-		env.Await(CompletedWork(lsp.DiagnosticWorkTitle(lsp.FromDidChange), 1))
-	}
-
-	const p = `package p; func DoIt(s string) {};`
-	const main = `package main
-
-import "mod.com/p"
-
-func main() {
-	p.DoIt(5)
-}
-`
-	// A simple version of the test that reproduces most of the problems it
-	// exposes.
-	t.Run("short", func(t *testing.T) {
-		runner.Run(t, mod, func(t *testing.T, env *Env) {
-			writeGoVim(env, "p/p.go", p)
-			writeGoVim(env, "main.go", main)
-			env.Await(env.DiagnosticAtRegexp("main.go", "5"))
-		})
-	})
-
-	// A full version that replicates the whole flow of the test.
-	t.Run("full", func(t *testing.T) {
-		runner.Run(t, mod, func(t *testing.T, env *Env) {
-			writeGoVim(env, "p/p.go", p)
-			writeGoVim(env, "main.go", main)
-			writeGoVim(env, "p/p_test.go", `package p
-
-import "testing"
-
-func TestDoIt(t *testing.T) {
-	DoIt(5)
-}
-`)
-			writeGoVim(env, "p/x_test.go", `package p_test
-
-import (
-	"testing"
-
-	"mod.com/p"
-)
-
-func TestDoIt(t *testing.T) {
-	p.DoIt(5)
-}
-`)
-			env.Await(
-				env.DiagnosticAtRegexp("main.go", "5"),
-				env.DiagnosticAtRegexp("p/p_test.go", "5"),
-				env.DiagnosticAtRegexp("p/x_test.go", "5"),
-			)
-			env.RegexpReplace("p/p.go", "s string", "i int")
-			env.Await(
-				EmptyDiagnostics("main.go"),
-				EmptyDiagnostics("p/p_test.go"),
-				EmptyDiagnostics("p/x_test.go"),
-			)
-		})
-	})
-}
-
-func TestSingleFile(t *testing.T) {
-	const mod = `
--- go.mod --
-module mod.com
-
-go 1.13
--- a/a.go --
-package a
-
-func _() {
-	var x int
-}
-`
-	runner.Run(t, mod, func(t *testing.T, env *Env) {
-		env.OpenFile("a/a.go")
-		env.Await(
-			env.DiagnosticAtRegexp("a/a.go", "x"),
-		)
-	}, WithoutWorkspaceFolders())
-}
-
-// Reproduces the case described in
-// https://github.com/golang/go/issues/39296#issuecomment-652058883.
-func TestPkgm(t *testing.T) {
-	const basic = `
--- go.mod --
-module mod.com
-
-go 1.15
--- foo/foo.go --
-package foo
-
-import "fmt"
-
-func Foo() {
-	fmt.Println("")
-}
-`
-	runner.Run(t, basic, func(t *testing.T, env *Env) {
-		testenv.NeedsGo1Point(t, 15)
-
-		env.WriteWorkspaceFile("foo/foo_test.go", `package main
-
-func main() {
-
-}`)
-		env.OpenFile("foo/foo_test.go")
-		env.RegexpReplace("foo/foo_test.go", `package main`, `package foo`)
-		env.Await(
-			OnceMet(
-				CompletedWork(lsp.DiagnosticWorkTitle(lsp.FromDidChange), 1),
-				NoDiagnostics("foo/foo.go"),
-			),
-		)
-	})
-}
-
-func TestClosingBuffer(t *testing.T) {
-	const basic = `
--- go.mod --
-module mod.com
-
-go 1.14
--- main.go --
-package main
-
-func main() {}
-`
-	runner.Run(t, basic, func(t *testing.T, env *Env) {
-		env.Editor.CreateBuffer(env.Ctx, "foo.go", `package main`)
-		env.Await(
-			CompletedWork(lsp.DiagnosticWorkTitle(lsp.FromDidOpen), 1),
-		)
-		env.CloseBuffer("foo.go")
-		env.Await(
-			OnceMet(
-				CompletedWork(lsp.DiagnosticWorkTitle(lsp.FromDidClose), 1),
-				NoLogMatching(protocol.Info, "packages=0"),
-			),
-		)
-	})
-}
-
-// Reproduces golang/go#38424.
-func TestCutAndPaste(t *testing.T) {
-	const basic = `
--- go.mod --
-module mod.com
-
-go 1.14
--- main2.go --
-package main
-`
-	runner.Run(t, basic, func(t *testing.T, env *Env) {
-		env.CreateBuffer("main.go", "")
-		env.Await(CompletedWork(lsp.DiagnosticWorkTitle(lsp.FromDidOpen), 1))
-
-		env.Editor.SaveBufferWithoutActions(env.Ctx, "main.go")
-		env.Await(
-			CompletedWork(lsp.DiagnosticWorkTitle(lsp.FromDidSave), 1),
-			CompletedWork(lsp.DiagnosticWorkTitle(lsp.FromDidChangeWatchedFiles), 1),
-		)
-
-		env.EditBuffer("main.go", fake.NewEdit(0, 0, 0, 0, `package main
-
-func main() {
-}
-`))
-		env.Await(CompletedWork(lsp.DiagnosticWorkTitle(lsp.FromDidChange), 1))
-
-		env.SaveBuffer("main.go")
-		env.Await(
-			CompletedWork(lsp.DiagnosticWorkTitle(lsp.FromDidSave), 2),
-			CompletedWork(lsp.DiagnosticWorkTitle(lsp.FromDidChangeWatchedFiles), 2),
-		)
-
-		env.EditBuffer("main.go", fake.NewEdit(0, 0, 4, 0, ""))
-		env.Await(CompletedWork(lsp.DiagnosticWorkTitle(lsp.FromDidChange), 2))
-
-		env.EditBuffer("main.go", fake.NewEdit(0, 0, 0, 0, `package main
-
-func main() {
-	var x int
-}
-`))
-		env.Await(
-			env.DiagnosticAtRegexp("main.go", "x"),
-		)
-	})
-}
-
-// Reproduces golang/go#39763.
-func TestInvalidPackageName(t *testing.T) {
-	testenv.NeedsGo1Point(t, 15)
-
-	const pkgDefault = `
--- go.mod --
-module mod.com
--- main.go --
-package default
-
-func main() {}
-`
-	runner.Run(t, pkgDefault, func(t *testing.T, env *Env) {
-		env.OpenFile("main.go")
-		env.Await(
-			env.DiagnosticAtRegexp("main.go", "default"),
-		)
-	})
-}
-
-// This tests the functionality of the "limitWorkspaceScope"
-func TestLimitWorkspaceScope(t *testing.T) {
-	const mod = `
--- go.mod --
-module mod.com
--- a/main.go --
-package main
-
-func main() {}
--- main.go --
-package main
-
-func main() {
-	var x int
-}
-`
-	withOptions(WithRootPath("a")).run(t, mod, func(t *testing.T, env *Env) {
-		env.OpenFile("a/main.go")
-		env.Await(
-			env.DiagnosticAtRegexp("main.go", "x"),
-		)
-	})
-	withOptions(WithRootPath("a"), LimitWorkspaceScope()).run(t, mod, func(t *testing.T, env *Env) {
-		env.OpenFile("a/main.go")
-		env.Await(
-			NoDiagnostics("main.go"),
-		)
-	})
-}
-
-func TestStaticcheckDiagnostic(t *testing.T) {
-	const files = `
--- go.mod --
-module mod.com
--- main.go --
-package main
-
-import "fmt"
-
-type t struct {
-	msg string
-}
-
-func main() {
-	x := []t{t{"msg"}}
-	fmt.Println(x)
-}
-`
-
-	withOptions(
-		EditorConfig{EnableStaticcheck: true},
-	).run(t, files, func(t *testing.T, env *Env) {
-		env.OpenFile("main.go")
-		// Staticcheck should generate a diagnostic to simplify this literal.
-		env.Await(env.DiagnosticAtRegexp("main.go", `t{"msg"}`))
-	})
-}
-
-// Test some secondary diagnostics
-func TestSecondaryDiagnostics(t *testing.T) {
-	const dir = `
--- go.mod --
-module mod.com
--- main.go --
-package main
-func main() {
-	panic("not here")
-}
--- other.go --
-package main
-func main() {}
-`
-	runner.Run(t, dir, func(t *testing.T, env *Env) {
-		log.SetFlags(log.Lshortfile)
-		env.OpenFile("main.go")
-		env.OpenFile("other.go")
-		x := env.DiagnosticsFor("main.go")
-		if x == nil {
-			t.Fatalf("expected 1 diagnostic, got none")
-		}
-		if len(x.Diagnostics) != 1 {
-			t.Fatalf("main.go, got %d diagnostics, expected 1", len(x.Diagnostics))
-		}
-		keep := x.Diagnostics[0]
-		y := env.DiagnosticsFor("other.go")
-		if len(y.Diagnostics) != 1 {
-			t.Fatalf("other.go: got %d diagnostics, expected 1", len(y.Diagnostics))
-		}
-		if len(y.Diagnostics[0].RelatedInformation) != 1 {
-			t.Fatalf("got %d RelatedInformations, expected 1", len(y.Diagnostics[0].RelatedInformation))
-		}
-		// check that the RelatedInformation matches the error from main.go
-		c := y.Diagnostics[0].RelatedInformation[0]
-		if c.Location.Range != keep.Range {
-			t.Errorf("locations don't match. Got %v expected %v", c.Location.Range, keep.Range)
-		}
-	})
-}
-
-func TestNotifyOrphanedFiles(t *testing.T) {
-	// Need GO111MODULE=on for this test to work with Go 1.12.
-	testenv.NeedsGo1Point(t, 13)
-
-	const files = `
--- go.mod --
-module mod.com
-
-go 1.12
--- a/a.go --
-package a
-
-func main() {
-	var x int
-}
--- a/a_ignore.go --
-// +build ignore
-
-package a
-
-func _() {
-	var x int
-}
-`
-	run(t, files, func(t *testing.T, env *Env) {
-		env.OpenFile("a/a.go")
-		env.Await(
-			env.DiagnosticAtRegexp("a/a.go", "x"),
-		)
-		env.OpenFile("a/a_ignore.go")
-		env.Await(
-			DiagnosticAt("a/a_ignore.go", 2, 8),
-		)
-	})
-}
-
-func TestEnableAllExperiments(t *testing.T) {
-	const mod = `
--- go.mod --
-module mod.com
-
--- main.go --
-package main
-
-import "bytes"
-
-func b(c bytes.Buffer) {
-	_ = 1
-}
-`
-	withOptions(
-		EditorConfig{
-			AllExperiments: true,
-		},
-	).run(t, mod, func(t *testing.T, env *Env) {
-		// Confirm that the setting doesn't cause any warnings.
-		env.Await(NoShowMessage())
-	})
-}
-
-func TestSwig(t *testing.T) {
-	t.Skipf("skipped until golang/go#37098 is resolved")
-
-	const mod = `
--- go.mod --
-module mod.com
--- pkg/simple/export_swig.go --
-package simple
-
-func ExportSimple(x, y int) int {
-	return Gcd(x, y)
-}
--- pkg/simple/simple.swigcxx --
-%module simple
-
-%inline %{
-extern int gcd(int x, int y)
-{
-  int g;
-  g = y;
-  while (x > 0) {
-    g = x;
-    x = y % x;
-    y = g;
-  }
-  return g;
-}
-%}
--- main.go --
-package a
-
-func main() {
-	var x int
-}
-`
-	run(t, mod, func(t *testing.T, env *Env) {
-		env.Await(
-			OnceMet(
-				InitialWorkspaceLoad,
-				NoDiagnosticWithMessage("", "illegal character U+0023 '#'"),
-			),
-		)
-	})
-}
-
-// When foo_test.go is opened, gopls will object to the borked package name.
-// This test asserts that when the package name is fixed, gopls will soon after
-// have no more complaints about it.
-// https://github.com/golang/go/issues/41061
-func TestRenamePackage(t *testing.T) {
-	t.Skip("Waiting for the fix that makes this pass: https://github.com/golang/go/issues/41061")
-
-	const contents = `
--- go.mod --
-module mod.com
--- foo.go --
-package foo
--- foo_test.go --
-package foo_`
-
-	runner.Run(t, contents, func(t *testing.T, env *Env) {
-		env.OpenFile("foo_test.go")
-		env.RegexpReplace("foo_test.go", "foo_", "foo_test")
-		env.SaveBuffer("foo_test.go")
-		env.Await(
-			EmptyDiagnostics("foo_test.go"),
-		)
-	})
-}
-
-// TestProgressBarErrors confirms that critical workspace load errors are shown
-// and updated via progress reports.
-func TestProgressBarErrors(t *testing.T) {
-	testenv.NeedsGo1Point(t, 14)
-
-	const pkg = `
--- go.mod --
-modul mod.com
-
-go 1.12
--- main.go --
-package main
-`
-	run(t, pkg, func(t *testing.T, env *Env) {
-		env.OpenFile("go.mod")
-		env.Await(
-			OutstandingWork("Error loading workspace", "unknown directive"),
-		)
-		env.EditBuffer("go.mod", fake.NewEdit(0, 0, 3, 0, `module mod.com
-
-go 1.hello
-`))
-		env.Await(
-			OutstandingWork("Error loading workspace", "invalid go version"),
-		)
-		env.RegexpReplace("go.mod", "go 1.hello", "go 1.12")
-		env.Await(
-			NoOutstandingWork(),
-		)
-	})
-}
-
-func TestDeleteDirectory(t *testing.T) {
-	testenv.NeedsGo1Point(t, 14)
-
-	const mod = `
--- bob/bob.go --
-package bob
-
-func Hello() {
-	var x int
-}
--- go.mod --
-module mod.com
--- main.go --
-package main
-
-import "mod.com/bob"
-
-func main() {
-	bob.Hello()
-}
-`
-	run(t, mod, func(t *testing.T, env *Env) {
-		env.RemoveWorkspaceFile("bob")
-		env.Await(
-			env.DiagnosticAtRegexp("main.go", `"mod.com/bob"`),
-			EmptyDiagnostics("bob/bob.go"),
-		)
-	})
-}
-
-// Confirms that circular imports are tested and reported.
-func TestCircularImports(t *testing.T) {
-	const mod = `
--- go.mod --
-module mod.com
-
-go 1.12
--- self/self.go --
-package self
-
-import _ "mod.com/self"
-func Hello() {}
--- double/a/a.go --
-package a
-
-import _ "mod.com/double/b"
--- double/b/b.go --
-package b
-
-import _ "mod.com/double/a"
--- triple/a/a.go --
-package a
-
-import _ "mod.com/triple/b"
--- triple/b/b.go --
-package b
-
-import _ "mod.com/triple/c"
--- triple/c/c.go --
-package c
-
-import _ "mod.com/triple/a"
-`
-	run(t, mod, func(t *testing.T, env *Env) {
-		env.Await(
-			env.DiagnosticAtRegexpWithMessage("self/self.go", `_ "mod.com/self"`, "import cycle not allowed"),
-			env.DiagnosticAtRegexpWithMessage("double/a/a.go", `_ "mod.com/double/b"`, "import cycle not allowed"),
-			env.DiagnosticAtRegexpWithMessage("triple/a/a.go", `_ "mod.com/triple/b"`, "import cycle not allowed"),
-		)
-	})
-}
-
-func TestBadImport(t *testing.T) {
-	testenv.NeedsGo1Point(t, 14)
-
-	const mod = `
--- go.mod --
-module mod.com
-
-go 1.12
--- main.go --
-package main
-
-import (
-	_ "nosuchpkg"
-)
-`
-	t.Run("module", func(t *testing.T) {
-		run(t, mod, func(t *testing.T, env *Env) {
-			env.Await(
-				env.DiagnosticAtRegexpWithMessage("main.go", `"nosuchpkg"`, `could not import nosuchpkg (no required module provides package "nosuchpkg"`),
-			)
-		})
-	})
-	t.Run("GOPATH", func(t *testing.T) {
-		withOptions(
-			InGOPATH(),
-			EditorConfig{
-				Env: map[string]string{"GO111MODULE": "off"},
-			},
-			WithModes(WithoutExperiments),
-		).run(t, mod, func(t *testing.T, env *Env) {
-			env.Await(
-				env.DiagnosticAtRegexpWithMessage("main.go", `"nosuchpkg"`, `cannot find package "nosuchpkg" in any of`),
-			)
-		})
-	})
-}
diff -urN a/gopls/internal/regtest/doc.go b/gopls/internal/regtest/doc.go
--- a/gopls/internal/regtest/doc.go	2000-01-01 00:00:00.000000000 -0000
+++ b/gopls/internal/regtest/doc.go	1969-12-31 19:00:00.000000000 -0500
@@ -1,36 +0,0 @@
-// Copyright 2020 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// Package regtest provides a framework for writing gopls regression tests.
-//
-// User reported regressions are often expressed in terms of editor
-// interactions. For example: "When I open my editor in this directory,
-// navigate to this file, and change this line, I get a diagnostic that doesn't
-// make sense". In these cases reproducing, diagnosing, and writing a test to
-// protect against this regression can be difficult.
-//
-// The regtest package provides an API for developers to express these types of
-// user interactions in ordinary Go tests, validate them, and run them in a
-// variety of execution modes (see gopls/doc/daemon.md for more information on
-// execution modes). This is achieved roughly as follows:
-//  + the Runner type starts and connects to a gopls instance for each
-//    configured execution mode.
-//  + the Env type provides a collection of resources to use in writing tests
-//    (for example a temporary working directory and fake text editor)
-//  + user interactions with these resources are scripted using test wrappers
-//    around the API provided by the golang.org/x/tools/internal/lsp/fake
-//    package.
-//
-// Regressions are expressed in terms of Expectations, which at a high level
-// are conditions that we expect to be met (or not to be met) at some point
-// after performing the interactions in the test. This is necessary because the
-// LSP is by construction asynchronous: both client and server can send
-// eachother notifications without formal acknowledgement that they have been
-// fully processed.
-//
-// Simple Expectations may be combined to match specific conditions reported by
-// the user. In the example above, a regtest validating that the user-reported
-// bug had been fixed would "expect" that the editor never displays the
-// confusing diagnostic.
-package regtest
diff -urN a/gopls/internal/regtest/env.go b/gopls/internal/regtest/env.go
--- a/gopls/internal/regtest/env.go	2000-01-01 00:00:00.000000000 -0000
+++ b/gopls/internal/regtest/env.go	1969-12-31 19:00:00.000000000 -0500
@@ -1,314 +0,0 @@
-// Copyright 2020 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package regtest
-
-import (
-	"context"
-	"fmt"
-	"strings"
-	"sync"
-	"testing"
-
-	"golang.org/x/tools/internal/jsonrpc2/servertest"
-	"golang.org/x/tools/internal/lsp/fake"
-	"golang.org/x/tools/internal/lsp/protocol"
-)
-
-// Env holds an initialized fake Editor, Workspace, and Server, which may be
-// used for writing tests. It also provides adapter methods that call t.Fatal
-// on any error, so that tests for the happy path may be written without
-// checking errors.
-type Env struct {
-	T   *testing.T
-	Ctx context.Context
-
-	// Most tests should not need to access the scratch area, editor, server, or
-	// connection, but they are available if needed.
-	Sandbox *fake.Sandbox
-	Editor  *fake.Editor
-	Server  servertest.Connector
-
-	// mu guards the fields below, for the purpose of checking conditions on
-	// every change to diagnostics.
-	mu sync.Mutex
-	// For simplicity, each waiter gets a unique ID.
-	nextWaiterID int
-	state        State
-	waiters      map[int]*condition
-}
-
-// State encapsulates the server state TODO: explain more
-type State struct {
-	// diagnostics are a map of relative path->diagnostics params
-	diagnostics        map[string]*protocol.PublishDiagnosticsParams
-	logs               []*protocol.LogMessageParams
-	showMessage        []*protocol.ShowMessageParams
-	showMessageRequest []*protocol.ShowMessageRequestParams
-
-	registrations   []*protocol.RegistrationParams
-	unregistrations []*protocol.UnregistrationParams
-
-	// outstandingWork is a map of token->work summary. All tokens are assumed to
-	// be string, though the spec allows for numeric tokens as well.  When work
-	// completes, it is deleted from this map.
-	outstandingWork map[protocol.ProgressToken]*workProgress
-	completedWork   map[string]int
-}
-
-type workProgress struct {
-	title, msg string
-	percent    float64
-}
-
-func (s State) String() string {
-	var b strings.Builder
-	b.WriteString("#### log messages (see RPC logs for full text):\n")
-	for _, msg := range s.logs {
-		summary := fmt.Sprintf("%v: %q", msg.Type, msg.Message)
-		if len(summary) > 60 {
-			summary = summary[:57] + "..."
-		}
-		// Some logs are quite long, and since they should be reproduced in the RPC
-		// logs on any failure we include here just a short summary.
-		fmt.Fprint(&b, "\t"+summary+"\n")
-	}
-	b.WriteString("\n")
-	b.WriteString("#### diagnostics:\n")
-	for name, params := range s.diagnostics {
-		fmt.Fprintf(&b, "\t%s (version %d):\n", name, int(params.Version))
-		for _, d := range params.Diagnostics {
-			fmt.Fprintf(&b, "\t\t(%d, %d): %s\n", int(d.Range.Start.Line), int(d.Range.Start.Character), d.Message)
-		}
-	}
-	b.WriteString("\n")
-	b.WriteString("#### outstanding work:\n")
-	for token, state := range s.outstandingWork {
-		name := state.title
-		if name == "" {
-			name = fmt.Sprintf("!NO NAME(token: %s)", token)
-		}
-		fmt.Fprintf(&b, "\t%s: %.2f\n", name, state.percent)
-	}
-	b.WriteString("#### completed work:\n")
-	for name, count := range s.completedWork {
-		fmt.Fprintf(&b, "\t%s: %d\n", name, count)
-	}
-	return b.String()
-}
-
-// A condition is satisfied when all expectations are simultaneously
-// met. At that point, the 'met' channel is closed. On any failure, err is set
-// and the failed channel is closed.
-type condition struct {
-	expectations []Expectation
-	verdict      chan Verdict
-}
-
-// NewEnv creates a new test environment using the given scratch environment
-// and gopls server.
-func NewEnv(ctx context.Context, t *testing.T, sandbox *fake.Sandbox, ts servertest.Connector, editorConfig fake.EditorConfig, withHooks bool) *Env {
-	t.Helper()
-	conn := ts.Connect(ctx)
-	env := &Env{
-		T:       t,
-		Ctx:     ctx,
-		Sandbox: sandbox,
-		Server:  ts,
-		state: State{
-			diagnostics:     make(map[string]*protocol.PublishDiagnosticsParams),
-			outstandingWork: make(map[protocol.ProgressToken]*workProgress),
-			completedWork:   make(map[string]int),
-		},
-		waiters: make(map[int]*condition),
-	}
-	var hooks fake.ClientHooks
-	if withHooks {
-		hooks = fake.ClientHooks{
-			OnDiagnostics:            env.onDiagnostics,
-			OnLogMessage:             env.onLogMessage,
-			OnWorkDoneProgressCreate: env.onWorkDoneProgressCreate,
-			OnProgress:               env.onProgress,
-			OnShowMessage:            env.onShowMessage,
-			OnShowMessageRequest:     env.onShowMessageRequest,
-			OnRegistration:           env.onRegistration,
-			OnUnregistration:         env.onUnregistration,
-		}
-	}
-	editor, err := fake.NewEditor(sandbox, editorConfig).Connect(ctx, conn, hooks)
-	if err != nil {
-		t.Fatal(err)
-	}
-	env.Editor = editor
-	return env
-}
-
-func (e *Env) onDiagnostics(_ context.Context, d *protocol.PublishDiagnosticsParams) error {
-	e.mu.Lock()
-	defer e.mu.Unlock()
-
-	pth := e.Sandbox.Workdir.URIToPath(d.URI)
-	e.state.diagnostics[pth] = d
-	e.checkConditionsLocked()
-	return nil
-}
-
-func (e *Env) onShowMessage(_ context.Context, m *protocol.ShowMessageParams) error {
-	e.mu.Lock()
-	defer e.mu.Unlock()
-
-	e.state.showMessage = append(e.state.showMessage, m)
-	e.checkConditionsLocked()
-	return nil
-}
-
-func (e *Env) onShowMessageRequest(_ context.Context, m *protocol.ShowMessageRequestParams) error {
-	e.mu.Lock()
-	defer e.mu.Unlock()
-
-	e.state.showMessageRequest = append(e.state.showMessageRequest, m)
-	e.checkConditionsLocked()
-	return nil
-}
-
-func (e *Env) onLogMessage(_ context.Context, m *protocol.LogMessageParams) error {
-	e.mu.Lock()
-	defer e.mu.Unlock()
-
-	e.state.logs = append(e.state.logs, m)
-	e.checkConditionsLocked()
-	return nil
-}
-
-func (e *Env) onWorkDoneProgressCreate(_ context.Context, m *protocol.WorkDoneProgressCreateParams) error {
-	e.mu.Lock()
-	defer e.mu.Unlock()
-
-	e.state.outstandingWork[m.Token] = &workProgress{}
-	return nil
-}
-
-func (e *Env) onProgress(_ context.Context, m *protocol.ProgressParams) error {
-	e.mu.Lock()
-	defer e.mu.Unlock()
-	work, ok := e.state.outstandingWork[m.Token]
-	if !ok {
-		panic(fmt.Sprintf("got progress report for unknown report %v: %v", m.Token, m))
-	}
-	v := m.Value.(map[string]interface{})
-	switch kind := v["kind"]; kind {
-	case "begin":
-		work.title = v["title"].(string)
-		if msg, ok := v["message"]; ok {
-			work.msg = msg.(string)
-		}
-	case "report":
-		if pct, ok := v["percentage"]; ok {
-			work.percent = pct.(float64)
-		}
-		if msg, ok := v["message"]; ok {
-			work.msg = msg.(string)
-		}
-	case "end":
-		title := e.state.outstandingWork[m.Token].title
-		e.state.completedWork[title] = e.state.completedWork[title] + 1
-		delete(e.state.outstandingWork, m.Token)
-	}
-	e.checkConditionsLocked()
-	return nil
-}
-
-func (e *Env) onRegistration(_ context.Context, m *protocol.RegistrationParams) error {
-	e.mu.Lock()
-	defer e.mu.Unlock()
-
-	e.state.registrations = append(e.state.registrations, m)
-	e.checkConditionsLocked()
-	return nil
-}
-
-func (e *Env) onUnregistration(_ context.Context, m *protocol.UnregistrationParams) error {
-	e.mu.Lock()
-	defer e.mu.Unlock()
-
-	e.state.unregistrations = append(e.state.unregistrations, m)
-	e.checkConditionsLocked()
-	return nil
-}
-
-func (e *Env) checkConditionsLocked() {
-	for id, condition := range e.waiters {
-		if v, _ := checkExpectations(e.state, condition.expectations); v != Unmet {
-			delete(e.waiters, id)
-			condition.verdict <- v
-		}
-	}
-}
-
-// checkExpectations reports whether s meets all expectations.
-func checkExpectations(s State, expectations []Expectation) (Verdict, string) {
-	finalVerdict := Met
-	var summary strings.Builder
-	for _, e := range expectations {
-		v := e.Check(s)
-		if v > finalVerdict {
-			finalVerdict = v
-		}
-		summary.WriteString(fmt.Sprintf("\t%v: %s\n", v, e.Description()))
-	}
-	return finalVerdict, summary.String()
-}
-
-// DiagnosticsFor returns the current diagnostics for the file. It is useful
-// after waiting on AnyDiagnosticAtCurrentVersion, when the desired diagnostic
-// is not simply described by DiagnosticAt.
-func (e *Env) DiagnosticsFor(name string) *protocol.PublishDiagnosticsParams {
-	e.mu.Lock()
-	defer e.mu.Unlock()
-	return e.state.diagnostics[name]
-}
-
-// Await waits for all expectations to simultaneously be met. It should only be
-// called from the main test goroutine.
-func (e *Env) Await(expectations ...Expectation) {
-	e.T.Helper()
-	e.mu.Lock()
-	// Before adding the waiter, we check if the condition is currently met or
-	// failed to avoid a race where the condition was realized before Await was
-	// called.
-	switch verdict, summary := checkExpectations(e.state, expectations); verdict {
-	case Met:
-		e.mu.Unlock()
-		return
-	case Unmeetable:
-		e.mu.Unlock()
-		e.T.Fatalf("unmeetable expectations:\n%s\nstate:\n%v", summary, e.state)
-	}
-	cond := &condition{
-		expectations: expectations,
-		verdict:      make(chan Verdict),
-	}
-	e.waiters[e.nextWaiterID] = cond
-	e.nextWaiterID++
-	e.mu.Unlock()
-
-	var err error
-	select {
-	case <-e.Ctx.Done():
-		err = e.Ctx.Err()
-	case v := <-cond.verdict:
-		if v != Met {
-			err = fmt.Errorf("condition has final verdict %v", v)
-		}
-	}
-	e.mu.Lock()
-	defer e.mu.Unlock()
-	_, summary := checkExpectations(e.state, expectations)
-
-	// Debugging an unmet expectation can be tricky, so we put some effort into
-	// nicely formatting the failure.
-	if err != nil {
-		e.T.Fatalf("waiting on:\n%s\nerr:%v\n\nstate:\n%v", summary, err, e.state)
-	}
-}
diff -urN a/gopls/internal/regtest/env_test.go b/gopls/internal/regtest/env_test.go
--- a/gopls/internal/regtest/env_test.go	2000-01-01 00:00:00.000000000 -0000
+++ b/gopls/internal/regtest/env_test.go	1969-12-31 19:00:00.000000000 -0500
@@ -1,67 +0,0 @@
-// Copyright 2020 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package regtest
-
-import (
-	"context"
-	"encoding/json"
-	"testing"
-
-	"golang.org/x/tools/internal/lsp/protocol"
-)
-
-func TestProgressUpdating(t *testing.T) {
-	e := &Env{
-		state: State{
-			outstandingWork: make(map[protocol.ProgressToken]*workProgress),
-			completedWork:   make(map[string]int),
-		},
-	}
-	ctx := context.Background()
-	if err := e.onWorkDoneProgressCreate(ctx, &protocol.WorkDoneProgressCreateParams{
-		Token: "foo",
-	}); err != nil {
-		t.Fatal(err)
-	}
-	if err := e.onWorkDoneProgressCreate(ctx, &protocol.WorkDoneProgressCreateParams{
-		Token: "bar",
-	}); err != nil {
-		t.Fatal(err)
-	}
-	updates := []struct {
-		token string
-		value interface{}
-	}{
-		{"foo", protocol.WorkDoneProgressBegin{Kind: "begin", Title: "foo work"}},
-		{"bar", protocol.WorkDoneProgressBegin{Kind: "begin", Title: "bar work"}},
-		{"foo", protocol.WorkDoneProgressEnd{Kind: "end"}},
-		{"bar", protocol.WorkDoneProgressReport{Kind: "report", Percentage: 42}},
-	}
-	for _, update := range updates {
-		params := &protocol.ProgressParams{
-			Token: update.token,
-			Value: update.value,
-		}
-		data, err := json.Marshal(params)
-		if err != nil {
-			t.Fatal(err)
-		}
-		var unmarshaled protocol.ProgressParams
-		if err := json.Unmarshal(data, &unmarshaled); err != nil {
-			t.Fatal(err)
-		}
-		if err := e.onProgress(ctx, &unmarshaled); err != nil {
-			t.Fatal(err)
-		}
-	}
-	if _, ok := e.state.outstandingWork["foo"]; ok {
-		t.Error("got work entry for \"foo\", want none")
-	}
-	got := *e.state.outstandingWork["bar"]
-	want := workProgress{title: "bar work", percent: 42}
-	if got != want {
-		t.Errorf("work progress for \"bar\": %v, want %v", got, want)
-	}
-}
diff -urN a/gopls/internal/regtest/expectation.go b/gopls/internal/regtest/expectation.go
--- a/gopls/internal/regtest/expectation.go	2000-01-01 00:00:00.000000000 -0000
+++ b/gopls/internal/regtest/expectation.go	1969-12-31 19:00:00.000000000 -0500
@@ -1,547 +0,0 @@
-// Copyright 2020 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package regtest
-
-import (
-	"fmt"
-	"regexp"
-	"strings"
-
-	"golang.org/x/tools/internal/lsp"
-	"golang.org/x/tools/internal/lsp/fake"
-	"golang.org/x/tools/internal/lsp/protocol"
-)
-
-// An Expectation asserts that the state of the editor at a point in time
-// matches an expected condition. This is used for signaling in tests when
-// certain conditions in the editor are met.
-type Expectation interface {
-	// Check determines whether the state of the editor satisfies the
-	// expectation, returning the results that met the condition.
-	Check(State) Verdict
-	// Description is a human-readable description of the expectation.
-	Description() string
-}
-
-var (
-	// InitialWorkspaceLoad is an expectation that the workspace initial load has
-	// completed. It is verified via workdone reporting.
-	InitialWorkspaceLoad = CompletedWork(lsp.DiagnosticWorkTitle(lsp.FromInitialWorkspaceLoad), 1)
-)
-
-// A Verdict is the result of checking an expectation against the current
-// editor state.
-type Verdict int
-
-// Order matters for the following constants: verdicts are sorted in order of
-// decisiveness.
-const (
-	// Met indicates that an expectation is satisfied by the current state.
-	Met Verdict = iota
-	// Unmet indicates that an expectation is not currently met, but could be met
-	// in the future.
-	Unmet
-	// Unmeetable indicates that an expectation cannot be satisfied in the
-	// future.
-	Unmeetable
-)
-
-func (v Verdict) String() string {
-	switch v {
-	case Met:
-		return "Met"
-	case Unmet:
-		return "Unmet"
-	case Unmeetable:
-		return "Unmeetable"
-	}
-	return fmt.Sprintf("unrecognized verdict %d", v)
-}
-
-// SimpleExpectation holds an arbitrary check func, and implements the Expectation interface.
-type SimpleExpectation struct {
-	check       func(State) Verdict
-	description string
-}
-
-// Check invokes e.check.
-func (e SimpleExpectation) Check(s State) Verdict {
-	return e.check(s)
-}
-
-// Description returns e.descriptin.
-func (e SimpleExpectation) Description() string {
-	return e.description
-}
-
-// OnceMet returns an Expectation that, once the precondition is met, asserts
-// that mustMeet is met.
-func OnceMet(precondition Expectation, mustMeet Expectation) *SimpleExpectation {
-	check := func(s State) Verdict {
-		switch pre := precondition.Check(s); pre {
-		case Unmeetable:
-			return Unmeetable
-		case Met:
-			verdict := mustMeet.Check(s)
-			if verdict != Met {
-				return Unmeetable
-			}
-			return Met
-		default:
-			return Unmet
-		}
-	}
-	return &SimpleExpectation{
-		check:       check,
-		description: fmt.Sprintf("once %q is met, must have %q", precondition.Description(), mustMeet.Description()),
-	}
-}
-
-// ReadDiagnostics is an 'expectation' that is used to read diagnostics
-// atomically. It is intended to be used with 'OnceMet'.
-func ReadDiagnostics(fileName string, into *protocol.PublishDiagnosticsParams) *SimpleExpectation {
-	check := func(s State) Verdict {
-		diags, ok := s.diagnostics[fileName]
-		if !ok {
-			return Unmeetable
-		}
-		*into = *diags
-		return Met
-	}
-	return &SimpleExpectation{
-		check:       check,
-		description: fmt.Sprintf("read diagnostics for %q", fileName),
-	}
-}
-
-// NoOutstandingWork asserts that there is no work initiated using the LSP
-// $/progress API that has not completed.
-func NoOutstandingWork() SimpleExpectation {
-	check := func(s State) Verdict {
-		if len(s.outstandingWork) == 0 {
-			return Met
-		}
-		return Unmet
-	}
-	return SimpleExpectation{
-		check:       check,
-		description: "no outstanding work",
-	}
-}
-
-// NoShowMessage asserts that the editor has not received a ShowMessage.
-func NoShowMessage() SimpleExpectation {
-	check := func(s State) Verdict {
-		if len(s.showMessage) == 0 {
-			return Met
-		}
-		return Unmeetable
-	}
-	return SimpleExpectation{
-		check:       check,
-		description: "no ShowMessage received",
-	}
-}
-
-// ShownMessage asserts that the editor has received a ShownMessage with the
-// given title.
-func ShownMessage(title string) SimpleExpectation {
-	check := func(s State) Verdict {
-		for _, m := range s.showMessage {
-			if strings.Contains(m.Message, title) {
-				return Met
-			}
-		}
-		return Unmet
-	}
-	return SimpleExpectation{
-		check:       check,
-		description: "received ShowMessage",
-	}
-}
-
-// ShowMessageRequest asserts that the editor has received a ShowMessageRequest
-// with an action item that has the given title.
-func ShowMessageRequest(title string) SimpleExpectation {
-	check := func(s State) Verdict {
-		if len(s.showMessageRequest) == 0 {
-			return Unmet
-		}
-		// Only check the most recent one.
-		m := s.showMessageRequest[len(s.showMessageRequest)-1]
-		if len(m.Actions) == 0 || len(m.Actions) > 1 {
-			return Unmet
-		}
-		if m.Actions[0].Title == title {
-			return Met
-		}
-		return Unmet
-	}
-	return SimpleExpectation{
-		check:       check,
-		description: "received ShowMessageRequest",
-	}
-}
-
-// CompletedWork expects a work item to have been completed >= atLeast times.
-//
-// Since the Progress API doesn't include any hidden metadata, we must use the
-// progress notification title to identify the work we expect to be completed.
-func CompletedWork(title string, atLeast int) SimpleExpectation {
-	check := func(s State) Verdict {
-		if s.completedWork[title] >= atLeast {
-			return Met
-		}
-		return Unmet
-	}
-	return SimpleExpectation{
-		check:       check,
-		description: fmt.Sprintf("completed work %q at least %d time(s)", title, atLeast),
-	}
-}
-
-// OutstandingWork expects a work item to be outstanding. The given title must
-// be an exact match, whereas the given msg must only be contained in the work
-// item's message.
-func OutstandingWork(title, msg string) SimpleExpectation {
-	check := func(s State) Verdict {
-		for _, work := range s.outstandingWork {
-			if work.title == title && strings.Contains(work.msg, msg) {
-				return Met
-			}
-		}
-		return Unmet
-	}
-	return SimpleExpectation{
-		check:       check,
-		description: fmt.Sprintf("outstanding work: %s", title),
-	}
-}
-
-// LogExpectation is an expectation on the log messages received by the editor
-// from gopls.
-type LogExpectation struct {
-	check       func([]*protocol.LogMessageParams) Verdict
-	description string
-}
-
-// Check implements the Expectation interface.
-func (e LogExpectation) Check(s State) Verdict {
-	return e.check(s.logs)
-}
-
-// Description implements the Expectation interface.
-func (e LogExpectation) Description() string {
-	return e.description
-}
-
-// NoErrorLogs asserts that the client has not received any log messages of
-// error severity.
-func NoErrorLogs() LogExpectation {
-	return NoLogMatching(protocol.Error, "")
-}
-
-// LogMatching asserts that the client has received a log message
-// of type typ matching the regexp re.
-func LogMatching(typ protocol.MessageType, re string, count int) LogExpectation {
-	rec, err := regexp.Compile(re)
-	if err != nil {
-		panic(err)
-	}
-	check := func(msgs []*protocol.LogMessageParams) Verdict {
-		var found int
-		for _, msg := range msgs {
-			if msg.Type == typ && rec.Match([]byte(msg.Message)) {
-				found++
-			}
-		}
-		if found == count {
-			return Met
-		}
-		return Unmet
-	}
-	return LogExpectation{
-		check:       check,
-		description: fmt.Sprintf("log message matching %q", re),
-	}
-}
-
-// NoLogMatching asserts that the client has not received a log message
-// of type typ matching the regexp re. If re is an empty string, any log
-// message is considered a match.
-func NoLogMatching(typ protocol.MessageType, re string) LogExpectation {
-	var r *regexp.Regexp
-	if re != "" {
-		var err error
-		r, err = regexp.Compile(re)
-		if err != nil {
-			panic(err)
-		}
-	}
-	check := func(msgs []*protocol.LogMessageParams) Verdict {
-		for _, msg := range msgs {
-			if msg.Type != typ {
-				continue
-			}
-			if r == nil || r.Match([]byte(msg.Message)) {
-				return Unmeetable
-			}
-		}
-		return Met
-	}
-	return LogExpectation{
-		check:       check,
-		description: fmt.Sprintf("no log message matching %q", re),
-	}
-}
-
-// RegistrationExpectation is an expectation on the capability registrations
-// received by the editor from gopls.
-type RegistrationExpectation struct {
-	check       func([]*protocol.RegistrationParams) Verdict
-	description string
-}
-
-// Check implements the Expectation interface.
-func (e RegistrationExpectation) Check(s State) Verdict {
-	return e.check(s.registrations)
-}
-
-// Description implements the Expectation interface.
-func (e RegistrationExpectation) Description() string {
-	return e.description
-}
-
-// RegistrationMatching asserts that the client has received a capability
-// registration matching the given regexp.
-func RegistrationMatching(re string) RegistrationExpectation {
-	rec, err := regexp.Compile(re)
-	if err != nil {
-		panic(err)
-	}
-	check := func(params []*protocol.RegistrationParams) Verdict {
-		for _, p := range params {
-			for _, r := range p.Registrations {
-				if rec.Match([]byte(r.Method)) {
-					return Met
-				}
-			}
-		}
-		return Unmet
-	}
-	return RegistrationExpectation{
-		check:       check,
-		description: fmt.Sprintf("registration matching %q", re),
-	}
-}
-
-// UnregistrationExpectation is an expectation on the capability
-// unregistrations received by the editor from gopls.
-type UnregistrationExpectation struct {
-	check       func([]*protocol.UnregistrationParams) Verdict
-	description string
-}
-
-// Check implements the Expectation interface.
-func (e UnregistrationExpectation) Check(s State) Verdict {
-	return e.check(s.unregistrations)
-}
-
-// Description implements the Expectation interface.
-func (e UnregistrationExpectation) Description() string {
-	return e.description
-}
-
-// UnregistrationMatching asserts that the client has received an
-// unregistration whose ID matches the given regexp.
-func UnregistrationMatching(re string) UnregistrationExpectation {
-	rec, err := regexp.Compile(re)
-	if err != nil {
-		panic(err)
-	}
-	check := func(params []*protocol.UnregistrationParams) Verdict {
-		for _, p := range params {
-			for _, r := range p.Unregisterations {
-				if rec.Match([]byte(r.Method)) {
-					return Met
-				}
-			}
-		}
-		return Unmet
-	}
-	return UnregistrationExpectation{
-		check:       check,
-		description: fmt.Sprintf("unregistration matching %q", re),
-	}
-}
-
-// A DiagnosticExpectation is a condition that must be met by the current set
-// of diagnostics for a file.
-type DiagnosticExpectation struct {
-	// optionally, the position of the diagnostic and the regex used to calculate it.
-	pos *fake.Pos
-	re  string
-
-	// optionally, the message that the diagnostic should contain.
-	message string
-
-	// whether the expectation is that the diagnostic is present, or absent.
-	present bool
-
-	// path is the scratch workdir-relative path to the file being asserted on.
-	path string
-}
-
-// Check implements the Expectation interface.
-func (e DiagnosticExpectation) Check(s State) Verdict {
-	diags, ok := s.diagnostics[e.path]
-	if !ok {
-		if !e.present {
-			return Met
-		}
-		return Unmet
-	}
-
-	found := false
-	for _, d := range diags.Diagnostics {
-		if e.pos != nil {
-			if d.Range.Start.Line != float64(e.pos.Line) || d.Range.Start.Character != float64(e.pos.Column) {
-				continue
-			}
-		}
-		if e.message != "" {
-			if !strings.Contains(d.Message, e.message) {
-				continue
-			}
-		}
-		found = true
-		break
-	}
-
-	if found == e.present {
-		return Met
-	}
-	return Unmet
-}
-
-// Description implements the Expectation interface.
-func (e DiagnosticExpectation) Description() string {
-	desc := e.path + ":"
-	if !e.present {
-		desc += " no"
-	}
-	desc += " diagnostic"
-	if e.pos != nil {
-		desc += fmt.Sprintf(" at {line:%d, column:%d}", e.pos.Line, e.pos.Column)
-		if e.re != "" {
-			desc += fmt.Sprintf(" (location of %q)", e.re)
-		}
-	}
-	if e.message != "" {
-		desc += fmt.Sprintf(" with message %q", e.message)
-	}
-	return desc
-}
-
-// EmptyDiagnostics asserts that empty diagnostics are sent for the
-// workspace-relative path name.
-func EmptyDiagnostics(name string) Expectation {
-	check := func(s State) Verdict {
-		if diags := s.diagnostics[name]; diags != nil && len(diags.Diagnostics) == 0 {
-			return Met
-		}
-		return Unmet
-	}
-	return SimpleExpectation{
-		check:       check,
-		description: "empty diagnostics",
-	}
-}
-
-// NoDiagnostics asserts that no diagnostics are sent for the
-// workspace-relative path name. It should be used primarily in conjunction
-// with a OnceMet, as it has to check that all outstanding diagnostics have
-// already been delivered.
-func NoDiagnostics(name string) Expectation {
-	check := func(s State) Verdict {
-		if _, ok := s.diagnostics[name]; !ok {
-			return Met
-		}
-		return Unmet
-	}
-	return SimpleExpectation{
-		check:       check,
-		description: "no diagnostics",
-	}
-}
-
-// AnyDiagnosticAtCurrentVersion asserts that there is a diagnostic report for
-// the current edited version of the buffer corresponding to the given
-// workdir-relative pathname.
-func (e *Env) AnyDiagnosticAtCurrentVersion(name string) Expectation {
-	version := e.Editor.BufferVersion(name)
-	check := func(s State) Verdict {
-		diags, ok := s.diagnostics[name]
-		if ok && diags.Version == float64(version) {
-			return Met
-		}
-		return Unmet
-	}
-	return SimpleExpectation{
-		check:       check,
-		description: fmt.Sprintf("any diagnostics at version %d", version),
-	}
-}
-
-// DiagnosticAtRegexp expects that there is a diagnostic entry at the start
-// position matching the regexp search string re in the buffer specified by
-// name. Note that this currently ignores the end position.
-func (e *Env) DiagnosticAtRegexp(name, re string) DiagnosticExpectation {
-	e.T.Helper()
-	pos := e.RegexpSearch(name, re)
-	return DiagnosticExpectation{path: name, pos: &pos, re: re, present: true}
-}
-
-// DiagnosticAtRegexpWithMessage is like DiagnosticAtRegexp, but it also
-// checks for the content of the diagnostic message,
-func (e *Env) DiagnosticAtRegexpWithMessage(name, re, msg string) DiagnosticExpectation {
-	e.T.Helper()
-	pos := e.RegexpSearch(name, re)
-	return DiagnosticExpectation{path: name, pos: &pos, re: re, present: true, message: msg}
-}
-
-// DiagnosticAt asserts that there is a diagnostic entry at the position
-// specified by line and col, for the workdir-relative path name.
-func DiagnosticAt(name string, line, col int) DiagnosticExpectation {
-	return DiagnosticExpectation{path: name, pos: &fake.Pos{Line: line, Column: col}, present: true}
-}
-
-// NoDiagnosticAtRegexp expects that there is no diagnostic entry at the start
-// position matching the regexp search string re in the buffer specified by
-// name. Note that this currently ignores the end position.
-// This should only be used in combination with OnceMet for a given condition,
-// otherwise it may always succeed.
-func (e *Env) NoDiagnosticAtRegexp(name, re string) DiagnosticExpectation {
-	e.T.Helper()
-	pos := e.RegexpSearch(name, re)
-	return DiagnosticExpectation{path: name, pos: &pos, re: re, present: false}
-}
-
-// NoDiagnosticAt asserts that there is no diagnostic entry at the position
-// specified by line and col, for the workdir-relative path name.
-// This should only be used in combination with OnceMet for a given condition,
-// otherwise it may always succeed.
-func NoDiagnosticAt(name string, line, col int) DiagnosticExpectation {
-	return DiagnosticExpectation{path: name, pos: &fake.Pos{Line: line, Column: col}, present: false}
-}
-
-// NoDiagnosticWithMessage asserts that there is no diagnostic entry with the
-// given message.
-//
-// This should only be used in combination with OnceMet for a given condition,
-// otherwise it may always succeed.
-func NoDiagnosticWithMessage(name, msg string) DiagnosticExpectation {
-	return DiagnosticExpectation{path: name, message: msg, present: false}
-}
diff -urN a/gopls/internal/regtest/failures_test.go b/gopls/internal/regtest/failures_test.go
--- a/gopls/internal/regtest/failures_test.go	2000-01-01 00:00:00.000000000 -0000
+++ b/gopls/internal/regtest/failures_test.go	1969-12-31 19:00:00.000000000 -0500
@@ -1,70 +0,0 @@
-// Copyright 2020 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package regtest
-
-import (
-	"log"
-	"testing"
-)
-
-// This test passes (TestHoverOnError in definition_test.go) without
-// the //line directive
-func TestHoverFailure(t *testing.T) {
-	const mod = `
--- go.mod --
-module mod.com
--- a.y --
-DWIM(main)
-
--- main.go --
-//line a.y:1
-package main
-
-func main() {
-	var err error
-	err.Error()
-}`
-	withOptions(SkipLogs()).run(t, mod, func(t *testing.T, env *Env) {
-		env.OpenFile("main.go")
-		content, _ := env.Hover("main.go", env.RegexpSearch("main.go", "Error"))
-		// without the //line comment content would be non-nil
-		if content != nil {
-			t.Fatalf("expected nil hover content for Error")
-		}
-	})
-}
-
-// badPackageDup contains a duplicate definition of the 'a' const.
-// this is from diagnostics_test.go,
-const badPackageDup = `
--- go.mod --
-module mod.com
--- a.go --
-package consts
-
-const a = 1
--- b.go --
-package consts
-//line gen.go:5
-const a = 2
-`
-
-func TestFailingDiagnosticClearingOnEdit(t *testing.T) {
-	runner.Run(t, badPackageDup, func(t *testing.T, env *Env) {
-		log.SetFlags(log.Lshortfile)
-		env.OpenFile("b.go")
-		env.Await(env.AnyDiagnosticAtCurrentVersion("a.go"))
-		// no diagnostics for either b.go or 'gen.go', but there should be
-		env.Await(NoDiagnostics("b.go"))
-
-		// Fix the error by editing the const name in b.go to `b`.
-		env.RegexpReplace("b.go", "(a) = 2", "b")
-		env.Await(
-			EmptyDiagnostics("a.go"),
-			// expected, as there have never been any diagnostics for b.go
-			NoDiagnostics("b.go"),
-		)
-	})
-}
diff -urN a/gopls/internal/regtest/fix_test.go b/gopls/internal/regtest/fix_test.go
--- a/gopls/internal/regtest/fix_test.go	2000-01-01 00:00:00.000000000 -0000
+++ b/gopls/internal/regtest/fix_test.go	1969-12-31 19:00:00.000000000 -0500
@@ -1,64 +0,0 @@
-// Copyright 2020 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package regtest
-
-import (
-	"testing"
-
-	"golang.org/x/tools/internal/lsp/protocol"
-	"golang.org/x/tools/internal/lsp/tests"
-)
-
-// A basic test for fillstruct, now that it uses a command.
-func TestFillStruct(t *testing.T) {
-	const basic = `
--- go.mod --
-module mod.com
-
-go 1.14
--- main.go --
-package main
-
-import "go/types"
-
-func Foo() {
-	_ = types.Info{}
-}
-`
-	runner.Run(t, basic, func(t *testing.T, env *Env) {
-		env.OpenFile("main.go")
-		if err := env.Editor.RefactorRewrite(env.Ctx, "main.go", &protocol.Range{
-			Start: protocol.Position{
-				Line:      5,
-				Character: 16,
-			},
-			End: protocol.Position{
-				Line:      5,
-				Character: 16,
-			},
-		}); err != nil {
-			t.Fatal(err)
-		}
-		want := `package main
-
-import "go/types"
-
-func Foo() {
-	_ = types.Info{
-		Types:      map[ast.Expr]types.TypeAndValue{},
-		Defs:       map[*ast.Ident]types.Object{},
-		Uses:       map[*ast.Ident]types.Object{},
-		Implicits:  map[ast.Node]types.Object{},
-		Selections: map[*ast.SelectorExpr]*types.Selection{},
-		Scopes:     map[ast.Node]*types.Scope{},
-		InitOrder:  []*types.Initializer{},
-	}
-}
-`
-		if got := env.Editor.BufferText("main.go"); got != want {
-			t.Fatalf("TestFillStruct failed:\n%s", tests.Diff(want, got))
-		}
-	})
-}
diff -urN a/gopls/internal/regtest/formatting_test.go b/gopls/internal/regtest/formatting_test.go
--- a/gopls/internal/regtest/formatting_test.go	2000-01-01 00:00:00.000000000 -0000
+++ b/gopls/internal/regtest/formatting_test.go	1969-12-31 19:00:00.000000000 -0500
@@ -1,225 +0,0 @@
-package regtest
-
-import (
-	"strings"
-	"testing"
-
-	"golang.org/x/tools/internal/lsp"
-	"golang.org/x/tools/internal/lsp/tests"
-)
-
-const unformattedProgram = `
--- main.go --
-package main
-import "fmt"
-func main(  ) {
-	fmt.Println("Hello World.")
-}
--- main.go.golden --
-package main
-
-import "fmt"
-
-func main() {
-	fmt.Println("Hello World.")
-}
-`
-
-func TestFormatting(t *testing.T) {
-	runner.Run(t, unformattedProgram, func(t *testing.T, env *Env) {
-		env.OpenFile("main.go")
-		env.FormatBuffer("main.go")
-		got := env.Editor.BufferText("main.go")
-		want := env.ReadWorkspaceFile("main.go.golden")
-		if got != want {
-			t.Errorf("unexpected formatting result:\n%s", tests.Diff(want, got))
-		}
-	})
-}
-
-// Tests golang/go#36824.
-func TestFormattingOneLine36824(t *testing.T) {
-	const onelineProgram = `
--- a.go --
-package main; func f() {}
-
--- a.go.formatted --
-package main
-
-func f() {}
-`
-	runner.Run(t, onelineProgram, func(t *testing.T, env *Env) {
-		env.OpenFile("a.go")
-		env.FormatBuffer("a.go")
-		got := env.Editor.BufferText("a.go")
-		want := env.ReadWorkspaceFile("a.go.formatted")
-		if got != want {
-			t.Errorf("unexpected formatting result:\n%s", tests.Diff(want, got))
-		}
-	})
-}
-
-// Tests golang/go#36824.
-func TestFormattingOneLineImports36824(t *testing.T) {
-	const onelineProgramA = `
--- a.go --
-package x; func f() {fmt.Println()}
-
--- a.go.imported --
-package x
-
-import "fmt"
-
-func f() { fmt.Println() }
-`
-	runner.Run(t, onelineProgramA, func(t *testing.T, env *Env) {
-		env.OpenFile("a.go")
-		env.OrganizeImports("a.go")
-		got := env.Editor.BufferText("a.go")
-		want := env.ReadWorkspaceFile("a.go.imported")
-		if got != want {
-			t.Errorf("unexpected formatting result:\n%s", tests.Diff(want, got))
-		}
-	})
-}
-
-func TestFormattingOneLineRmImports36824(t *testing.T) {
-	const onelineProgramB = `
--- a.go --
-package x; import "os"; func f() {}
-
--- a.go.imported --
-package x
-
-func f() {}
-`
-	runner.Run(t, onelineProgramB, func(t *testing.T, env *Env) {
-		env.OpenFile("a.go")
-		env.OrganizeImports("a.go")
-		got := env.Editor.BufferText("a.go")
-		want := env.ReadWorkspaceFile("a.go.imported")
-		if got != want {
-			t.Errorf("unexpected formatting result:\n%s", tests.Diff(want, got))
-		}
-	})
-}
-
-const disorganizedProgram = `
--- main.go --
-package main
-
-import (
-	"fmt"
-	"errors"
-)
-func main(  ) {
-	fmt.Println(errors.New("bad"))
-}
--- main.go.organized --
-package main
-
-import (
-	"errors"
-	"fmt"
-)
-func main(  ) {
-	fmt.Println(errors.New("bad"))
-}
--- main.go.formatted --
-package main
-
-import (
-	"errors"
-	"fmt"
-)
-
-func main() {
-	fmt.Println(errors.New("bad"))
-}
-`
-
-func TestOrganizeImports(t *testing.T) {
-	runner.Run(t, disorganizedProgram, func(t *testing.T, env *Env) {
-		env.OpenFile("main.go")
-		env.OrganizeImports("main.go")
-		got := env.Editor.BufferText("main.go")
-		want := env.ReadWorkspaceFile("main.go.organized")
-		if got != want {
-			t.Errorf("unexpected formatting result:\n%s", tests.Diff(want, got))
-		}
-	})
-}
-
-func TestFormattingOnSave(t *testing.T) {
-	runner.Run(t, disorganizedProgram, func(t *testing.T, env *Env) {
-		env.OpenFile("main.go")
-		env.SaveBuffer("main.go")
-		got := env.Editor.BufferText("main.go")
-		want := env.ReadWorkspaceFile("main.go.formatted")
-		if got != want {
-			t.Errorf("unexpected formatting result:\n%s", tests.Diff(want, got))
-		}
-	})
-}
-
-// Reproduce golang/go#41057.
-func TestCRLF(t *testing.T) {
-	runner.Run(t, "-- main.go --", func(t *testing.T, env *Env) {
-		want := `package main
-
-/*
-Hi description
-*/
-func Hi() {
-}
-`
-		crlf := strings.ReplaceAll(want, "\n", "\r\n")
-		env.CreateBuffer("main.go", crlf)
-		env.Await(CompletedWork(lsp.DiagnosticWorkTitle(lsp.FromDidOpen), 1))
-		env.SaveBuffer("main.go")
-		got := env.Editor.BufferText("main.go")
-		if want != got {
-			t.Errorf("unexpected content after save:\n%s", tests.Diff(want, got))
-		}
-	})
-}
-
-func TestCRLF_42646(t *testing.T) {
-	runner.Run(t, "-- main.go --", func(t *testing.T, env *Env) {
-		want := `package main
-
-import (
-	"fmt"
-)
-
-/*
-func upload(c echo.Context) error {
-	if err := r.ParseForm(); err != nil {
-		fmt.Fprintf(w, "ParseForm() err: %v", err)
-		return
-	}
-	fmt.Fprintf(w, "POST request successful")
-	path_ver := r.FormValue("path_ver")
-	ukclin_ver := r.FormValue("ukclin_ver")
-
-	fmt.Fprintf(w, "Name = %s\n", path_ver)
-	fmt.Fprintf(w, "Address = %s\n", ukclin_ver)
-}
-*/
-
-func main() {
-	const server_port = 8080
-	fmt.Printf("port: %d\n", server_port)
-}
-`
-		crlf := strings.ReplaceAll(want, "\n", "\r\n")
-		env.CreateBuffer("main.go", crlf)
-		env.Await(CompletedWork(lsp.DiagnosticWorkTitle(lsp.FromDidOpen), 1))
-		env.OrganizeImports("main.go")
-		got := env.Editor.BufferText("main.go")
-		got = strings.ReplaceAll(got, "\r\n", "\n") // convert everything to LF for simplicity
-		if want != got {
-			t.Errorf("unexpected content after save:\n%s", tests.Diff(want, got))
-		}
-	})
-}
diff -urN a/gopls/internal/regtest/generate_test.go b/gopls/internal/regtest/generate_test.go
--- a/gopls/internal/regtest/generate_test.go	2000-01-01 00:00:00.000000000 -0000
+++ b/gopls/internal/regtest/generate_test.go	1969-12-31 19:00:00.000000000 -0500
@@ -1,54 +0,0 @@
-// Copyright 2020 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// TODO(rfindley): figure out why go generate fails on android builders.
-
-// +build !android
-
-package regtest
-
-import (
-	"testing"
-
-	"golang.org/x/tools/internal/lsp"
-)
-
-func TestGenerateProgress(t *testing.T) {
-	const generatedWorkspace = `
--- go.mod --
-module fake.test
-
-go 1.14
--- lib/generate.go --
-// +build ignore
-
-package main
-
-import "io/ioutil"
-
-func main() {
-	ioutil.WriteFile("generated.go", []byte("package lib\n\nconst answer = 42"), 0644)
-}
--- lib/lib.go --
-package lib
-
-func GetAnswer() int {
-	return answer
-}
-
-//go:generate go run generate.go
-`
-
-	runner.Run(t, generatedWorkspace, func(t *testing.T, env *Env) {
-		env.Await(
-			env.DiagnosticAtRegexp("lib/lib.go", "answer"),
-		)
-		env.RunGenerate("./lib")
-		env.Await(
-			OnceMet(
-				CompletedWork(lsp.DiagnosticWorkTitle(lsp.FromDidChangeWatchedFiles), 1),
-				EmptyDiagnostics("lib/lib.go")),
-		)
-	})
-}
diff -urN a/gopls/internal/regtest/imports_test.go b/gopls/internal/regtest/imports_test.go
--- a/gopls/internal/regtest/imports_test.go	2000-01-01 00:00:00.000000000 -0000
+++ b/gopls/internal/regtest/imports_test.go	1969-12-31 19:00:00.000000000 -0500
@@ -1,205 +0,0 @@
-package regtest
-
-import (
-	"io/ioutil"
-	"os"
-	"path/filepath"
-	"strings"
-	"testing"
-
-	"golang.org/x/tools/internal/lsp/protocol"
-	"golang.org/x/tools/internal/testenv"
-)
-
-// Tests golang/go#38815.
-func TestIssue38815(t *testing.T) {
-	const needs = `
--- go.mod --
-module foo
-
--- a.go --
-package main
-func f() {}
-`
-	const ntest = `package main
-func TestZ(t *testing.T) {
-	f()
-}
-`
-	const want = `package main
-
-import "testing"
-
-func TestZ(t *testing.T) {
-	f()
-}
-`
-
-	// it was returning
-	// "package main\nimport \"testing\"\npackage main..."
-	runner.Run(t, needs, func(t *testing.T, env *Env) {
-		env.CreateBuffer("a_test.go", ntest)
-		env.SaveBuffer("a_test.go")
-		got := env.Editor.BufferText("a_test.go")
-		if want != got {
-			t.Errorf("got\n%q, wanted\n%q", got, want)
-		}
-	})
-}
-
-func TestVim1(t *testing.T) {
-	const vim1 = `package main
-
-import "fmt"
-
-var foo = 1
-var bar = 2
-
-func main() {
-	fmt.Printf("This is a test %v\n", foo)
-	fmt.Printf("This is another test %v\n", foo)
-	fmt.Printf("This is also a test %v\n", foo)
-}
-`
-
-	// The file remains unchanged, but if there are any CodeActions returned, they confuse vim.
-	// Therefore check for no CodeActions
-	runner.Run(t, "", func(t *testing.T, env *Env) {
-		env.CreateBuffer("main.go", vim1)
-		env.OrganizeImports("main.go")
-		actions := env.CodeAction("main.go")
-		if len(actions) > 0 {
-			got := env.Editor.BufferText("main.go")
-			t.Errorf("unexpected actions %#v", actions)
-			if got == vim1 {
-				t.Errorf("no changes")
-			} else {
-				t.Errorf("got\n%q", got)
-				t.Errorf("was\n%q", vim1)
-			}
-		}
-	})
-}
-
-func TestVim2(t *testing.T) {
-	const vim2 = `package main
-
-import (
-	"fmt"
-
-	"example.com/blah"
-
-	"rubbish.com/useless"
-)
-
-func main() {
-	fmt.Println(blah.Name, useless.Name)
-}
-`
-
-	runner.Run(t, "", func(t *testing.T, env *Env) {
-		env.CreateBuffer("main.go", vim2)
-		env.OrganizeImports("main.go")
-		actions := env.CodeAction("main.go")
-		if len(actions) > 0 {
-			t.Errorf("unexpected actions %#v", actions)
-		}
-	})
-}
-
-func TestGOMODCACHE(t *testing.T) {
-	const proxy = `
--- example.com@v1.2.3/go.mod --
-module example.com
-
-go 1.12
--- example.com@v1.2.3/x/x.go --
-package x
-
-const X = 1
--- example.com@v1.2.3/y/y.go --
-package y
-
-const Y = 2
-`
-	const files = `
--- go.mod --
-module mod.com
-
-require example.com v1.2.3
-
--- main.go --
-package main
-
-import "example.com/x"
-
-var _, _ = x.X, y.Y
-`
-	testenv.NeedsGo1Point(t, 15)
-
-	modcache, err := ioutil.TempDir("", "TestGOMODCACHE-modcache")
-	if err != nil {
-		t.Fatal(err)
-	}
-	defer os.RemoveAll(modcache)
-	editorConfig := EditorConfig{Env: map[string]string{"GOMODCACHE": modcache}}
-	withOptions(
-		editorConfig,
-		WithProxyFiles(proxy),
-	).run(t, files, func(t *testing.T, env *Env) {
-		env.OpenFile("main.go")
-		env.Await(env.DiagnosticAtRegexp("main.go", `y.Y`))
-		env.SaveBuffer("main.go")
-		env.Await(EmptyDiagnostics("main.go"))
-		path, _ := env.GoToDefinition("main.go", env.RegexpSearch("main.go", `y.(Y)`))
-		if !strings.HasPrefix(path, filepath.ToSlash(modcache)) {
-			t.Errorf("found module dependency outside of GOMODCACHE: got %v, wanted subdir of %v", path, filepath.ToSlash(modcache))
-		}
-	})
-}
-
-// Tests golang/go#40685.
-func TestAcceptImportsQuickFixTestVariant(t *testing.T) {
-	const pkg = `
--- go.mod --
-module mod.com
-
-go 1.12
--- a/a.go --
-package a
-
-import (
-	"fmt"
-)
-
-func _() {
-	fmt.Println("")
-	os.Stat("")
-}
--- a/a_test.go --
-package a
-
-import (
-	"os"
-	"testing"
-)
-
-func TestA(t *testing.T) {
-	os.Stat("")
-}
-`
-	run(t, pkg, func(t *testing.T, env *Env) {
-		env.OpenFile("a/a.go")
-		var d protocol.PublishDiagnosticsParams
-		env.Await(
-			OnceMet(
-				env.DiagnosticAtRegexp("a/a.go", "os.Stat"),
-				ReadDiagnostics("a/a.go", &d),
-			),
-		)
-		env.ApplyQuickFixes("a/a.go", d.Diagnostics)
-		env.Await(
-			EmptyDiagnostics("a/a.go"),
-		)
-	})
-}
diff -urN a/gopls/internal/regtest/link_test.go b/gopls/internal/regtest/link_test.go
--- a/gopls/internal/regtest/link_test.go	2000-01-01 00:00:00.000000000 -0000
+++ b/gopls/internal/regtest/link_test.go	1969-12-31 19:00:00.000000000 -0500
@@ -1,88 +0,0 @@
-// Copyright 2020 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package regtest
-
-import (
-	"strings"
-	"testing"
-
-	"golang.org/x/tools/internal/testenv"
-)
-
-func TestHoverAndDocumentLink(t *testing.T) {
-	testenv.NeedsGo1Point(t, 13)
-	const program = `
--- go.mod --
-module mod.test
-
-go 1.12
-
-require import.test v1.2.3
--- main.go --
-package main
-
-import "import.test/pkg"
-
-func main() {
-	println(pkg.Hello)
-}`
-
-	const proxy = `
--- import.test@v1.2.3/go.mod --
-module import.test
-
-go 1.12
--- import.test@v1.2.3/pkg/const.go --
-package pkg
-
-const Hello = "Hello"
-`
-	runner.Run(t, program, func(t *testing.T, env *Env) {
-		env.OpenFile("main.go")
-		env.OpenFile("go.mod")
-
-		modLink := "https://pkg.go.dev/mod/import.test@v1.2.3?utm_source=gopls"
-		pkgLink := "https://pkg.go.dev/import.test@v1.2.3/pkg?utm_source=gopls"
-
-		// First, check that we get the expected links via hover and documentLink.
-		content, _ := env.Hover("main.go", env.RegexpSearch("main.go", "pkg.Hello"))
-		if content == nil || !strings.Contains(content.Value, pkgLink) {
-			t.Errorf("hover: got %v in main.go, want contains %q", content, pkgLink)
-		}
-		content, _ = env.Hover("go.mod", env.RegexpSearch("go.mod", "import.test"))
-		if content == nil || !strings.Contains(content.Value, pkgLink) {
-			t.Errorf("hover: got %v in go.mod, want contains %q", content, pkgLink)
-		}
-		links := env.DocumentLink("main.go")
-		if len(links) != 1 || links[0].Target != pkgLink {
-			t.Errorf("documentLink: got %v for main.go, want link to %q", links, pkgLink)
-		}
-		links = env.DocumentLink("go.mod")
-		if len(links) != 1 || links[0].Target != modLink {
-			t.Errorf("documentLink: got %v for go.mod, want link to %q", links, modLink)
-		}
-
-		// Then change the environment to make these links private.
-		env.ChangeEnv(map[string]string{"GOPRIVATE": "import.test"})
-
-		// Finally, verify that the links are gone.
-		content, _ = env.Hover("main.go", env.RegexpSearch("main.go", "pkg.Hello"))
-		if content == nil || strings.Contains(content.Value, pkgLink) {
-			t.Errorf("hover: got %v in main.go, want non-empty hover without %q", content, pkgLink)
-		}
-		content, _ = env.Hover("go.mod", env.RegexpSearch("go.mod", "import.test"))
-		if content == nil || strings.Contains(content.Value, modLink) {
-			t.Errorf("hover: got %v in go.mod, want contains %q", content, modLink)
-		}
-		links = env.DocumentLink("main.go")
-		if len(links) != 0 {
-			t.Errorf("documentLink: got %d document links for main.go, want 0\nlinks: %v", len(links), links)
-		}
-		links = env.DocumentLink("go.mod")
-		if len(links) != 0 {
-			t.Errorf("documentLink: got %d document links for go.mod, want 0\nlinks: %v", len(links), links)
-		}
-	}, WithProxyFiles(proxy))
-}
diff -urN a/gopls/internal/regtest/modfile_test.go b/gopls/internal/regtest/modfile_test.go
--- a/gopls/internal/regtest/modfile_test.go	2000-01-01 00:00:00.000000000 -0000
+++ b/gopls/internal/regtest/modfile_test.go	1969-12-31 19:00:00.000000000 -0500
@@ -1,652 +0,0 @@
-// Copyright 2020 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package regtest
-
-import (
-	"strings"
-	"testing"
-
-	"golang.org/x/tools/internal/lsp"
-	"golang.org/x/tools/internal/lsp/protocol"
-	"golang.org/x/tools/internal/lsp/tests"
-	"golang.org/x/tools/internal/testenv"
-)
-
-const proxy = `
--- example.com@v1.2.3/go.mod --
-module example.com
-
-go 1.12
--- example.com@v1.2.3/blah/blah.go --
-package blah
-
-const Name = "Blah"
--- random.org@v1.2.3/go.mod --
-module random.org
-
-go 1.12
--- random.org@v1.2.3/blah/blah.go --
-package hello
-
-const Name = "Hello"
-`
-
-func runModfileTest(t *testing.T, files, proxy string, f TestFunc) {
-	t.Run("normal", func(t *testing.T) {
-		withOptions(WithProxyFiles(proxy)).run(t, files, f)
-	})
-	t.Run("nested", func(t *testing.T) {
-		withOptions(WithProxyFiles(proxy), NestWorkdir(), WithModes(Singleton|Experimental)).run(t, files, f)
-	})
-}
-
-func TestModFileModification(t *testing.T) {
-	testenv.NeedsGo1Point(t, 14)
-
-	const untidyModule = `
--- go.mod --
-module mod.com
-
--- main.go --
-package main
-
-import "example.com/blah"
-
-func main() {
-	println(blah.Name)
-}
-`
-	t.Run("basic", func(t *testing.T) {
-		runModfileTest(t, untidyModule, proxy, func(t *testing.T, env *Env) {
-			// Open the file and make sure that the initial workspace load does not
-			// modify the go.mod file.
-			goModContent := env.ReadWorkspaceFile("go.mod")
-			env.OpenFile("main.go")
-			env.Await(
-				env.DiagnosticAtRegexp("main.go", "\"example.com/blah\""),
-			)
-			if got := env.ReadWorkspaceFile("go.mod"); got != goModContent {
-				t.Fatalf("go.mod changed on disk:\n%s", tests.Diff(goModContent, got))
-			}
-			// Save the buffer, which will format and organize imports.
-			// Confirm that the go.mod file still does not change.
-			env.SaveBuffer("main.go")
-			env.Await(
-				env.DiagnosticAtRegexp("main.go", "\"example.com/blah\""),
-			)
-			if got := env.ReadWorkspaceFile("go.mod"); got != goModContent {
-				t.Fatalf("go.mod changed on disk:\n%s", tests.Diff(goModContent, got))
-			}
-		})
-	})
-
-	// Reproduce golang/go#40269 by deleting and recreating main.go.
-	t.Run("delete main.go", func(t *testing.T) {
-		t.Skip("This test will be flaky until golang/go#40269 is resolved.")
-
-		runModfileTest(t, untidyModule, proxy, func(t *testing.T, env *Env) {
-			goModContent := env.ReadWorkspaceFile("go.mod")
-			mainContent := env.ReadWorkspaceFile("main.go")
-			env.OpenFile("main.go")
-			env.SaveBuffer("main.go")
-
-			env.RemoveWorkspaceFile("main.go")
-			env.Await(
-				CompletedWork(lsp.DiagnosticWorkTitle(lsp.FromDidOpen), 1),
-				CompletedWork(lsp.DiagnosticWorkTitle(lsp.FromDidSave), 1),
-				CompletedWork(lsp.DiagnosticWorkTitle(lsp.FromDidChangeWatchedFiles), 2),
-			)
-
-			env.WriteWorkspaceFile("main.go", mainContent)
-			env.Await(
-				env.DiagnosticAtRegexp("main.go", "\"example.com/blah\""),
-			)
-			if got := env.ReadWorkspaceFile("go.mod"); got != goModContent {
-				t.Fatalf("go.mod changed on disk:\n%s", tests.Diff(goModContent, got))
-			}
-		})
-	})
-}
-
-// Tests that multiple missing dependencies gives good single fixes.
-func TestMissingDependencyFixes(t *testing.T) {
-	testenv.NeedsGo1Point(t, 14)
-	const mod = `
--- go.mod --
-module mod.com
-
-go 1.12
-
--- main.go --
-package main
-
-import "example.com/blah"
-import "random.org/blah"
-
-var _, _ = blah.Name, hello.Name
-`
-
-	const want = `module mod.com
-
-go 1.12
-
-require random.org v1.2.3
-`
-
-	runModfileTest(t, mod, proxy, func(t *testing.T, env *Env) {
-		env.OpenFile("main.go")
-		var d protocol.PublishDiagnosticsParams
-		env.Await(
-			OnceMet(
-				env.DiagnosticAtRegexp("main.go", `"random.org/blah"`),
-				ReadDiagnostics("main.go", &d),
-			),
-		)
-		var randomDiag protocol.Diagnostic
-		for _, diag := range d.Diagnostics {
-			if strings.Contains(diag.Message, "random.org") {
-				randomDiag = diag
-			}
-		}
-		env.ApplyQuickFixes("main.go", []protocol.Diagnostic{randomDiag})
-		if got := env.ReadWorkspaceFile("go.mod"); got != want {
-			t.Fatalf("unexpected go.mod content:\n%s", tests.Diff(want, got))
-		}
-	})
-}
-
-func TestIndirectDependencyFix(t *testing.T) {
-	testenv.NeedsGo1Point(t, 14)
-
-	const mod = `
--- go.mod --
-module mod.com
-
-go 1.12
-
-require example.com v1.2.3 // indirect
--- main.go --
-package main
-
-import "example.com/blah"
-
-func main() {
-	fmt.Println(blah.Name)
-`
-	const want = `module mod.com
-
-go 1.12
-
-require example.com v1.2.3
-`
-	runModfileTest(t, mod, proxy, func(t *testing.T, env *Env) {
-		env.OpenFile("go.mod")
-		var d protocol.PublishDiagnosticsParams
-		env.Await(
-			OnceMet(
-				env.DiagnosticAtRegexp("go.mod", "// indirect"),
-				ReadDiagnostics("go.mod", &d),
-			),
-		)
-		env.ApplyQuickFixes("go.mod", d.Diagnostics)
-		if got := env.Editor.BufferText("go.mod"); got != want {
-			t.Fatalf("unexpected go.mod content:\n%s", tests.Diff(want, got))
-		}
-	})
-}
-
-func TestUnusedDiag(t *testing.T) {
-	testenv.NeedsGo1Point(t, 14)
-
-	const proxy = `
--- example.com@v1.0.0/x.go --
-package pkg
-const X = 1
-`
-	const files = `
--- go.mod --
-module mod.com
-go 1.14
-require example.com v1.0.0
-
--- main.go --
-package main
-func main() {}
-`
-
-	const want = `module mod.com
-
-go 1.14
-`
-
-	runModfileTest(t, files, proxy, func(t *testing.T, env *Env) {
-		env.OpenFile("go.mod")
-		var d protocol.PublishDiagnosticsParams
-		env.Await(
-			OnceMet(
-				env.DiagnosticAtRegexp("go.mod", `require example.com`),
-				ReadDiagnostics("go.mod", &d),
-			),
-		)
-		env.ApplyQuickFixes("go.mod", d.Diagnostics)
-		if got := env.ReadWorkspaceFile("go.mod"); got != want {
-			t.Fatalf("unexpected go.mod content:\n%s", tests.Diff(want, got))
-		}
-	})
-}
-
-// Test to reproduce golang/go#39041. It adds a new require to a go.mod file
-// that already has an unused require.
-func TestNewDepWithUnusedDep(t *testing.T) {
-	testenv.NeedsGo1Point(t, 14)
-
-	const proxy = `
--- github.com/esimov/caire@v1.2.5/go.mod --
-module github.com/esimov/caire
-
-go 1.12
--- github.com/esimov/caire@v1.2.5/caire.go --
-package caire
-
-func RemoveTempImage() {}
--- google.golang.org/protobuf@v1.20.0/go.mod --
-module google.golang.org/protobuf
-
-go 1.12
--- google.golang.org/protobuf@v1.20.0/hello/hello.go --
-package hello
-`
-	const repro = `
--- go.mod --
-module mod.com
-
-go 1.14
-
-require google.golang.org/protobuf v1.20.0
--- main.go --
-package main
-
-import (
-    "github.com/esimov/caire"
-)
-
-func _() {
-    caire.RemoveTempImage()
-}`
-	runModfileTest(t, repro, proxy, func(t *testing.T, env *Env) {
-		env.OpenFile("main.go")
-		var d protocol.PublishDiagnosticsParams
-		env.Await(
-			OnceMet(
-				env.DiagnosticAtRegexp("main.go", `"github.com/esimov/caire"`),
-				ReadDiagnostics("main.go", &d),
-			),
-		)
-		env.ApplyQuickFixes("main.go", d.Diagnostics)
-		want := `module mod.com
-
-go 1.14
-
-require (
-	github.com/esimov/caire v1.2.5
-	google.golang.org/protobuf v1.20.0
-)
-`
-		if got := env.ReadWorkspaceFile("go.mod"); got != want {
-			t.Fatalf("TestNewDepWithUnusedDep failed:\n%s", tests.Diff(want, got))
-		}
-	})
-}
-
-// TODO: For this test to be effective, the sandbox's file watcher must respect
-// the file watching GlobPattern in the capability registration. See
-// golang/go#39384.
-func TestModuleChangesOnDisk(t *testing.T) {
-	testenv.NeedsGo1Point(t, 14)
-
-	const mod = `
--- go.mod --
-module mod.com
-
-go 1.12
-
-require example.com v1.2.3
--- main.go --
-package main
-
-func main() {
-	fmt.Println(blah.Name)
-`
-	runModfileTest(t, mod, proxy, func(t *testing.T, env *Env) {
-		env.Await(env.DiagnosticAtRegexp("go.mod", "require"))
-		env.RunGoCommand("mod", "tidy")
-		env.Await(
-			EmptyDiagnostics("go.mod"),
-		)
-	})
-}
-
-// Tests golang/go#39784: a missing indirect dependency, necessary
-// due to blah@v2.0.0's incomplete go.mod file.
-func TestBadlyVersionedModule(t *testing.T) {
-	testenv.NeedsGo1Point(t, 14)
-
-	const proxy = `
--- example.com/blah/@v/v1.0.0.mod --
-module example.com
-
-go 1.12
--- example.com/blah@v1.0.0/blah.go --
-package blah
-
-const Name = "Blah"
--- example.com/blah/v2/@v/v2.0.0.mod --
-module example.com
-
-go 1.12
--- example.com/blah/v2@v2.0.0/blah.go --
-package blah
-
-import "example.com/blah"
-
-var _ = blah.Name
-const Name = "Blah"
-`
-	const files = `
--- go.mod --
-module mod.com
-
-go 1.12
-
-require example.com/blah/v2 v2.0.0
--- main.go --
-package main
-
-import "example.com/blah/v2"
-
-var _ = blah.Name
-`
-	withOptions(WithProxyFiles(proxy)).run(t, files, func(t *testing.T, env *Env) {
-		env.OpenFile("main.go")
-		env.OpenFile("go.mod")
-		var d protocol.PublishDiagnosticsParams
-		env.Await(
-			OnceMet(
-				DiagnosticAt("go.mod", 0, 0),
-				ReadDiagnostics("go.mod", &d),
-			),
-		)
-		env.ApplyQuickFixes("main.go", d.Diagnostics)
-		const want = `module mod.com
-
-go 1.12
-
-require (
-	example.com/blah v1.0.0 // indirect
-	example.com/blah/v2 v2.0.0
-)
-`
-		env.Await(EmptyDiagnostics("go.mod"))
-		if got := env.Editor.BufferText("go.mod"); got != want {
-			t.Fatalf("suggested fixes failed:\n%s", tests.Diff(want, got))
-		}
-	})
-}
-
-// Reproduces golang/go#38232.
-func TestUnknownRevision(t *testing.T) {
-	testenv.NeedsGo1Point(t, 14)
-
-	const unknown = `
--- go.mod --
-module mod.com
-
-require (
-	example.com v1.2.2
-)
--- main.go --
-package main
-
-import "example.com/blah"
-
-func main() {
-	var x = blah.Name
-}
-`
-
-	// Start from a bad state/bad IWL, and confirm that we recover.
-	t.Run("bad", func(t *testing.T) {
-		runModfileTest(t, unknown, proxy, func(t *testing.T, env *Env) {
-			env.OpenFile("go.mod")
-			env.Await(
-				env.DiagnosticAtRegexp("go.mod", "example.com v1.2.2"),
-			)
-			env.RegexpReplace("go.mod", "v1.2.2", "v1.2.3")
-			env.Editor.SaveBufferWithoutActions(env.Ctx, "go.mod") // go.mod changes must be on disk
-			env.Await(
-				env.DiagnosticAtRegexp("main.go", "x = "),
-			)
-		})
-	})
-
-	const known = `
--- go.mod --
-module mod.com
-
-require (
-	example.com v1.2.3
-)
--- main.go --
-package main
-
-import "example.com/blah"
-
-func main() {
-	var x = blah.Name
-}
-`
-	// Start from a good state, transform to a bad state, and confirm that we
-	// still recover.
-	t.Run("good", func(t *testing.T) {
-		runModfileTest(t, known, proxy, func(t *testing.T, env *Env) {
-			env.OpenFile("go.mod")
-			env.Await(
-				env.DiagnosticAtRegexp("main.go", "x = "),
-			)
-			env.RegexpReplace("go.mod", "v1.2.3", "v1.2.2")
-			env.Editor.SaveBufferWithoutActions(env.Ctx, "go.mod") // go.mod changes must be on disk
-			env.Await(
-				env.DiagnosticAtRegexp("go.mod", "example.com v1.2.2"),
-			)
-			env.RegexpReplace("go.mod", "v1.2.2", "v1.2.3")
-			env.Editor.SaveBufferWithoutActions(env.Ctx, "go.mod") // go.mod changes must be on disk
-			env.Await(
-				env.DiagnosticAtRegexp("main.go", "x = "),
-			)
-		})
-	})
-}
-
-// Confirm that an error in an indirect dependency of a requirement is surfaced
-// as a diagnostic in the go.mod file.
-func TestErrorInIndirectDependency(t *testing.T) {
-	testenv.NeedsGo1Point(t, 14)
-
-	const badProxy = `
--- example.com@v1.2.3/go.mod --
-module example.com
-
-go 1.12
-
-require random.org v1.2.3 // indirect
--- example.com@v1.2.3/blah/blah.go --
-package blah
-
-const Name = "Blah"
--- random.org@v1.2.3/go.mod --
-module bob.org
-
-go 1.12
--- random.org@v1.2.3/blah/blah.go --
-package hello
-
-const Name = "Hello"
-`
-	const module = `
--- go.mod --
-module mod.com
-
-go 1.14
-
-require example.com v1.2.3
--- main.go --
-package main
-
-import "example.com/blah"
-
-func main() {
-	println(blah.Name)
-}
-`
-	runModfileTest(t, module, badProxy, func(t *testing.T, env *Env) {
-		env.OpenFile("go.mod")
-		env.Await(
-			env.DiagnosticAtRegexp("go.mod", "require example.com v1.2.3"),
-		)
-	})
-}
-
-// A copy of govim's config_set_env_goflags_mod_readonly test.
-func TestGovimModReadonly(t *testing.T) {
-	const mod = `
--- go.mod --
-module mod.com
-
-go 1.13
--- main.go --
-package main
-
-import "example.com/blah"
-
-func main() {
-	println(blah.Name)
-}
-`
-	withOptions(
-		EditorConfig{
-			Env: map[string]string{
-				"GOFLAGS": "-mod=readonly",
-			},
-		},
-		WithProxyFiles(proxy),
-		WithModes(WithoutExperiments),
-	).run(t, mod, func(t *testing.T, env *Env) {
-		env.OpenFile("main.go")
-		original := env.ReadWorkspaceFile("go.mod")
-		env.Await(
-			env.DiagnosticAtRegexp("main.go", `"example.com/blah"`),
-		)
-		got := env.ReadWorkspaceFile("go.mod")
-		if got != original {
-			t.Fatalf("go.mod file modified:\n%s", tests.Diff(original, got))
-		}
-		env.RunGoCommand("get", "example.com/blah@v1.2.3")
-		env.RunGoCommand("mod", "tidy")
-		env.Await(
-			EmptyDiagnostics("main.go"),
-		)
-	})
-}
-
-func TestMultiModuleModDiagnostics(t *testing.T) {
-	testenv.NeedsGo1Point(t, 14)
-
-	const mod = `
--- a/go.mod --
-module mod.com
-
-go 1.14
-
-require (
-	example.com v1.2.3
-)
--- a/main.go --
-package main
-
-func main() {}
--- b/go.mod --
-module mod.com
-
-go 1.14
--- b/main.go --
-package main
-
-import "example.com/blah"
-
-func main() {
-	blah.SaySomething()
-}
-`
-	withOptions(
-		WithProxyFiles(workspaceProxy),
-		WithModes(Experimental),
-	).run(t, mod, func(t *testing.T, env *Env) {
-		env.Await(
-			env.DiagnosticAtRegexp("a/go.mod", "example.com v1.2.3"),
-			env.DiagnosticAtRegexp("b/go.mod", "module mod.com"),
-		)
-	})
-}
-
-func TestModTidyWithBuildTags(t *testing.T) {
-	testenv.NeedsGo1Point(t, 14)
-
-	const mod = `
--- go.mod --
-module mod.com
-
-go 1.14
--- main.go --
-// +build bob
-
-package main
-
-import "example.com/blah"
-
-func main() {
-	blah.SaySomething()
-}
-`
-	withOptions(
-		WithProxyFiles(workspaceProxy),
-		EditorConfig{
-			BuildFlags: []string{"-tags", "bob"},
-		},
-	).run(t, mod, func(t *testing.T, env *Env) {
-		env.Await(
-			env.DiagnosticAtRegexp("main.go", `"example.com/blah"`),
-		)
-	})
-}
-
-func TestModTypoDiagnostic(t *testing.T) {
-	const mod = `
--- go.mod --
-module mod.com
-
-go 1.12
--- main.go --
-package main
-
-func main() {}
-`
-	run(t, mod, func(t *testing.T, env *Env) {
-		env.OpenFile("go.mod")
-		env.RegexpReplace("go.mod", "module", "modul")
-		env.Await(
-			env.DiagnosticAtRegexp("go.mod", "modul"),
-		)
-	})
-}
diff -urN a/gopls/internal/regtest/references_test.go b/gopls/internal/regtest/references_test.go
--- a/gopls/internal/regtest/references_test.go	2000-01-01 00:00:00.000000000 -0000
+++ b/gopls/internal/regtest/references_test.go	1969-12-31 19:00:00.000000000 -0500
@@ -1,41 +0,0 @@
-// Copyright 2020 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package regtest
-
-import (
-	"testing"
-)
-
-func TestStdlibReferences(t *testing.T) {
-	const files = `
--- go.mod --
-module mod.com
-
--- main.go --
-package main
-
-import "fmt"
-
-func main() {
-	fmt.Print()
-}
-`
-
-	run(t, files, func(t *testing.T, env *Env) {
-		env.OpenFile("main.go")
-		file, pos := env.GoToDefinition("main.go", env.RegexpSearch("main.go", `fmt.(Print)`))
-		refs, err := env.Editor.References(env.Ctx, file, pos)
-		if err != nil {
-			t.Fatal(err)
-		}
-		if len(refs) != 2 {
-			t.Fatalf("got %v reference(s), want 2", len(refs))
-		}
-		// The first reference is guaranteed to be the definition.
-		if got, want := refs[1].URI, env.Sandbox.Workdir.URI("main.go"); got != want {
-			t.Errorf("found reference in %v, wanted %v", got, want)
-		}
-	})
-}
diff -urN a/gopls/internal/regtest/reg_test.go b/gopls/internal/regtest/reg_test.go
--- a/gopls/internal/regtest/reg_test.go	2000-01-01 00:00:00.000000000 -0000
+++ b/gopls/internal/regtest/reg_test.go	1969-12-31 19:00:00.000000000 -0500
@@ -1,91 +0,0 @@
-// Copyright 2020 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package regtest
-
-import (
-	"context"
-	"flag"
-	"fmt"
-	"io/ioutil"
-	"os"
-	"runtime"
-	"testing"
-	"time"
-
-	"golang.org/x/tools/internal/lsp/cmd"
-	"golang.org/x/tools/internal/testenv"
-	"golang.org/x/tools/internal/tool"
-)
-
-var (
-	runSubprocessTests       = flag.Bool("enable_gopls_subprocess_tests", false, "run regtests against a gopls subprocess")
-	goplsBinaryPath          = flag.String("gopls_test_binary", "", "path to the gopls binary for use as a remote, for use with the -enable_gopls_subprocess_tests flag")
-	regtestTimeout           = flag.Duration("regtest_timeout", 20*time.Second, "default timeout for each regtest")
-	skipCleanup              = flag.Bool("regtest_skip_cleanup", false, "whether to skip cleaning up temp directories")
-	printGoroutinesOnFailure = flag.Bool("regtest_print_goroutines", false, "whether to print goroutines info on failure")
-)
-
-var runner *Runner
-
-func run(t *testing.T, files string, f TestFunc) {
-	runner.Run(t, files, f)
-}
-
-func withOptions(opts ...RunOption) configuredRunner {
-	return configuredRunner{opts: opts}
-}
-
-type configuredRunner struct {
-	opts []RunOption
-}
-
-func (r configuredRunner) run(t *testing.T, files string, f TestFunc) {
-	runner.Run(t, files, f, r.opts...)
-}
-
-func TestMain(m *testing.M) {
-	flag.Parse()
-	if os.Getenv("_GOPLS_TEST_BINARY_RUN_AS_GOPLS") == "true" {
-		tool.Main(context.Background(), cmd.New("gopls", "", nil, nil), os.Args[1:])
-		os.Exit(0)
-	}
-
-	runner = &Runner{
-		DefaultModes:             NormalModes,
-		Timeout:                  *regtestTimeout,
-		PrintGoroutinesOnFailure: *printGoroutinesOnFailure,
-		SkipCleanup:              *skipCleanup,
-	}
-	if *runSubprocessTests {
-		goplsPath := *goplsBinaryPath
-		if goplsPath == "" {
-			var err error
-			goplsPath, err = os.Executable()
-			if err != nil {
-				panic(fmt.Sprintf("finding test binary path: %v", err))
-			}
-		}
-		runner.DefaultModes = NormalModes | SeparateProcess
-		runner.GoplsPath = goplsPath
-	}
-	dir, err := ioutil.TempDir("", "gopls-regtest-")
-	if err != nil {
-		panic(fmt.Errorf("creating regtest temp directory: %v", err))
-	}
-	runner.TempDir = dir
-
-	code := m.Run()
-	if err := runner.Close(); err != nil {
-		fmt.Fprintf(os.Stderr, "closing test runner: %v\n", err)
-		// Regtest cleanup is broken in go1.12 and earlier, and sometimes flakes on
-		// Windows due to file locking, but this is OK for our CI.
-		//
-		// Fail on non-windows go1.13+.
-		if testenv.Go1Point() >= 13 && runtime.GOOS != "windows" {
-			os.Exit(1)
-		}
-	}
-	os.Exit(code)
-}
diff -urN a/gopls/internal/regtest/runner.go b/gopls/internal/regtest/runner.go
--- a/gopls/internal/regtest/runner.go	2000-01-01 00:00:00.000000000 -0000
+++ b/gopls/internal/regtest/runner.go	1969-12-31 19:00:00.000000000 -0500
@@ -1,487 +0,0 @@
-// Copyright 2020 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package regtest
-
-import (
-	"bytes"
-	"context"
-	"fmt"
-	"io"
-	"io/ioutil"
-	"net"
-	"os"
-	"os/exec"
-	"path/filepath"
-	"runtime/pprof"
-	"strings"
-	"sync"
-	"testing"
-	"time"
-
-	"golang.org/x/tools/gopls/internal/hooks"
-	"golang.org/x/tools/internal/jsonrpc2"
-	"golang.org/x/tools/internal/jsonrpc2/servertest"
-	"golang.org/x/tools/internal/lsp/cache"
-	"golang.org/x/tools/internal/lsp/debug"
-	"golang.org/x/tools/internal/lsp/fake"
-	"golang.org/x/tools/internal/lsp/lsprpc"
-	"golang.org/x/tools/internal/lsp/protocol"
-	"golang.org/x/tools/internal/lsp/source"
-)
-
-// Mode is a bitmask that defines for which execution modes a test should run.
-type Mode int
-
-const (
-	// Singleton mode uses a separate in-process gopls instance for each test,
-	// and communicates over pipes to mimic the gopls sidecar execution mode,
-	// which communicates over stdin/stderr.
-	Singleton Mode = 1 << iota
-	// Forwarded forwards connections to a shared in-process gopls instance.
-	Forwarded
-	// SeparateProcess forwards connection to a shared separate gopls process.
-	SeparateProcess
-	// Experimental enables all of the experimental configurations that are
-	// being developed. Currently, it enables the workspace module.
-	Experimental
-	// WithoutExperiments are the modes that run without experimental features,
-	// like the workspace module. These should be used for tests that only work
-	// in the default modes.
-	WithoutExperiments = Singleton | Forwarded
-	// NormalModes are the global default execution modes, when unmodified by
-	// test flags or by individual test options.
-	NormalModes = Singleton | Experimental
-)
-
-// A Runner runs tests in gopls execution environments, as specified by its
-// modes. For modes that share state (for example, a shared cache or common
-// remote), any tests that execute on the same Runner will share the same
-// state.
-type Runner struct {
-	DefaultModes             Mode
-	Timeout                  time.Duration
-	GoplsPath                string
-	PrintGoroutinesOnFailure bool
-	TempDir                  string
-	SkipCleanup              bool
-
-	mu        sync.Mutex
-	ts        *servertest.TCPServer
-	socketDir string
-	// closers is a queue of clean-up functions to run at the end of the entire
-	// test suite.
-	closers []io.Closer
-}
-
-type runConfig struct {
-	editor      fake.EditorConfig
-	sandbox     fake.SandboxConfig
-	modes       Mode
-	timeout     time.Duration
-	debugAddr   string
-	skipLogs    bool
-	skipHooks   bool
-	nestWorkdir bool
-}
-
-func (r *Runner) defaultConfig() *runConfig {
-	return &runConfig{
-		modes:   r.DefaultModes,
-		timeout: r.Timeout,
-	}
-}
-
-// A RunOption augments the behavior of the test runner.
-type RunOption interface {
-	set(*runConfig)
-}
-
-type optionSetter func(*runConfig)
-
-func (f optionSetter) set(opts *runConfig) {
-	f(opts)
-}
-
-// WithTimeout configures a custom timeout for this test run.
-func WithTimeout(d time.Duration) RunOption {
-	return optionSetter(func(opts *runConfig) {
-		opts.timeout = d
-	})
-}
-
-// WithProxyFiles configures a file proxy using the given txtar-encoded string.
-func WithProxyFiles(txt string) RunOption {
-	return optionSetter(func(opts *runConfig) {
-		opts.sandbox.ProxyFiles = txt
-	})
-}
-
-// WithModes configures the execution modes that the test should run in.
-func WithModes(modes Mode) RunOption {
-	return optionSetter(func(opts *runConfig) {
-		opts.modes = modes
-	})
-}
-
-func SendPID() RunOption {
-	return optionSetter(func(opts *runConfig) {
-		opts.editor.SendPID = true
-	})
-}
-
-// EditorConfig is a RunOption option that configured the regtest editor.
-type EditorConfig fake.EditorConfig
-
-func (c EditorConfig) set(opts *runConfig) {
-	opts.editor = fake.EditorConfig(c)
-}
-
-// WithoutWorkspaceFolders prevents workspace folders from being sent as part
-// of the sandbox's initialization. It is used to simulate opening a single
-// file in the editor, without a workspace root. In that case, the client sends
-// neither workspace folders nor a root URI.
-func WithoutWorkspaceFolders() RunOption {
-	return optionSetter(func(opts *runConfig) {
-		opts.editor.WithoutWorkspaceFolders = true
-	})
-}
-
-// WithRootPath specifies the rootURI of the workspace folder opened in the
-// editor. By default, the sandbox opens the top-level directory, but some
-// tests need to check other cases.
-func WithRootPath(path string) RunOption {
-	return optionSetter(func(opts *runConfig) {
-		opts.editor.WorkspaceRoot = path
-	})
-}
-
-// InGOPATH configures the workspace working directory to be GOPATH, rather
-// than a separate working directory for use with modules.
-func InGOPATH() RunOption {
-	return optionSetter(func(opts *runConfig) {
-		opts.sandbox.InGoPath = true
-	})
-}
-
-// WithDebugAddress configures a debug server bound to addr. This option is
-// currently only supported when executing in Singleton mode. It is intended to
-// be used for long-running stress tests.
-func WithDebugAddress(addr string) RunOption {
-	return optionSetter(func(opts *runConfig) {
-		opts.debugAddr = addr
-	})
-}
-
-// SkipLogs skips the buffering of logs during test execution. It is intended
-// for long-running stress tests.
-func SkipLogs() RunOption {
-	return optionSetter(func(opts *runConfig) {
-		opts.skipLogs = true
-	})
-}
-
-// InExistingDir runs the test in a pre-existing directory. If set, no initial
-// files may be passed to the runner. It is intended for long-running stress
-// tests.
-func InExistingDir(dir string) RunOption {
-	return optionSetter(func(opts *runConfig) {
-		opts.sandbox.Workdir = dir
-	})
-}
-
-// SkipHooks allows for disabling the test runner's client hooks that are used
-// for instrumenting expectations (tracking diagnostics, logs, work done,
-// etc.). It is intended for performance-sensitive stress tests or benchmarks.
-func SkipHooks(skip bool) RunOption {
-	return optionSetter(func(opts *runConfig) {
-		opts.skipHooks = skip
-	})
-}
-
-// WithGOPROXY configures the test environment to have an explicit proxy value.
-// This is intended for stress tests -- to ensure their isolation, regtests
-// should instead use WithProxyFiles.
-func WithGOPROXY(goproxy string) RunOption {
-	return optionSetter(func(opts *runConfig) {
-		opts.sandbox.GOPROXY = goproxy
-	})
-}
-
-// LimitWorkspaceScope sets the LimitWorkspaceScope configuration.
-func LimitWorkspaceScope() RunOption {
-	return optionSetter(func(opts *runConfig) {
-		opts.editor.LimitWorkspaceScope = true
-	})
-}
-
-// NestWorkdir inserts the sandbox working directory in a subdirectory of the
-// editor workspace.
-func NestWorkdir() RunOption {
-	return optionSetter(func(opts *runConfig) {
-		opts.nestWorkdir = true
-	})
-}
-
-type TestFunc func(t *testing.T, env *Env)
-
-// Run executes the test function in the default configured gopls execution
-// modes. For each a test run, a new workspace is created containing the
-// un-txtared files specified by filedata.
-func (r *Runner) Run(t *testing.T, files string, test TestFunc, opts ...RunOption) {
-	t.Helper()
-
-	if os.Getenv("GO_BUILDER_NAME") == "openbsd-amd64-64" && testing.Short() {
-		t.Skip("Skipping openbsd-amd64-64 due to golang.org/issues/42789.")
-	}
-
-	tests := []struct {
-		name      string
-		mode      Mode
-		getServer func(context.Context, *testing.T) jsonrpc2.StreamServer
-	}{
-		{"singleton", Singleton, singletonServer},
-		{"forwarded", Forwarded, r.forwardedServer},
-		{"separate_process", SeparateProcess, r.separateProcessServer},
-		{"experimental_workspace_module", Experimental, experimentalWorkspaceModule},
-	}
-
-	for _, tc := range tests {
-		tc := tc
-		config := r.defaultConfig()
-		for _, opt := range opts {
-			opt.set(config)
-		}
-		if config.modes&tc.mode == 0 {
-			continue
-		}
-		if config.debugAddr != "" && tc.mode != Singleton {
-			// Debugging is useful for running stress tests, but since the daemon has
-			// likely already been started, it would be too late to debug.
-			t.Fatalf("debugging regtest servers only works in Singleton mode, "+
-				"got debug addr %q and mode %v", config.debugAddr, tc.mode)
-		}
-
-		t.Run(tc.name, func(t *testing.T) {
-			ctx, cancel := context.WithTimeout(context.Background(), config.timeout)
-			defer cancel()
-			ctx = debug.WithInstance(ctx, "", "off")
-			if config.debugAddr != "" {
-				di := debug.GetInstance(ctx)
-				di.DebugAddress = config.debugAddr
-				di.Serve(ctx)
-				di.MonitorMemory(ctx)
-			}
-
-			rootDir := filepath.Join(r.TempDir, filepath.FromSlash(t.Name()))
-			if err := os.MkdirAll(rootDir, 0755); err != nil {
-				t.Fatal(err)
-			}
-			if config.nestWorkdir {
-				config.sandbox.Workdir = "work/nested"
-			}
-			config.sandbox.Files = files
-			config.sandbox.RootDir = rootDir
-			sandbox, err := fake.NewSandbox(&config.sandbox)
-			if err != nil {
-				t.Fatal(err)
-			}
-			workdir := sandbox.Workdir.RootURI().SpanURI().Filename()
-			if config.nestWorkdir {
-				// Now that we know the actual workdir, set our workspace to be the
-				// parent directory.
-				config.editor.WorkspaceRoot = filepath.Clean(filepath.Join(workdir, ".."))
-			}
-			// Deferring the closure of ws until the end of the entire test suite
-			// has, in testing, given the LSP server time to properly shutdown and
-			// release any file locks held in workspace, which is a problem on
-			// Windows. This may still be flaky however, and in the future we need a
-			// better solution to ensure that all Go processes started by gopls have
-			// exited before we clean up.
-			r.AddCloser(sandbox)
-			ss := tc.getServer(ctx, t)
-			framer := jsonrpc2.NewRawStream
-			ls := &loggingFramer{}
-			if !config.skipLogs {
-				framer = ls.framer(jsonrpc2.NewRawStream)
-			}
-			ts := servertest.NewPipeServer(ctx, ss, framer)
-			env := NewEnv(ctx, t, sandbox, ts, config.editor, !config.skipHooks)
-			defer func() {
-				if t.Failed() && r.PrintGoroutinesOnFailure {
-					pprof.Lookup("goroutine").WriteTo(os.Stderr, 1)
-				}
-				if t.Failed() || testing.Verbose() {
-					ls.printBuffers(t.Name(), os.Stderr)
-				}
-				env.CloseEditor()
-			}()
-			// Always await the initial workspace load.
-			env.Await(InitialWorkspaceLoad)
-			test(t, env)
-		})
-	}
-}
-
-type loggingFramer struct {
-	mu  sync.Mutex
-	buf *safeBuffer
-}
-
-// safeBuffer is a threadsafe buffer for logs.
-type safeBuffer struct {
-	mu  sync.Mutex
-	buf bytes.Buffer
-}
-
-func (b *safeBuffer) Write(p []byte) (int, error) {
-	b.mu.Lock()
-	defer b.mu.Unlock()
-	return b.buf.Write(p)
-}
-
-func (s *loggingFramer) framer(f jsonrpc2.Framer) jsonrpc2.Framer {
-	return func(nc net.Conn) jsonrpc2.Stream {
-		s.mu.Lock()
-		framed := false
-		if s.buf == nil {
-			s.buf = &safeBuffer{buf: bytes.Buffer{}}
-			framed = true
-		}
-		s.mu.Unlock()
-		stream := f(nc)
-		if framed {
-			return protocol.LoggingStream(stream, s.buf)
-		}
-		return stream
-	}
-}
-
-func (s *loggingFramer) printBuffers(testname string, w io.Writer) {
-	s.mu.Lock()
-	defer s.mu.Unlock()
-
-	if s.buf == nil {
-		return
-	}
-	fmt.Fprintf(os.Stderr, "#### Start Gopls Test Logs for %q\n", testname)
-	s.buf.mu.Lock()
-	io.Copy(w, &s.buf.buf)
-	s.buf.mu.Unlock()
-	fmt.Fprintf(os.Stderr, "#### End Gopls Test Logs for %q\n", testname)
-}
-
-func singletonServer(ctx context.Context, t *testing.T) jsonrpc2.StreamServer {
-	return lsprpc.NewStreamServer(cache.New(ctx, hooks.Options), false)
-}
-
-func experimentalWorkspaceModule(ctx context.Context, t *testing.T) jsonrpc2.StreamServer {
-	options := func(o *source.Options) {
-		hooks.Options(o)
-		o.ExperimentalWorkspaceModule = true
-	}
-	return lsprpc.NewStreamServer(cache.New(ctx, options), false)
-}
-
-func (r *Runner) forwardedServer(ctx context.Context, t *testing.T) jsonrpc2.StreamServer {
-	ts := r.getTestServer()
-	return lsprpc.NewForwarder("tcp", ts.Addr)
-}
-
-// getTestServer gets the shared test server instance to connect to, or creates
-// one if it doesn't exist.
-func (r *Runner) getTestServer() *servertest.TCPServer {
-	r.mu.Lock()
-	defer r.mu.Unlock()
-	if r.ts == nil {
-		ctx := context.Background()
-		ctx = debug.WithInstance(ctx, "", "off")
-		ss := lsprpc.NewStreamServer(cache.New(ctx, hooks.Options), false)
-		r.ts = servertest.NewTCPServer(ctx, ss, nil)
-	}
-	return r.ts
-}
-
-func (r *Runner) separateProcessServer(ctx context.Context, t *testing.T) jsonrpc2.StreamServer {
-	// TODO(rfindley): can we use the autostart behavior here, instead of
-	// pre-starting the remote?
-	socket := r.getRemoteSocket(t)
-	return lsprpc.NewForwarder("unix", socket)
-}
-
-// runTestAsGoplsEnvvar triggers TestMain to run gopls instead of running
-// tests. It's a trick to allow tests to find a binary to use to start a gopls
-// subprocess.
-const runTestAsGoplsEnvvar = "_GOPLS_TEST_BINARY_RUN_AS_GOPLS"
-
-func (r *Runner) getRemoteSocket(t *testing.T) string {
-	t.Helper()
-	r.mu.Lock()
-	defer r.mu.Unlock()
-	const daemonFile = "gopls-test-daemon"
-	if r.socketDir != "" {
-		return filepath.Join(r.socketDir, daemonFile)
-	}
-
-	if r.GoplsPath == "" {
-		t.Fatal("cannot run tests with a separate process unless a path to a gopls binary is configured")
-	}
-	var err error
-	r.socketDir, err = ioutil.TempDir(r.TempDir, "gopls-regtest-socket")
-	if err != nil {
-		t.Fatalf("creating tempdir: %v", err)
-	}
-	socket := filepath.Join(r.socketDir, daemonFile)
-	args := []string{"serve", "-listen", "unix;" + socket, "-listen.timeout", "10s"}
-	cmd := exec.Command(r.GoplsPath, args...)
-	cmd.Env = append(os.Environ(), runTestAsGoplsEnvvar+"=true")
-	var stderr bytes.Buffer
-	cmd.Stderr = &stderr
-	go func() {
-		if err := cmd.Run(); err != nil {
-			panic(fmt.Sprintf("error running external gopls: %v\nstderr:\n%s", err, stderr.String()))
-		}
-	}()
-	return socket
-}
-
-// AddCloser schedules a closer to be closed at the end of the test run. This
-// is useful for Windows in particular, as
-func (r *Runner) AddCloser(closer io.Closer) {
-	r.mu.Lock()
-	defer r.mu.Unlock()
-	r.closers = append(r.closers, closer)
-}
-
-// Close cleans up resource that have been allocated to this workspace.
-func (r *Runner) Close() error {
-	r.mu.Lock()
-	defer r.mu.Unlock()
-
-	var errmsgs []string
-	if r.ts != nil {
-		if err := r.ts.Close(); err != nil {
-			errmsgs = append(errmsgs, err.Error())
-		}
-	}
-	if r.socketDir != "" {
-		if err := os.RemoveAll(r.socketDir); err != nil {
-			errmsgs = append(errmsgs, err.Error())
-		}
-	}
-	if !r.SkipCleanup {
-		for _, closer := range r.closers {
-			if err := closer.Close(); err != nil {
-				errmsgs = append(errmsgs, err.Error())
-			}
-		}
-		if err := os.RemoveAll(r.TempDir); err != nil {
-			errmsgs = append(errmsgs, err.Error())
-		}
-	}
-	if len(errmsgs) > 0 {
-		return fmt.Errorf("errors closing the test runner:\n\t%s", strings.Join(errmsgs, "\n\t"))
-	}
-	return nil
-}
diff -urN a/gopls/internal/regtest/shared_test.go b/gopls/internal/regtest/shared_test.go
--- a/gopls/internal/regtest/shared_test.go	2000-01-01 00:00:00.000000000 -0000
+++ b/gopls/internal/regtest/shared_test.go	1969-12-31 19:00:00.000000000 -0500
@@ -1,59 +0,0 @@
-// Copyright 2020 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package regtest
-
-import (
-	"testing"
-)
-
-const sharedProgram = `
--- go.mod --
-module mod
-
-go 1.12
--- main.go --
-package main
-
-import "fmt"
-
-func main() {
-	fmt.Println("Hello World.")
-}`
-
-func runShared(t *testing.T, program string, testFunc func(env1 *Env, env2 *Env)) {
-	// Only run these tests in forwarded modes.
-	modes := runner.DefaultModes & (Forwarded | SeparateProcess)
-	runner.Run(t, sharedProgram, func(t *testing.T, env1 *Env) {
-		// Create a second test session connected to the same workspace and server
-		// as the first.
-		env2 := NewEnv(env1.Ctx, t, env1.Sandbox, env1.Server, env1.Editor.Config, true)
-		testFunc(env1, env2)
-	}, WithModes(modes))
-}
-
-func TestSimultaneousEdits(t *testing.T) {
-	runShared(t, exampleProgram, func(env1 *Env, env2 *Env) {
-		// In editor #1, break fmt.Println as before.
-		env1.OpenFile("main.go")
-		env1.RegexpReplace("main.go", "Printl(n)", "")
-		// In editor #2 remove the closing brace.
-		env2.OpenFile("main.go")
-		env2.RegexpReplace("main.go", "\\)\n(})", "")
-
-		// Now check that we got different diagnostics in each environment.
-		env1.Await(env1.DiagnosticAtRegexp("main.go", "Printl"))
-		env2.Await(env2.DiagnosticAtRegexp("main.go", "$"))
-	})
-}
-
-func TestShutdown(t *testing.T) {
-	runShared(t, sharedProgram, func(env1 *Env, env2 *Env) {
-		env1.CloseEditor()
-		// Now make an edit in editor #2 to trigger diagnostics.
-		env2.OpenFile("main.go")
-		env2.RegexpReplace("main.go", "\\)\n(})", "")
-		env2.Await(env2.DiagnosticAtRegexp("main.go", "$"))
-	})
-}
diff -urN a/gopls/internal/regtest/stress_test.go b/gopls/internal/regtest/stress_test.go
--- a/gopls/internal/regtest/stress_test.go	2000-01-01 00:00:00.000000000 -0000
+++ b/gopls/internal/regtest/stress_test.go	1969-12-31 19:00:00.000000000 -0500
@@ -1,82 +0,0 @@
-// Copyright 2020 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package regtest
-
-import (
-	"context"
-	"flag"
-	"fmt"
-	"testing"
-	"time"
-)
-
-// Pilosa is a repository that has historically caused significant memory
-// problems for Gopls. We use it for a simple stress test that types
-// arbitrarily in a file with lots of dependents.
-
-var pilosaPath = flag.String("pilosa_path", "", "Path to a directory containing "+
-	"github.com/pilosa/pilosa, for stress testing. Do not set this unless you "+
-	"know what you're doing!")
-
-func stressTestOptions(dir string) []RunOption {
-	return []RunOption{
-		// Run in an existing directory, since we're trying to simulate known cases
-		// that cause gopls memory problems.
-		InExistingDir(dir),
-
-		// Enable live debugging.
-		WithDebugAddress(":8087"),
-
-		// Skip logs as they buffer up memory unnaturally.
-		SkipLogs(),
-		// Similarly to logs: disable hooks so that they don't affect performance.
-		SkipHooks(true),
-		// The Debug server only makes sense if running in singleton mode.
-		WithModes(Singleton),
-		// Set a generous timeout. Individual tests should control their own
-		// graceful termination.
-		WithTimeout(20 * time.Minute),
-
-		// Use the actual proxy, since we want our builds to succeed.
-		WithGOPROXY("https://proxy.golang.org"),
-	}
-}
-
-func TestPilosaStress(t *testing.T) {
-	if *pilosaPath == "" {
-		t.Skip("-pilosa_path not configured")
-	}
-	opts := stressTestOptions(*pilosaPath)
-
-	withOptions(opts...).run(t, "", func(t *testing.T, env *Env) {
-		files := []string{
-			"cmd.go",
-			"internal/private.pb.go",
-			"roaring/roaring.go",
-			"roaring/roaring_internal_test.go",
-			"server/handler_test.go",
-		}
-		for _, file := range files {
-			env.OpenFile(file)
-		}
-		ctx, cancel := context.WithTimeout(env.Ctx, 10*time.Minute)
-		defer cancel()
-
-		i := 1
-		// MagicNumber is an identifier that occurs in roaring.go. Just change it
-		// arbitrarily.
-		env.RegexpReplace("roaring/roaring.go", "MagicNumber", fmt.Sprintf("MagicNumber%d", 1))
-		for {
-			select {
-			case <-ctx.Done():
-				return
-			default:
-			}
-			env.RegexpReplace("roaring/roaring.go", fmt.Sprintf("MagicNumber%d", i), fmt.Sprintf("MagicNumber%d", i+1))
-			time.Sleep(20 * time.Millisecond)
-			i++
-		}
-	})
-}
diff -urN a/gopls/internal/regtest/unix_test.go b/gopls/internal/regtest/unix_test.go
--- a/gopls/internal/regtest/unix_test.go	2000-01-01 00:00:00.000000000 -0000
+++ b/gopls/internal/regtest/unix_test.go	1969-12-31 19:00:00.000000000 -0500
@@ -1,32 +0,0 @@
-// Copyright 2020 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// +build !windows,!plan9
-
-package regtest
-
-import (
-	"testing"
-)
-
-func TestBadGOPATH(t *testing.T) {
-	const files = `
--- main.go --
-package main
-
-func _() {
-	fmt.Println("Hello World")
-}
-`
-	// https://github.com/fatih/vim-go/issues/2673#issuecomment-622307211.
-	withOptions(
-		EditorConfig{Env: map[string]string{"GOPATH": ":/path/to/gopath"}},
-	).run(t, files, func(t *testing.T, env *Env) {
-		env.OpenFile("main.go")
-		env.Await(env.DiagnosticAtRegexp("main.go", "fmt"))
-		if err := env.Editor.OrganizeImports(env.Ctx, "main.go"); err != nil {
-			t.Fatal(err)
-		}
-	})
-}
diff -urN a/gopls/internal/regtest/vendor_test.go b/gopls/internal/regtest/vendor_test.go
--- a/gopls/internal/regtest/vendor_test.go	2000-01-01 00:00:00.000000000 -0000
+++ b/gopls/internal/regtest/vendor_test.go	1969-12-31 19:00:00.000000000 -0500
@@ -1,75 +0,0 @@
-package regtest
-
-import (
-	"testing"
-
-	"golang.org/x/tools/internal/lsp"
-	"golang.org/x/tools/internal/lsp/protocol"
-	"golang.org/x/tools/internal/lsp/source"
-	"golang.org/x/tools/internal/testenv"
-)
-
-const basicProxy = `
--- golang.org/x/hello@v1.2.3/go.mod --
-module golang.org/x/hello
-
-go 1.14
--- golang.org/x/hello@v1.2.3/hi/hi.go --
-package hi
-
-var Goodbye error
-`
-
-func TestInconsistentVendoring(t *testing.T) {
-	testenv.NeedsGo1Point(t, 14)
-
-	const pkgThatUsesVendoring = `
--- go.mod --
-module mod.com
-
-go 1.14
-
-require golang.org/x/hello v1.2.3
--- vendor/modules.txt --
--- a/a1.go --
-package a
-
-import "golang.org/x/hello/hi"
-
-func _() {
-	_ = hi.Goodbye
-	var q int // hardcode a diagnostic
-}
-`
-	// TODO(rstambler): Remove this when golang/go#41819 is resolved.
-	withOptions(
-		WithModes(WithoutExperiments),
-		WithProxyFiles(basicProxy),
-	).run(t, pkgThatUsesVendoring, func(t *testing.T, env *Env) {
-		env.OpenFile("a/a1.go")
-		env.Await(
-			// The editor should pop up a message suggesting that the user
-			// run `go mod vendor`, along with a button to do so.
-			// By default, the fake editor always accepts such suggestions,
-			// so once we see the request, we can assume that `go mod vendor`
-			// will be executed.
-			OnceMet(
-				CompletedWork(lsp.DiagnosticWorkTitle(lsp.FromDidOpen), 1),
-				env.DiagnosticAtRegexp("go.mod", "module mod.com"),
-			),
-		)
-		// Apply the quickfix associated with the diagnostic.
-		d := &protocol.PublishDiagnosticsParams{}
-		env.Await(ReadDiagnostics("go.mod", d))
-		env.ApplyQuickFixes("go.mod", d.Diagnostics)
-
-		// Check for file changes when the command completes.
-		env.Await(CompletedWork(source.CommandVendor.Title, 1))
-		env.CheckForFileChanges()
-
-		// Confirm that there is no longer any inconsistent vendoring.
-		env.Await(
-			DiagnosticAt("a/a1.go", 6, 5),
-		)
-	})
-}
diff -urN a/gopls/internal/regtest/watch_test.go b/gopls/internal/regtest/watch_test.go
--- a/gopls/internal/regtest/watch_test.go	2000-01-01 00:00:00.000000000 -0000
+++ b/gopls/internal/regtest/watch_test.go	1969-12-31 19:00:00.000000000 -0500
@@ -1,755 +0,0 @@
-// Copyright 2020 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package regtest
-
-import (
-	"testing"
-
-	"golang.org/x/tools/internal/lsp"
-	"golang.org/x/tools/internal/lsp/fake"
-	"golang.org/x/tools/internal/lsp/protocol"
-	"golang.org/x/tools/internal/testenv"
-)
-
-func TestEditFile(t *testing.T) {
-	const pkg = `
--- go.mod --
-module mod.com
-
-go 1.14
--- a/a.go --
-package a
-
-func _() {
-	var x int
-}
-`
-	// Edit the file when it's *not open* in the workspace, and check that
-	// diagnostics are updated.
-	t.Run("unopened", func(t *testing.T) {
-		runner.Run(t, pkg, func(t *testing.T, env *Env) {
-			env.Await(
-				env.DiagnosticAtRegexp("a/a.go", "x"),
-			)
-			env.WriteWorkspaceFile("a/a.go", `package a; func _() {};`)
-			env.Await(
-				EmptyDiagnostics("a/a.go"),
-			)
-		})
-	})
-
-	// Edit the file when it *is open* in the workspace, and check that
-	// diagnostics are *not* updated.
-	t.Run("opened", func(t *testing.T) {
-		runner.Run(t, pkg, func(t *testing.T, env *Env) {
-			env.OpenFile("a/a.go")
-			// Insert a trivial edit so that we don't automatically update the buffer
-			// (see CL 267577).
-			env.EditBuffer("a/a.go", fake.NewEdit(0, 0, 0, 0, " "))
-			env.Await(CompletedWork(lsp.DiagnosticWorkTitle(lsp.FromDidOpen), 1))
-			env.WriteWorkspaceFile("a/a.go", `package a; func _() {};`)
-			env.Await(
-				OnceMet(
-					CompletedWork(lsp.DiagnosticWorkTitle(lsp.FromDidChangeWatchedFiles), 1),
-					env.DiagnosticAtRegexp("a/a.go", "x"),
-				))
-		})
-	})
-}
-
-// Edit a dependency on disk and expect a new diagnostic.
-func TestEditDependency(t *testing.T) {
-	const pkg = `
--- go.mod --
-module mod.com
-
-go 1.14
--- b/b.go --
-package b
-
-func B() int { return 0 }
--- a/a.go --
-package a
-
-import (
-	"mod.com/b"
-)
-
-func _() {
-	_ = b.B()
-}
-`
-	runner.Run(t, pkg, func(t *testing.T, env *Env) {
-		env.OpenFile("a/a.go")
-		env.Await(CompletedWork(lsp.DiagnosticWorkTitle(lsp.FromDidOpen), 1))
-		env.WriteWorkspaceFile("b/b.go", `package b; func B() {};`)
-		env.Await(
-			env.DiagnosticAtRegexp("a/a.go", "b.B"),
-		)
-	})
-}
-
-// Edit both the current file and one of its dependencies on disk and
-// expect diagnostic changes.
-func TestEditFileAndDependency(t *testing.T) {
-	const pkg = `
--- go.mod --
-module mod.com
-
-go 1.14
--- b/b.go --
-package b
-
-func B() int { return 0 }
--- a/a.go --
-package a
-
-import (
-	"mod.com/b"
-)
-
-func _() {
-	var x int
-	_ = b.B()
-}
-`
-	runner.Run(t, pkg, func(t *testing.T, env *Env) {
-		env.Await(
-			env.DiagnosticAtRegexp("a/a.go", "x"),
-		)
-		env.WriteWorkspaceFiles(map[string]string{
-			"b/b.go": `package b; func B() {};`,
-			"a/a.go": `package a
-
-import "mod.com/b"
-
-func _() {
-	b.B()
-}`,
-		})
-		env.Await(
-			EmptyDiagnostics("a/a.go"),
-			NoDiagnostics("b/b.go"),
-		)
-	})
-}
-
-// Delete a dependency and expect a new diagnostic.
-func TestDeleteDependency(t *testing.T) {
-	const pkg = `
--- go.mod --
-module mod.com
-
-go 1.14
--- b/b.go --
-package b
-
-func B() int { return 0 }
--- a/a.go --
-package a
-
-import (
-	"mod.com/b"
-)
-
-func _() {
-	_ = b.B()
-}
-`
-	runner.Run(t, pkg, func(t *testing.T, env *Env) {
-		env.OpenFile("a/a.go")
-		env.Await(CompletedWork(lsp.DiagnosticWorkTitle(lsp.FromDidOpen), 1))
-		env.RemoveWorkspaceFile("b/b.go")
-		env.Await(
-			env.DiagnosticAtRegexp("a/a.go", "\"mod.com/b\""),
-		)
-	})
-}
-
-// Create a dependency on disk and expect the diagnostic to go away.
-func TestCreateDependency(t *testing.T) {
-	const missing = `
--- go.mod --
-module mod.com
-
-go 1.14
--- b/b.go --
-package b
-
-func B() int { return 0 }
--- a/a.go --
-package a
-
-import (
-	"mod.com/c"
-)
-
-func _() {
-	c.C()
-}
-`
-	runner.Run(t, missing, func(t *testing.T, env *Env) {
-		t.Skip("the initial workspace load fails and never retries")
-
-		env.Await(
-			env.DiagnosticAtRegexp("a/a.go", "\"mod.com/c\""),
-		)
-		env.WriteWorkspaceFile("c/c.go", `package c; func C() {};`)
-		env.Await(
-			EmptyDiagnostics("c/c.go"),
-		)
-	})
-}
-
-// Create a new dependency and add it to the file on disk.
-// This is similar to what might happen if you switch branches.
-func TestCreateAndAddDependency(t *testing.T) {
-	const original = `
--- go.mod --
-module mod.com
-
-go 1.14
--- a/a.go --
-package a
-
-func _() {}
-`
-	runner.Run(t, original, func(t *testing.T, env *Env) {
-		env.WriteWorkspaceFile("c/c.go", `package c; func C() {};`)
-		env.WriteWorkspaceFile("a/a.go", `package a; import "mod.com/c"; func _() { c.C() }`)
-		env.Await(
-			NoDiagnostics("a/a.go"),
-		)
-	})
-}
-
-// Create a new file that defines a new symbol, in the same package.
-func TestCreateFile(t *testing.T) {
-	const pkg = `
--- go.mod --
-module mod.com
-
-go 1.14
--- a/a.go --
-package a
-
-func _() {
-	hello()
-}
-`
-	runner.Run(t, pkg, func(t *testing.T, env *Env) {
-		env.Await(
-			env.DiagnosticAtRegexp("a/a.go", "hello"),
-		)
-		env.WriteWorkspaceFile("a/a2.go", `package a; func hello() {};`)
-		env.Await(
-			EmptyDiagnostics("a/a.go"),
-		)
-	})
-}
-
-// Add a new method to an interface and implement it.
-// Inspired by the structure of internal/lsp/source and internal/lsp/cache.
-func TestCreateImplementation(t *testing.T) {
-	const pkg = `
--- go.mod --
-module mod.com
-
-go 1.14
--- b/b.go --
-package b
-
-type B interface{
-	Hello() string
-}
-
-func SayHello(bee B) {
-	println(bee.Hello())
-}
--- a/a.go --
-package a
-
-import "mod.com/b"
-
-type X struct {}
-
-func (_ X) Hello() string {
-	return ""
-}
-
-func _() {
-	x := X{}
-	b.SayHello(x)
-}
-`
-	const newMethod = `package b
-type B interface{
-	Hello() string
-	Bye() string
-}
-
-func SayHello(bee B) {
-	println(bee.Hello())
-}`
-	const implementation = `package a
-
-import "mod.com/b"
-
-type X struct {}
-
-func (_ X) Hello() string {
-	return ""
-}
-
-func (_ X) Bye() string {
-	return ""
-}
-
-func _() {
-	x := X{}
-	b.SayHello(x)
-}`
-
-	// Add the new method before the implementation. Expect diagnostics.
-	t.Run("method before implementation", func(t *testing.T) {
-		runner.Run(t, pkg, func(t *testing.T, env *Env) {
-			env.WriteWorkspaceFile("b/b.go", newMethod)
-			env.Await(
-				OnceMet(
-					CompletedWork(lsp.DiagnosticWorkTitle(lsp.FromDidChangeWatchedFiles), 1),
-					DiagnosticAt("a/a.go", 12, 12),
-				),
-			)
-			env.WriteWorkspaceFile("a/a.go", implementation)
-			env.Await(
-				EmptyDiagnostics("a/a.go"),
-			)
-		})
-	})
-	// Add the new implementation before the new method. Expect no diagnostics.
-	t.Run("implementation before method", func(t *testing.T) {
-		runner.Run(t, pkg, func(t *testing.T, env *Env) {
-			env.WriteWorkspaceFile("a/a.go", implementation)
-			env.Await(
-				OnceMet(
-					CompletedWork(lsp.DiagnosticWorkTitle(lsp.FromDidChangeWatchedFiles), 1),
-					NoDiagnostics("a/a.go"),
-				),
-			)
-			env.WriteWorkspaceFile("b/b.go", newMethod)
-			env.Await(
-				NoDiagnostics("a/a.go"),
-			)
-		})
-	})
-	// Add both simultaneously. Expect no diagnostics.
-	t.Run("implementation and method simultaneously", func(t *testing.T) {
-		runner.Run(t, pkg, func(t *testing.T, env *Env) {
-			env.WriteWorkspaceFiles(map[string]string{
-				"a/a.go": implementation,
-				"b/b.go": newMethod,
-			})
-			env.Await(
-				OnceMet(
-					CompletedWork(lsp.DiagnosticWorkTitle(lsp.FromDidChangeWatchedFiles), 1),
-					NoDiagnostics("a/a.go"),
-				),
-				NoDiagnostics("b/b.go"),
-			)
-		})
-	})
-}
-
-// Tests golang/go#38498. Delete a file and then force a reload.
-// Assert that we no longer try to load the file.
-func TestDeleteFiles(t *testing.T) {
-	const pkg = `
--- go.mod --
-module mod.com
-
-go 1.14
--- a/a.go --
-package a
-
-func _() {
-	var _ int
-}
--- a/a_unneeded.go --
-package a
-`
-	t.Run("close then delete", func(t *testing.T) {
-		withOptions(EditorConfig{
-			VerboseOutput: true,
-		}).run(t, pkg, func(t *testing.T, env *Env) {
-			env.OpenFile("a/a.go")
-			env.OpenFile("a/a_unneeded.go")
-			env.Await(
-				OnceMet(
-					CompletedWork(lsp.DiagnosticWorkTitle(lsp.FromDidOpen), 2),
-					LogMatching(protocol.Info, "a_unneeded.go", 1),
-				),
-			)
-
-			// Close and delete the open file, mimicking what an editor would do.
-			env.CloseBuffer("a/a_unneeded.go")
-			env.RemoveWorkspaceFile("a/a_unneeded.go")
-			env.RegexpReplace("a/a.go", "var _ int", "fmt.Println(\"\")")
-			env.Await(
-				env.DiagnosticAtRegexp("a/a.go", "fmt"),
-			)
-			env.SaveBuffer("a/a.go")
-			env.Await(
-				OnceMet(
-					CompletedWork(lsp.DiagnosticWorkTitle(lsp.FromDidSave), 1),
-					// There should only be one log message containing
-					// a_unneeded.go, from the initial workspace load, which we
-					// check for earlier. If there are more, there's a bug.
-					LogMatching(protocol.Info, "a_unneeded.go", 1),
-				),
-				EmptyDiagnostics("a/a.go"),
-			)
-		})
-	})
-
-	t.Run("delete then close", func(t *testing.T) {
-		withOptions(EditorConfig{
-			VerboseOutput: true,
-		}).run(t, pkg, func(t *testing.T, env *Env) {
-			env.OpenFile("a/a.go")
-			env.OpenFile("a/a_unneeded.go")
-			env.Await(
-				OnceMet(
-					CompletedWork(lsp.DiagnosticWorkTitle(lsp.FromDidOpen), 2),
-					LogMatching(protocol.Info, "a_unneeded.go", 1),
-				),
-			)
-
-			// Delete and then close the file.
-			env.RemoveWorkspaceFile("a/a_unneeded.go")
-			env.CloseBuffer("a/a_unneeded.go")
-			env.RegexpReplace("a/a.go", "var _ int", "fmt.Println(\"\")")
-			env.Await(
-				env.DiagnosticAtRegexp("a/a.go", "fmt"),
-			)
-			env.SaveBuffer("a/a.go")
-			env.Await(
-				OnceMet(
-					CompletedWork(lsp.DiagnosticWorkTitle(lsp.FromDidSave), 1),
-					// There should only be one log message containing
-					// a_unneeded.go, from the initial workspace load, which we
-					// check for earlier. If there are more, there's a bug.
-					LogMatching(protocol.Info, "a_unneeded.go", 1),
-				),
-				EmptyDiagnostics("a/a.go"),
-			)
-		})
-	})
-}
-
-// This change reproduces the behavior of switching branches, with multiple
-// files being created and deleted. The key change here is the movement of a
-// symbol from one file to another in a given package through a deletion and
-// creation. To reproduce an issue with metadata invalidation in batched
-// changes, the last change in the batch is an on-disk file change that doesn't
-// require metadata invalidation.
-func TestMoveSymbol(t *testing.T) {
-	const pkg = `
--- go.mod --
-module mod.com
-
-go 1.14
--- main.go --
-package main
-
-import "mod.com/a"
-
-func main() {
-	var x int
-	x = a.Hello
-	println(x)
-}
--- a/a1.go --
-package a
-
-var Hello int
--- a/a2.go --
-package a
-
-func _() {}
-`
-	runner.Run(t, pkg, func(t *testing.T, env *Env) {
-		env.ChangeFilesOnDisk([]fake.FileEvent{
-			{
-				Path: "a/a3.go",
-				Content: `package a
-
-var Hello int
-`,
-				ProtocolEvent: protocol.FileEvent{
-					URI:  env.Sandbox.Workdir.URI("a/a3.go"),
-					Type: protocol.Created,
-				},
-			},
-			{
-				Path: "a/a1.go",
-				ProtocolEvent: protocol.FileEvent{
-					URI:  env.Sandbox.Workdir.URI("a/a1.go"),
-					Type: protocol.Deleted,
-				},
-			},
-			{
-				Path:    "a/a2.go",
-				Content: `package a; func _() {};`,
-				ProtocolEvent: protocol.FileEvent{
-					URI:  env.Sandbox.Workdir.URI("a/a2.go"),
-					Type: protocol.Changed,
-				},
-			},
-		})
-		env.Await(
-			OnceMet(
-				CompletedWork(lsp.DiagnosticWorkTitle(lsp.FromDidChangeWatchedFiles), 1),
-				NoDiagnostics("main.go"),
-			),
-		)
-	})
-}
-
-// Reproduce golang/go#40456.
-func TestChangeVersion(t *testing.T) {
-	const proxy = `
--- example.com@v1.2.3/go.mod --
-module example.com
-
-go 1.12
--- example.com@v1.2.3/blah/blah.go --
-package blah
-
-const Name = "Blah"
-
-func X(x int) {}
--- example.com@v1.2.2/go.mod --
-module example.com
-
-go 1.12
--- example.com@v1.2.2/blah/blah.go --
-package blah
-
-const Name = "Blah"
-
-func X() {}
--- random.org@v1.2.3/go.mod --
-module random.org
-
-go 1.12
--- random.org@v1.2.3/blah/blah.go --
-package hello
-
-const Name = "Hello"
-`
-	const mod = `
--- go.mod --
-module mod.com
-
-go 1.12
-
-require example.com v1.2.2
--- main.go --
-package main
-
-import "example.com/blah"
-
-func main() {
-	blah.X()
-}
-`
-	withOptions(WithProxyFiles(proxy)).run(t, mod, func(t *testing.T, env *Env) {
-		env.WriteWorkspaceFiles(map[string]string{
-			"go.mod": `module mod.com
-
-go 1.12
-
-require example.com v1.2.3
-`,
-			"main.go": `package main
-
-import (
-	"example.com/blah"
-)
-
-func main() {
-	blah.X(1)
-}
-`,
-		})
-		env.Await(
-			CompletedWork(lsp.DiagnosticWorkTitle(lsp.FromDidChangeWatchedFiles), 1),
-			NoDiagnostics("main.go"),
-		)
-	})
-}
-
-// Reproduces golang/go#40340.
-func TestSwitchFromGOPATHToModules(t *testing.T) {
-	testenv.NeedsGo1Point(t, 13)
-
-	const files = `
--- foo/blah/blah.go --
-package blah
-
-const Name = ""
--- foo/main.go --
-package main
-
-import "blah"
-
-func main() {
-	_ = blah.Name
-}
-`
-	withOptions(
-		InGOPATH(),
-		WithModes(Experimental), // module is in a subdirectory
-	).run(t, files, func(t *testing.T, env *Env) {
-		env.OpenFile("foo/main.go")
-		env.Await(env.DiagnosticAtRegexp("foo/main.go", `"blah"`))
-		if err := env.Sandbox.RunGoCommand(env.Ctx, "foo", "mod", []string{"init", "mod.com"}); err != nil {
-			t.Fatal(err)
-		}
-		env.Await(
-			OnceMet(
-				CompletedWork(lsp.DiagnosticWorkTitle(lsp.FromDidChangeWatchedFiles), 1),
-				env.DiagnosticAtRegexp("foo/main.go", `"blah"`),
-			),
-		)
-		env.RegexpReplace("foo/main.go", `"blah"`, `"mod.com/blah"`)
-		env.Await(
-			EmptyDiagnostics("foo/main.go"),
-		)
-	})
-}
-
-// Reproduces golang/go#40487.
-func TestSwitchFromModulesToGOPATH(t *testing.T) {
-	testenv.NeedsGo1Point(t, 13)
-
-	const files = `
--- foo/go.mod --
-module mod.com
-
-go 1.14
--- foo/blah/blah.go --
-package blah
-
-const Name = ""
--- foo/main.go --
-package main
-
-import "mod.com/blah"
-
-func main() {
-	_ = blah.Name
-}
-`
-	withOptions(
-		InGOPATH(),
-	).run(t, files, func(t *testing.T, env *Env) {
-		env.OpenFile("foo/main.go")
-		env.RemoveWorkspaceFile("foo/go.mod")
-		env.Await(
-			OnceMet(
-				CompletedWork(lsp.DiagnosticWorkTitle(lsp.FromDidChangeWatchedFiles), 1),
-				env.DiagnosticAtRegexp("foo/main.go", `"mod.com/blah"`),
-			),
-		)
-		env.RegexpReplace("foo/main.go", `"mod.com/blah"`, `"foo/blah"`)
-		env.Await(
-			EmptyDiagnostics("foo/main.go"),
-		)
-	})
-}
-
-func TestNewSymbolInTestVariant(t *testing.T) {
-	const files = `
--- go.mod --
-module mod.com
-
-go 1.12
--- a/a.go --
-package a
-
-func bob() {}
--- a/a_test.go --
-package a
-
-import "testing"
-
-func TestBob(t *testing.T) {
-	bob()
-}
-`
-	run(t, files, func(t *testing.T, env *Env) {
-		// Add a new symbol to the package under test and use it in the test
-		// variant. Expect no diagnostics.
-		env.WriteWorkspaceFiles(map[string]string{
-			"a/a.go": `package a
-
-func bob() {}
-func george() {}
-`,
-			"a/a_test.go": `package a
-
-import "testing"
-
-func TestAll(t *testing.T) {
-	bob()
-	george()
-}
-`,
-		})
-		env.Await(
-			OnceMet(
-				CompletedWork(lsp.DiagnosticWorkTitle(lsp.FromDidChangeWatchedFiles), 1),
-				NoDiagnostics("a/a.go"),
-			),
-			OnceMet(
-				CompletedWork(lsp.DiagnosticWorkTitle(lsp.FromDidChangeWatchedFiles), 1),
-				NoDiagnostics("a/a_test.go"),
-			),
-		)
-		// Now, add a new file to the test variant and use its symbol in the
-		// original test file. Expect no diagnostics.
-		env.WriteWorkspaceFiles(map[string]string{
-			"a/a_test.go": `package a
-
-import "testing"
-
-func TestAll(t *testing.T) {
-	bob()
-	george()
-	hi()
-}
-`,
-			"a/a2_test.go": `package a
-
-import "testing"
-
-func hi() {}
-
-func TestSomething(t *testing.T) {}
-`,
-		})
-		env.Await(
-			OnceMet(
-				CompletedWork(lsp.DiagnosticWorkTitle(lsp.FromDidChangeWatchedFiles), 2),
-				NoDiagnostics("a/a_test.go"),
-			),
-			OnceMet(
-				CompletedWork(lsp.DiagnosticWorkTitle(lsp.FromDidChangeWatchedFiles), 2),
-				NoDiagnostics("a/a2_test.go"),
-			),
-		)
-	})
-}
diff -urN a/gopls/internal/regtest/workspace_test.go b/gopls/internal/regtest/workspace_test.go
--- a/gopls/internal/regtest/workspace_test.go	2000-01-01 00:00:00.000000000 -0000
+++ b/gopls/internal/regtest/workspace_test.go	1969-12-31 19:00:00.000000000 -0500
@@ -1,625 +0,0 @@
-// Copyright 2020 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package regtest
-
-import (
-	"fmt"
-	"io/ioutil"
-	"os"
-	"path/filepath"
-	"strings"
-	"testing"
-
-	"golang.org/x/tools/internal/lsp"
-	"golang.org/x/tools/internal/lsp/fake"
-	"golang.org/x/tools/internal/testenv"
-)
-
-const workspaceProxy = `
--- example.com@v1.2.3/go.mod --
-module example.com
-
-go 1.12
--- example.com@v1.2.3/blah/blah.go --
-package blah
-
-func SaySomething() {
-	fmt.Println("something")
-}
--- random.org@v1.2.3/go.mod --
-module random.org
-
-go 1.12
--- random.org@v1.2.3/bye/bye.go --
-package bye
-
-func Goodbye() {
-	println("Bye")
-}
-`
-
-// TODO: Add a replace directive.
-const workspaceModule = `
--- pkg/go.mod --
-module mod.com
-
-go 1.14
-
-require (
-	example.com v1.2.3
-	random.org v1.2.3
-)
--- pkg/main.go --
-package main
-
-import (
-	"example.com/blah"
-	"mod.com/inner"
-	"random.org/bye"
-)
-
-func main() {
-	blah.SaySomething()
-	inner.Hi()
-	bye.Goodbye()
-}
--- pkg/main2.go --
-package main
-
-import "fmt"
-
-func _() {
-	fmt.Print("%s")
-}
--- pkg/inner/inner.go --
-package inner
-
-import "example.com/blah"
-
-func Hi() {
-	blah.SaySomething()
-}
--- goodbye/bye/bye.go --
-package bye
-
-func Bye() {}
--- goodbye/go.mod --
-module random.org
-
-go 1.12
-`
-
-// Confirm that find references returns all of the references in the module,
-// regardless of what the workspace root is.
-func TestReferences(t *testing.T) {
-	for _, tt := range []struct {
-		name, rootPath string
-	}{
-		{
-			name:     "module root",
-			rootPath: "pkg",
-		},
-		{
-			name:     "subdirectory",
-			rootPath: "pkg/inner",
-		},
-	} {
-		t.Run(tt.name, func(t *testing.T) {
-			opts := []RunOption{WithProxyFiles(workspaceProxy)}
-			if tt.rootPath != "" {
-				opts = append(opts, WithRootPath(tt.rootPath))
-			}
-			withOptions(opts...).run(t, workspaceModule, func(t *testing.T, env *Env) {
-				f := "pkg/inner/inner.go"
-				env.OpenFile(f)
-				locations := env.References(f, env.RegexpSearch(f, `SaySomething`))
-				want := 3
-				if got := len(locations); got != want {
-					t.Fatalf("expected %v locations, got %v", want, got)
-				}
-			})
-		})
-	}
-}
-
-// Make sure that analysis diagnostics are cleared for the whole package when
-// the only opened file is closed. This test was inspired by the experience in
-// VS Code, where clicking on a reference result triggers a
-// textDocument/didOpen without a corresponding textDocument/didClose.
-func TestClearAnalysisDiagnostics(t *testing.T) {
-	withOptions(WithProxyFiles(workspaceProxy), WithRootPath("pkg/inner")).run(t, workspaceModule, func(t *testing.T, env *Env) {
-		env.OpenFile("pkg/main.go")
-		env.Await(
-			env.DiagnosticAtRegexp("pkg/main2.go", "fmt.Print"),
-		)
-		env.CloseBuffer("pkg/main.go")
-		env.Await(
-			EmptyDiagnostics("pkg/main2.go"),
-		)
-	})
-}
-
-// This test checks that gopls updates the set of files it watches when a
-// replace target is added to the go.mod.
-func TestWatchReplaceTargets(t *testing.T) {
-	withOptions(WithProxyFiles(workspaceProxy), WithRootPath("pkg")).run(t, workspaceModule, func(t *testing.T, env *Env) {
-		// Add a replace directive and expect the files that gopls is watching
-		// to change.
-		dir := env.Sandbox.Workdir.URI("goodbye").SpanURI().Filename()
-		goModWithReplace := fmt.Sprintf(`%s
-replace random.org => %s
-`, env.ReadWorkspaceFile("pkg/go.mod"), dir)
-		env.WriteWorkspaceFile("pkg/go.mod", goModWithReplace)
-		env.Await(
-			CompletedWork(lsp.DiagnosticWorkTitle(lsp.FromDidChangeWatchedFiles), 1),
-			UnregistrationMatching("didChangeWatchedFiles"),
-			RegistrationMatching("didChangeWatchedFiles"),
-		)
-	})
-}
-
-const workspaceModuleProxy = `
--- example.com@v1.2.3/go.mod --
-module example.com
-
-go 1.12
--- example.com@v1.2.3/blah/blah.go --
-package blah
-
-func SaySomething() {
-	fmt.Println("something")
-}
--- b.com@v1.2.3/go.mod --
-module b.com
-
-go 1.12
--- b.com@v1.2.3/b/b.go --
-package b
-
-func Hello() {}
-`
-
-func TestAutomaticWorkspaceModule_Interdependent(t *testing.T) {
-	const multiModule = `
--- moda/a/go.mod --
-module a.com
-
-require b.com v1.2.3
-
--- moda/a/a.go --
-package a
-
-import (
-	"b.com/b"
-)
-
-func main() {
-	var x int
-	_ = b.Hello()
-}
--- modb/go.mod --
-module b.com
-
--- modb/b/b.go --
-package b
-
-func Hello() int {
-	var x int
-}
-`
-	withOptions(
-		WithProxyFiles(workspaceModuleProxy),
-		WithModes(Experimental),
-	).run(t, multiModule, func(t *testing.T, env *Env) {
-		env.Await(
-			env.DiagnosticAtRegexp("moda/a/a.go", "x"),
-			env.DiagnosticAtRegexp("modb/b/b.go", "x"),
-			env.NoDiagnosticAtRegexp("moda/a/a.go", `"b.com/b"`),
-		)
-	})
-}
-
-// This change tests that the version of the module used changes after it has
-// been deleted from the workspace.
-func TestDeleteModule_Interdependent(t *testing.T) {
-	const multiModule = `
--- moda/a/go.mod --
-module a.com
-
-require b.com v1.2.3
-
--- moda/a/a.go --
-package a
-
-import (
-	"b.com/b"
-)
-
-func main() {
-	var x int
-	_ = b.Hello()
-}
--- modb/go.mod --
-module b.com
-
--- modb/b/b.go --
-package b
-
-func Hello() int {
-	var x int
-}
-`
-	withOptions(
-		WithProxyFiles(workspaceModuleProxy),
-		WithModes(Experimental),
-	).run(t, multiModule, func(t *testing.T, env *Env) {
-		env.OpenFile("moda/a/a.go")
-
-		original, _ := env.GoToDefinition("moda/a/a.go", env.RegexpSearch("moda/a/a.go", "Hello"))
-		if want := "modb/b/b.go"; !strings.HasSuffix(original, want) {
-			t.Errorf("expected %s, got %v", want, original)
-		}
-		env.CloseBuffer(original)
-		env.RemoveWorkspaceFile("modb/b/b.go")
-		env.RemoveWorkspaceFile("modb/go.mod")
-		env.Await(
-			CompletedWork(lsp.DiagnosticWorkTitle(lsp.FromDidChangeWatchedFiles), 2),
-		)
-		got, _ := env.GoToDefinition("moda/a/a.go", env.RegexpSearch("moda/a/a.go", "Hello"))
-		if want := "b.com@v1.2.3/b/b.go"; !strings.HasSuffix(got, want) {
-			t.Errorf("expected %s, got %v", want, got)
-		}
-	})
-}
-
-// Tests that the version of the module used changes after it has been added
-// to the workspace.
-func TestCreateModule_Interdependent(t *testing.T) {
-	const multiModule = `
--- moda/a/go.mod --
-module a.com
-
-require b.com v1.2.3
-
--- moda/a/a.go --
-package a
-
-import (
-	"b.com/b"
-)
-
-func main() {
-	var x int
-	_ = b.Hello()
-}
-`
-	withOptions(
-		WithModes(Experimental),
-		WithProxyFiles(workspaceModuleProxy),
-	).run(t, multiModule, func(t *testing.T, env *Env) {
-		env.OpenFile("moda/a/a.go")
-		original, _ := env.GoToDefinition("moda/a/a.go", env.RegexpSearch("moda/a/a.go", "Hello"))
-		if want := "b.com@v1.2.3/b/b.go"; !strings.HasSuffix(original, want) {
-			t.Errorf("expected %s, got %v", want, original)
-		}
-		env.CloseBuffer(original)
-		env.WriteWorkspaceFiles(map[string]string{
-			"modb/go.mod": "module b.com",
-			"modb/b/b.go": `package b
-
-func Hello() int {
-	var x int
-}
-`,
-		})
-		env.Await(
-			OnceMet(
-				CompletedWork(lsp.DiagnosticWorkTitle(lsp.FromDidChangeWatchedFiles), 1),
-				env.DiagnosticAtRegexp("modb/b/b.go", "x"),
-			),
-		)
-		got, _ := env.GoToDefinition("moda/a/a.go", env.RegexpSearch("moda/a/a.go", "Hello"))
-		if want := "modb/b/b.go"; !strings.HasSuffix(got, want) {
-			t.Errorf("expected %s, got %v", want, original)
-		}
-	})
-}
-
-// This test confirms that a gopls workspace can recover from initialization
-// with one invalid module.
-func TestOneBrokenModule(t *testing.T) {
-	const multiModule = `
--- moda/a/go.mod --
-module a.com
-
-require b.com v1.2.3
-
--- moda/a/a.go --
-package a
-
-import (
-	"b.com/b"
-)
-
-func main() {
-	var x int
-	_ = b.Hello()
-}
--- modb/go.mod --
-modul b.com // typo here
-
--- modb/b/b.go --
-package b
-
-func Hello() int {
-	var x int
-}
-`
-	withOptions(
-		WithProxyFiles(workspaceModuleProxy),
-		WithModes(Experimental),
-	).run(t, multiModule, func(t *testing.T, env *Env) {
-		env.OpenFile("modb/go.mod")
-		env.Await(
-			OnceMet(
-				CompletedWork(lsp.DiagnosticWorkTitle(lsp.FromDidOpen), 1),
-				DiagnosticAt("modb/go.mod", 0, 0),
-			),
-		)
-		env.RegexpReplace("modb/go.mod", "modul", "module")
-		env.Editor.SaveBufferWithoutActions(env.Ctx, "modb/go.mod")
-		env.Await(
-			env.DiagnosticAtRegexp("modb/b/b.go", "x"),
-		)
-	})
-}
-
-func TestUseGoplsMod(t *testing.T) {
-	// This test validates certain functionality related to using a gopls.mod
-	// file to specify workspace modules.
-	testenv.NeedsGo1Point(t, 14)
-	const multiModule = `
--- moda/a/go.mod --
-module a.com
-
-require b.com v1.2.3
-
--- moda/a/a.go --
-package a
-
-import (
-	"b.com/b"
-)
-
-func main() {
-	var x int
-	_ = b.Hello()
-}
--- modb/go.mod --
-module b.com
-
-require example.com v1.2.3
--- modb/b/b.go --
-package b
-
-func Hello() int {
-	var x int
-}
--- gopls.mod --
-module gopls-workspace
-
-require (
-	a.com v0.0.0-goplsworkspace
-	b.com v1.2.3
-)
-
-replace a.com => $SANDBOX_WORKDIR/moda/a
-`
-	withOptions(
-		WithProxyFiles(workspaceModuleProxy),
-		WithModes(Experimental),
-	).run(t, multiModule, func(t *testing.T, env *Env) {
-		// Initially, the gopls.mod should cause only the a.com module to be
-		// loaded. Validate this by jumping to a definition in b.com and ensuring
-		// that we go to the module cache.
-		env.OpenFile("moda/a/a.go")
-		location, _ := env.GoToDefinition("moda/a/a.go", env.RegexpSearch("moda/a/a.go", "Hello"))
-		if want := "b.com@v1.2.3/b/b.go"; !strings.HasSuffix(location, want) {
-			t.Errorf("expected %s, got %v", want, location)
-		}
-		workdir := env.Sandbox.Workdir.RootURI().SpanURI().Filename()
-
-		// Now, modify the gopls.mod file on disk to activate the b.com module in
-		// the workspace.
-		env.WriteWorkspaceFile("gopls.mod", fmt.Sprintf(`module gopls-workspace
-
-require (
-	a.com v0.0.0-goplsworkspace
-	b.com v0.0.0-goplsworkspace
-)
-
-replace a.com => %s/moda/a
-replace b.com => %s/modb
-`, workdir, workdir))
-		env.Await(
-			OnceMet(
-				CompletedWork(lsp.DiagnosticWorkTitle(lsp.FromDidChangeWatchedFiles), 1),
-				env.DiagnosticAtRegexp("modb/b/b.go", "x"),
-			),
-		)
-		env.OpenFile("modb/go.mod")
-		// Check that go.mod diagnostics picked up the newly active mod file.
-		env.Await(env.DiagnosticAtRegexp("modb/go.mod", `require example.com v1.2.3`))
-		// ...and that jumping to definition now goes to b.com in the workspace.
-		location, _ = env.GoToDefinition("moda/a/a.go", env.RegexpSearch("moda/a/a.go", "Hello"))
-		if want := "modb/b/b.go"; !strings.HasSuffix(location, want) {
-			t.Errorf("expected %s, got %v", want, location)
-		}
-
-		// Now, let's modify the gopls.mod *overlay* (not on disk), and verify that
-		// this change is also picked up.
-		env.OpenFile("gopls.mod")
-		env.SetBufferContent("gopls.mod", fmt.Sprintf(`module gopls-workspace
-
-require (
-	a.com v0.0.0-goplsworkspace
-)
-
-replace a.com => %s/moda/a
-`, workdir))
-		env.Await(CompletedWork(lsp.DiagnosticWorkTitle(lsp.FromDidChange), 1))
-		env.Await(OnceMet(
-			CompletedWork(lsp.DiagnosticWorkTitle(lsp.FromDidChange), 1),
-			EmptyDiagnostics("modb/go.mod"),
-		))
-
-		// Just as before, check that we now jump to the module cache.
-		location, _ = env.GoToDefinition("moda/a/a.go", env.RegexpSearch("moda/a/a.go", "Hello"))
-		if want := "b.com@v1.2.3/b/b.go"; !strings.HasSuffix(location, want) {
-			t.Errorf("expected %s, got %v", want, location)
-		}
-	})
-}
-
-func TestNonWorkspaceFileCreation(t *testing.T) {
-	testenv.NeedsGo1Point(t, 13)
-
-	const files = `
--- go.mod --
-module mod.com
-
--- x.go --
-package x
-`
-
-	const code = `
-package foo
-import "fmt"
-var _ = fmt.Printf
-`
-	run(t, files, func(t *testing.T, env *Env) {
-		env.CreateBuffer("/tmp/foo.go", "")
-		env.EditBuffer("/tmp/foo.go", fake.NewEdit(0, 0, 0, 0, code))
-		env.GoToDefinition("/tmp/foo.go", env.RegexpSearch("/tmp/foo.go", `Printf`))
-	})
-}
-
-func TestMultiModuleV2(t *testing.T) {
-	const multiModule = `
--- moda/a/go.mod --
-module a.com
-
-require b.com/v2 v2.0.0
--- moda/a/a.go --
-package a
-
-import (
-	"b.com/v2/b"
-)
-
-func main() {
-	var x int
-	_ = b.Hi()
-}
--- modb/go.mod --
-module b.com
-
--- modb/b/b.go --
-package b
-
-func Hello() int {
-	var x int
-}
--- modb/v2/go.mod --
-module b.com/v2
-
--- modb/v2/b/b.go --
-package b
-
-func Hi() int {
-	var x int
-}
--- modc/go.mod --
-module gopkg.in/yaml.v1 // test gopkg.in versions
--- modc/main.go --
-package main
-
-func main() {
-	var x int
-}
-`
-	withOptions(
-		WithModes(Experimental),
-	).run(t, multiModule, func(t *testing.T, env *Env) {
-		env.Await(
-			env.DiagnosticAtRegexp("moda/a/a.go", "x"),
-			env.DiagnosticAtRegexp("modb/b/b.go", "x"),
-			env.DiagnosticAtRegexp("modb/v2/b/b.go", "x"),
-			env.DiagnosticAtRegexp("modc/main.go", "x"),
-		)
-	})
-}
-
-func TestWorkspaceDirAccess(t *testing.T) {
-	const multiModule = `
--- moda/a/go.mod --
-module a.com
-
--- moda/a/a.go --
-package main
-
-func main() {
-	fmt.Println("Hello")
-}
--- modb/go.mod --
-module b.com
--- modb/b/b.go --
-package main
-
-func main() {
-	fmt.Println("World")
-}
-`
-	withOptions(
-		WithModes(Experimental),
-		SendPID(),
-	).run(t, multiModule, func(t *testing.T, env *Env) {
-		pid := os.Getpid()
-		// Don't factor this out of Server.addFolders. vscode-go expects this
-		// directory.
-		modPath := filepath.Join(os.TempDir(), fmt.Sprintf("gopls-%d.workspace", pid), "go.mod")
-		gotb, err := ioutil.ReadFile(modPath)
-		if err != nil {
-			t.Fatalf("reading expected workspace modfile: %v", err)
-		}
-		got := string(gotb)
-		for _, want := range []string{"a.com v0.0.0-goplsworkspace", "b.com v0.0.0-goplsworkspace"} {
-			if !strings.Contains(got, want) {
-				// want before got here, since the go.mod is multi-line
-				t.Fatalf("workspace go.mod missing %q. got:\n%s", want, got)
-			}
-		}
-		workdir := env.Sandbox.Workdir.RootURI().SpanURI().Filename()
-		env.WriteWorkspaceFile("gopls.mod", fmt.Sprintf(`
-				module gopls-workspace
-
-				require (
-					a.com v0.0.0-goplsworkspace
-				)
-
-				replace a.com => %s/moda/a
-				`, workdir))
-		env.Await(CompletedWork(lsp.DiagnosticWorkTitle(lsp.FromDidChangeWatchedFiles), 1))
-		gotb, err = ioutil.ReadFile(modPath)
-		if err != nil {
-			t.Fatalf("reading expected workspace modfile: %v", err)
-		}
-		got = string(gotb)
-		want := "b.com v0.0.0-goplsworkspace"
-		if strings.Contains(got, want) {
-			t.Fatalf("workspace go.mod contains unexpected %q. got:\n%s", want, got)
-		}
-	})
-}
diff -urN a/gopls/internal/regtest/wrappers.go b/gopls/internal/regtest/wrappers.go
--- a/gopls/internal/regtest/wrappers.go	2000-01-01 00:00:00.000000000 -0000
+++ b/gopls/internal/regtest/wrappers.go	1969-12-31 19:00:00.000000000 -0500
@@ -1,353 +0,0 @@
-// Copyright 2020 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package regtest
-
-import (
-	"io"
-	"testing"
-
-	"golang.org/x/tools/internal/lsp/fake"
-	"golang.org/x/tools/internal/lsp/protocol"
-	"golang.org/x/tools/internal/lsp/source"
-	errors "golang.org/x/xerrors"
-)
-
-func (e *Env) ChangeFilesOnDisk(events []fake.FileEvent) {
-	e.T.Helper()
-	if err := e.Sandbox.Workdir.ChangeFilesOnDisk(e.Ctx, events); err != nil {
-		e.T.Fatal(err)
-	}
-}
-
-// RemoveWorkspaceFile deletes a file on disk but does nothing in the
-// editor. It calls t.Fatal on any error.
-func (e *Env) RemoveWorkspaceFile(name string) {
-	e.T.Helper()
-	if err := e.Sandbox.Workdir.RemoveFile(e.Ctx, name); err != nil {
-		e.T.Fatal(err)
-	}
-}
-
-// ReadWorkspaceFile reads a file from the workspace, calling t.Fatal on any
-// error.
-func (e *Env) ReadWorkspaceFile(name string) string {
-	e.T.Helper()
-	content, err := e.Sandbox.Workdir.ReadFile(name)
-	if err != nil {
-		e.T.Fatal(err)
-	}
-	return content
-}
-
-// WriteWorkspaceFile writes a file to disk but does nothing in the editor.
-// It calls t.Fatal on any error.
-func (e *Env) WriteWorkspaceFile(name, content string) {
-	e.T.Helper()
-	if err := e.Sandbox.Workdir.WriteFile(e.Ctx, name, content); err != nil {
-		e.T.Fatal(err)
-	}
-}
-
-// WriteWorkspaceFiles deletes a file on disk but does nothing in the
-// editor. It calls t.Fatal on any error.
-func (e *Env) WriteWorkspaceFiles(files map[string]string) {
-	e.T.Helper()
-	if err := e.Sandbox.Workdir.WriteFiles(e.Ctx, files); err != nil {
-		e.T.Fatal(err)
-	}
-}
-
-// OpenFile opens a file in the editor, calling t.Fatal on any error.
-func (e *Env) OpenFile(name string) {
-	e.T.Helper()
-	if err := e.Editor.OpenFile(e.Ctx, name); err != nil {
-		e.T.Fatal(err)
-	}
-}
-
-// CreateBuffer creates a buffer in the editor, calling t.Fatal on any error.
-func (e *Env) CreateBuffer(name string, content string) {
-	e.T.Helper()
-	if err := e.Editor.CreateBuffer(e.Ctx, name, content); err != nil {
-		e.T.Fatal(err)
-	}
-}
-
-// CloseBuffer closes an editor buffer without saving, calling t.Fatal on any
-// error.
-func (e *Env) CloseBuffer(name string) {
-	e.T.Helper()
-	if err := e.Editor.CloseBuffer(e.Ctx, name); err != nil {
-		e.T.Fatal(err)
-	}
-}
-
-// EditBuffer applies edits to an editor buffer, calling t.Fatal on any error.
-func (e *Env) EditBuffer(name string, edits ...fake.Edit) {
-	e.T.Helper()
-	if err := e.Editor.EditBuffer(e.Ctx, name, edits); err != nil {
-		e.T.Fatal(err)
-	}
-}
-
-func (e *Env) SetBufferContent(name string, content string) {
-	e.T.Helper()
-	if err := e.Editor.SetBufferContent(e.Ctx, name, content); err != nil {
-		e.T.Fatal(err)
-	}
-}
-
-// RegexpRange returns the range of the first match for re in the buffer
-// specified by name, calling t.Fatal on any error. It first searches for the
-// position in open buffers, then in workspace files.
-func (e *Env) RegexpRange(name, re string) (fake.Pos, fake.Pos) {
-	e.T.Helper()
-	start, end, err := e.Editor.RegexpRange(name, re)
-	if err == fake.ErrUnknownBuffer {
-		start, end, err = e.Sandbox.Workdir.RegexpRange(name, re)
-	}
-	if err != nil {
-		e.T.Fatalf("RegexpRange: %v, %v", name, err)
-	}
-	return start, end
-}
-
-// RegexpSearch returns the starting position of the first match for re in the
-// buffer specified by name, calling t.Fatal on any error. It first searches
-// for the position in open buffers, then in workspace files.
-func (e *Env) RegexpSearch(name, re string) fake.Pos {
-	e.T.Helper()
-	pos, err := e.Editor.RegexpSearch(name, re)
-	if err == fake.ErrUnknownBuffer {
-		pos, err = e.Sandbox.Workdir.RegexpSearch(name, re)
-	}
-	if err != nil {
-		e.T.Fatalf("RegexpSearch: %v, %v", name, err)
-	}
-	return pos
-}
-
-// RegexpReplace replaces the first group in the first match of regexpStr with
-// the replace text, calling t.Fatal on any error.
-func (e *Env) RegexpReplace(name, regexpStr, replace string) {
-	e.T.Helper()
-	if err := e.Editor.RegexpReplace(e.Ctx, name, regexpStr, replace); err != nil {
-		e.T.Fatalf("RegexpReplace: %v", err)
-	}
-}
-
-// SaveBuffer saves an editor buffer, calling t.Fatal on any error.
-func (e *Env) SaveBuffer(name string) {
-	e.T.Helper()
-	if err := e.Editor.SaveBuffer(e.Ctx, name); err != nil {
-		e.T.Fatal(err)
-	}
-}
-
-// GoToDefinition goes to definition in the editor, calling t.Fatal on any
-// error.
-func (e *Env) GoToDefinition(name string, pos fake.Pos) (string, fake.Pos) {
-	e.T.Helper()
-	n, p, err := e.Editor.GoToDefinition(e.Ctx, name, pos)
-	if err != nil {
-		e.T.Fatal(err)
-	}
-	return n, p
-}
-
-// Symbol returns symbols matching query
-func (e *Env) Symbol(query string) []fake.SymbolInformation {
-	e.T.Helper()
-	r, err := e.Editor.Symbol(e.Ctx, query)
-	if err != nil {
-		e.T.Fatal(err)
-	}
-	return r
-}
-
-// FormatBuffer formats the editor buffer, calling t.Fatal on any error.
-func (e *Env) FormatBuffer(name string) {
-	e.T.Helper()
-	if err := e.Editor.FormatBuffer(e.Ctx, name); err != nil {
-		e.T.Fatal(err)
-	}
-}
-
-// OrganizeImports processes the source.organizeImports codeAction, calling
-// t.Fatal on any error.
-func (e *Env) OrganizeImports(name string) {
-	e.T.Helper()
-	if err := e.Editor.OrganizeImports(e.Ctx, name); err != nil {
-		e.T.Fatal(err)
-	}
-}
-
-// ApplyQuickFixes processes the quickfix codeAction, calling t.Fatal on any error.
-func (e *Env) ApplyQuickFixes(path string, diagnostics []protocol.Diagnostic) {
-	e.T.Helper()
-	if err := e.Editor.ApplyQuickFixes(e.Ctx, path, nil, diagnostics); err != nil {
-		e.T.Fatal(err)
-	}
-}
-
-// Hover in the editor, calling t.Fatal on any error.
-func (e *Env) Hover(name string, pos fake.Pos) (*protocol.MarkupContent, fake.Pos) {
-	e.T.Helper()
-	c, p, err := e.Editor.Hover(e.Ctx, name, pos)
-	if err != nil {
-		e.T.Fatal(err)
-	}
-	return c, p
-}
-
-func (e *Env) DocumentLink(name string) []protocol.DocumentLink {
-	e.T.Helper()
-	links, err := e.Editor.DocumentLink(e.Ctx, name)
-	if err != nil {
-		e.T.Fatal(err)
-	}
-	return links
-}
-
-func checkIsFatal(t *testing.T, err error) {
-	t.Helper()
-	if err != nil && !errors.Is(err, io.EOF) && !errors.Is(err, io.ErrClosedPipe) {
-		t.Fatal(err)
-	}
-}
-
-// CloseEditor shuts down the editor, calling t.Fatal on any error.
-func (e *Env) CloseEditor() {
-	e.T.Helper()
-	checkIsFatal(e.T, e.Editor.Close(e.Ctx))
-}
-
-// RunGenerate runs go:generate on the given dir, calling t.Fatal on any error.
-// It waits for the generate command to complete and checks for file changes
-// before returning.
-func (e *Env) RunGenerate(dir string) {
-	e.T.Helper()
-	if err := e.Editor.RunGenerate(e.Ctx, dir); err != nil {
-		e.T.Fatal(err)
-	}
-	e.Await(NoOutstandingWork())
-	// Ideally the fake.Workspace would handle all synthetic file watching, but
-	// we help it out here as we need to wait for the generate command to
-	// complete before checking the filesystem.
-	e.CheckForFileChanges()
-}
-
-// RunGoCommand runs the given command in the sandbox's default working
-// directory.
-func (e *Env) RunGoCommand(verb string, args ...string) {
-	if err := e.Sandbox.RunGoCommand(e.Ctx, "", verb, args); err != nil {
-		e.T.Fatal(err)
-	}
-}
-
-// CheckForFileChanges triggers a manual poll of the workspace for any file
-// changes since creation, or since last polling. It is a workaround for the
-// lack of true file watching support in the fake workspace.
-func (e *Env) CheckForFileChanges() {
-	e.T.Helper()
-	if err := e.Sandbox.Workdir.CheckForFileChanges(e.Ctx); err != nil {
-		e.T.Fatal(err)
-	}
-}
-
-// CodeLens calls textDocument/codeLens for the given path, calling t.Fatal on
-// any error.
-func (e *Env) CodeLens(path string) []protocol.CodeLens {
-	e.T.Helper()
-	lens, err := e.Editor.CodeLens(e.Ctx, path)
-	if err != nil {
-		e.T.Fatal(err)
-	}
-	return lens
-}
-
-// ExecuteCodeLensCommand executes the command for the code lens matching the
-// given command name.
-func (e *Env) ExecuteCodeLensCommand(path string, cmd *source.Command) {
-	lenses := e.CodeLens(path)
-	var lens protocol.CodeLens
-	var found bool
-	for _, l := range lenses {
-		if l.Command.Command == cmd.ID() {
-			lens = l
-			found = true
-		}
-	}
-	if !found {
-		e.T.Fatalf("found no command with the ID %s", cmd.ID())
-	}
-	if _, err := e.Editor.ExecuteCommand(e.Ctx, &protocol.ExecuteCommandParams{
-		Command:   lens.Command.Command,
-		Arguments: lens.Command.Arguments,
-	}); err != nil {
-		e.T.Fatal(err)
-	}
-}
-
-// References calls textDocument/references for the given path at the given
-// position.
-func (e *Env) References(path string, pos fake.Pos) []protocol.Location {
-	e.T.Helper()
-	locations, err := e.Editor.References(e.Ctx, path, pos)
-	if err != nil {
-		e.T.Fatal(err)
-	}
-	return locations
-}
-
-// Completion executes a completion request on the server.
-func (e *Env) Completion(path string, pos fake.Pos) *protocol.CompletionList {
-	e.T.Helper()
-	completions, err := e.Editor.Completion(e.Ctx, path, pos)
-	if err != nil {
-		e.T.Fatal(err)
-	}
-	return completions
-}
-
-// CodeAction calls testDocument/codeAction for the given path, and calls
-// t.Fatal if there are errors.
-func (e *Env) CodeAction(path string) []protocol.CodeAction {
-	e.T.Helper()
-	actions, err := e.Editor.CodeAction(e.Ctx, path, nil)
-	if err != nil {
-		e.T.Fatal(err)
-	}
-	return actions
-}
-
-func (e *Env) changeConfiguration(t *testing.T, config *fake.EditorConfig) {
-	e.Editor.Config = *config
-	if err := e.Editor.Server.DidChangeConfiguration(e.Ctx, &protocol.DidChangeConfigurationParams{
-		// gopls currently ignores the Settings field
-	}); err != nil {
-		t.Fatal(err)
-	}
-}
-
-// ChangeEnv modifies the editor environment and reconfigures the LSP client.
-// TODO: extend this to "ChangeConfiguration", once we refactor the way editor
-// configuration is defined.
-func (e *Env) ChangeEnv(overlay map[string]string) {
-	e.T.Helper()
-	// TODO: to be correct, this should probably be synchronized, but right now
-	// configuration is only ever modified synchronously in a regtest, so this
-	// correctness can wait for the previously mentioned refactoring.
-	if e.Editor.Config.Env == nil {
-		e.Editor.Config.Env = make(map[string]string)
-	}
-	for k, v := range overlay {
-		e.Editor.Config.Env[k] = v
-	}
-	var params protocol.DidChangeConfigurationParams
-	if err := e.Editor.Server.DidChangeConfiguration(e.Ctx, &params); err != nil {
-		e.T.Fatal(err)
-	}
-}
diff -urN a/gopls/main.go b/gopls/main.go
--- a/gopls/main.go	2000-01-01 00:00:00.000000000 -0000
+++ b/gopls/main.go	1969-12-31 19:00:00.000000000 -0500
@@ -1,26 +0,0 @@
-// Copyright 2019 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// The gopls command is an LSP server for Go.
-// The Language Server Protocol allows any text editor
-// to be extended with IDE-like features;
-// see https://langserver.org/ for details.
-//
-// See https://github.com/golang/tools/tree/master/gopls
-// for the most up-to-date information on the gopls status.
-package main // import "golang.org/x/tools/gopls"
-
-import (
-	"context"
-	"os"
-
-	"golang.org/x/tools/gopls/internal/hooks"
-	"golang.org/x/tools/internal/lsp/cmd"
-	"golang.org/x/tools/internal/tool"
-)
-
-func main() {
-	ctx := context.Background()
-	tool.Main(ctx, cmd.New("gopls", "", nil, hooks.Options), os.Args[1:])
-}
diff -urN a/gopls/test/gopls_test.go b/gopls/test/gopls_test.go
--- a/gopls/test/gopls_test.go	2000-01-01 00:00:00.000000000 -0000
+++ b/gopls/test/gopls_test.go	1969-12-31 19:00:00.000000000 -0500
@@ -1,32 +0,0 @@
-// Copyright 2019 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package gopls_test
-
-import (
-	"os"
-	"testing"
-
-	"golang.org/x/tools/gopls/internal/hooks"
-	cmdtest "golang.org/x/tools/internal/lsp/cmd/test"
-	"golang.org/x/tools/internal/lsp/source"
-	"golang.org/x/tools/internal/lsp/tests"
-	"golang.org/x/tools/internal/testenv"
-)
-
-func TestMain(m *testing.M) {
-	testenv.ExitIfSmallMachine()
-	os.Exit(m.Run())
-}
-
-func TestCommandLine(t *testing.T) {
-	cmdtest.TestCommandLine(t, "../../internal/lsp/testdata", commandLineOptions)
-}
-
-func commandLineOptions(options *source.Options) {
-	options.Staticcheck = true
-	options.GoDiff = false
-	tests.DefaultOptions(options)
-	hooks.Options(options)
-}
